# AI駆動開発の基本ガイドライン

## 1. はじめに

AI駆動開発とは、大規模言語モデル（LLM）を活用して効率的かつ一貫性のあるソフトウェア開発を行うための方法論です。このガイドラインでは、タスクリスト駆動開発を中心に、AIエージェントと協業するための体系的なアプローチを解説します。

## 2. 大方針：タスクリスト駆動開発

タスクリスト駆動開発は、開発作業を「計画（Plan）」と「実行（Act）」の2つのフェーズに分けて進める方法論です。

### 2.1 主な利点

- **ベンダー非依存性**：マークダウンベースのドキュメント管理により、特定のAIツールに依存せず、より良いエージェントへの移行が容易
- **コンテキスト最適化**：一貫性を確保しながら不要な文脈の肥大化を防止
- **再現性の向上**：計画ベースの作業により、AI作業の再現性が高まる
- **効率的な修正プロセス**：問題発生時に一括ロールバックし、フィードバックを計画に反映させることで、コンテキストの肥大化による性能劣化を防止

## 3. コンテキスト管理の重要性

AI駆動開発の成否は適切なコンテキスト管理にかかっています。

### 3.1 管理すべき3つの要素

- **量・圧縮**：情報量を適切に調整し、AIが上手に処理できる範囲に収める
  - 参考：[言語モデルの長文コンテキスト処理：「Lost in the Middle」現象の実態と最新研究](https://zenn.dev/kimkiyong/articles/c0250864d53595)
  - 参考：[NoLiMa：リテラルマッチングを超えた長文脈評価の新基準](https://zenn.dev/kimkiyong/articles/15cbd1049fb2f3)
- **一貫性**：矛盾のない情報提供によりAIの誤解や混乱を防止。特に複数のステップにまたがるタスクでは、コンテキストの一貫性欠如がAIの性能を著しく低下させることが研究で示されている
  - 参考：[AI開発者が知るべき真実：コンテキスト一貫性とAIコーディングエージェントの性能の関係](https://zenn.dev/kimkiyong/articles/8c98ca7b425d18)
- **構造**：情報の構造化によりAIが理解しやすくする。XMLやJSONなどの構造的フォーマットを用いることで、AIの理解度と出力の一貫性が向上する
  - 参考：[意味的構造化プロンプト設計：AIとの効果的な協働のための新パラダイム](https://zenn.dev/kimkiyong/articles/0320559fc099c6)

## 4. ドキュメント管理体系

以下の3種類のドキュメントでプロジェクト情報を管理します。

### 4.1 Specification（知識）

- プロジェクト概要、アーキテクチャ、背景情報などを整理したドキュメント
- `spes/`等の ディレクトリに保存
- 長期的に参照される基盤的な情報を含む

### 4.2 Procedure（手順）

- タスク作成等の一連のプロンプトを一般化させたテンプレート
- 成功したタスク実行後に、そのプロセスを一般化したプロンプトとして保存
- 再利用可能なプロンプトパターンのライブラリとして機能

### 4.3 Task（タスク）

- AIエージェントが実行する具体的な作業を単一ステップで記述
- この情報のみをコンテキストに含めることで、期待する出力を得られるよう設計
- タスク単位でセッションを分離し、コンテキストの混乱を防止

### 4.4 Memory-bankを廃止した理由

過去に使用していたMemory-bank（セッション間でコンテキストを維持するための構造化ドキュメント）は以下の理由により廃止しました：

- **知識のサイロ化問題**：個人的なメモリーバンクが増えることで、チーム全体での知識共有が困難になる問題
  - 参考：[共有コンテキスト・知識のサイロ化問題](https://x.com/cline/status/1907186512506306572?s=12)
- **コンテキスト肥大化問題**：時間経過とともにメモリーバンクが肥大化し、AIの処理能力に負担をかける問題
  - 参考：[Memory-bankの使い分け：大規模コードベースでの考慮点](https://zenn.dev/jtechjapan_pub/articles/a1cace00f7f96f#memory-bank%E3%81%AE%E4%BD%BF%E3%81%84%E5%88%86%E3%81%91%EF%BC%9A%E5%A4%A7%E8%A6%8F%E6%A8%A1%E3%82%B3%E3%83%BC%E3%83%89%E3%83%99%E3%83%BC%E3%82%B9%E3%81%A7%E3%81%AE%E8%80%83%E6%85%AE%E7%82%B9)

代替手段として：

- 共有コンテキスト・知識は `specifications/` ディレクトリで管理
- セッションを跨いだ情報は各タスク単位の最小限のコンテキストとして `tasks/` ディレクトリで管理

この方式により、知識の共有性を高めつつ、コンテキストの肥大化を防止します。

### 4.5 ドキュメント更新の原則

- 量の圧縮と一貫性確保や人間の言語化能力を補うために、AIエージェント自身にドキュメント更新を依頼する
- 人間はレビューと承認を行い、品質を担保

## 5. タスクリスト駆動開発のフロー

```mermaid
graph TD
    subgraph "タスクリスト駆動開発"
        subgraph "計画フェーズ（Plan）"
            A[開発タスクの発生] --> B[作業単位ディレクトリの作成]
            B --> C[AIエージェントと対話して作業を細分化]
            C --> D[タスクの優先順位付け]
            D --> E[タスク記述ファイルの作成]
            E --> F[各タスクに具体的な指示を記載]
        end
        
        subgraph "実行フェーズ（Act）"
            G[タスク実行：AIに指示] --> H{結果は期待通り?}
            H -- Yes --> I[次のタスクへ進む]
            H -- No --> J[フィードバックをタスクに反映]
            J --> K[セッションを切り替えて再実行]
            I --> L[全タスク完了?]
            K --> G
            L -- Yes --> M[プロセスの一般化]
            L -- No --> G
            M --> N[一般化プロンプトをprocedureに保存]
        end
        
        F --> G
        N --> O[次のタスクリストで活用]
    end
    
    style 計画フェーズ（Plan） fill:#d0e0ff,stroke:#0066cc
    style 実行フェーズ（Act） fill:#ffe0d0,stroke:#cc6600
```

### 5.1 計画フェーズ（Plan）

1. **作業単位ディレクトリの作成**
    - Issue等の開発作業単位でディレクトリを作成し、タスクリストとして管理
2. **作業の細分化**
    - AIエージェントと対話しながら作業を細分化
    - 細分化された各項目をタスクとし、その集合をタスクリストとする
3. **タスク記述ファイルの作成**
    - 各タスクに対してマークダウンファイルを作成
    - 超具体的な作業指示プロンプトを記載
    - ファイル名の先頭に番号（例：`1_`）や日付(例: `20250414-`)を付けて実行順序を明確化
    - 必要なコンテキストは全てタスク内のプロンプトに明記
    - 必要に応じて`specifications`ドキュメントを参照するよう指示

### 5.2 実行フェーズ（Act）

1. **タスク実行**
    - タスクに従って作業を行うようAIに指示
2. **結果の評価**
    - 期待通りの結果が得られた場合は次のタスクへ進む
    - 期待通りでない場合はフィードバックをタスクに反映させる
    - セッションを切り替え、修正版のタスクに従って作業するよう指示
3. **プロセスの一般化**
    - タスクが全て完了したら、類似作業のための一般化されたプロンプトを作成
    - `procedure` ディレクトリにマークダウンファイルとして保存

## 6. モデル選定のガイドライン

- **一貫性の確保**：各工程で使用する言語モデルは統一する
- **応答の一貫性**：同じモデルを使用することでプロンプトに対する応答パターンが安定する
- **累積的改善**：`procedure`の改善が後続のタスクにプラスに積み重なるようにする
- 参考：[モデル選定について](https://zenn.dev/kimkiyong/articles/84c8488400118d) - モデルによって最適なプロンプトが変わるため、一貫したモデル使用が重要です

## 7. 実践のためのベストプラクティス

1. **コンテキストの最小化**：必要最低限のコンテキストのみをAIに提供
2. **明確なタスク定義**：各タスクは単一の明確な目的を持つよう設計
3. **フィードバックループの確立**：問題発生時の迅速なフィードバック反映プロセスを確立
4. **ドキュメント管理の自動化**：可能な限りAIにドキュメント更新を任せる
5. **モデル特性の理解**：使用するAIモデルの特性と限界を理解し、適切なタスク分割を行う

## 8. まとめ

AI駆動開発は、適切なコンテキスト管理と体系的なタスク分割を通じて、AIの能力を最大限に活用するアプローチです。タスクリスト駆動開発の手法を取り入れることで、AIとの効率的な協業が可能になり、開発プロセス全体の品質と一貫性を高めることができます。

## 9. 実践的Tips

ここでは、AI駆動開発を実践する際に役立つ具体的なテクニックを紹介します。

### 9.1 コンテキスト管理の実践

- **タスクリスト駆動でのアプローチ**：本ガイドラインで説明したタスクリスト駆動開発は、コンテキストウィンドウの圧縮と一貫性維持の両方に有効です
- **必要最小限の情報提供**：AIに与える情報は必要最小限に抑え、重要な情報が埋もれないようにします

### 9.2 プロンプト理解の確認方法

- **理解度確認の指標設定**：AIがプロンプトを理解しているか、またはコンテキストから情報が欠損していないかを確認するための指標を設定します
  - 例：規範となるルールを読み込んだら特定の口調に変える
  - 例：タスク開始時に特定の文言（「[ACTIVE]」など）を表示させる

### 9.3 構造を意識したプロンプト設計

- **シンプルな文構造の使用**：日本語特有の句読点や助詞を使った意味的に連なった複雑な文章を避け、英文法におけるSVOレベルのシンプルな文章を重ねる
- **段階的な指示**：複雑なタスクは段階的に指示する
  - 例）プロジェクトや既存アーキテクチャを踏まえて実装計画を立てるプロンプト：
    1. プロジェクト概要を深く理解してください。
    2. 既存コードを徹底的に調査してください。
    3. 実装計画を立ててください。

### 9.4 AIの応答品質を高めるテクニック

- **感情を促す言葉の追加**：研究によると、感情を促す言葉を追加することでAIの性能が向上する場合があります
  - 例：「君ならできる！」
  - 例：「成功しないと怒ります。」
  - 参考：[LLMsをより良く機能させる感情的言語の研究](https://arxiv.org/pdf/2307.11760)

### 9.5 AIによるプロンプト生成の活用

- **AIに対するプロンプトをAIに作成させる**：AIにタスクの目的や要件を説明し、そのタスクに最適なプロンプトを生成させることが効果的です
  - AIはプロンプトエンジニアリングの知識や過去の成功パターンを取り入れた高品質なプロンプトを生成できます
  - 人間が考えない角度からのプロンプト構造や表現方法を提案することもあります
- **プロンプトの反復的改善**：AIが生成したプロンプトを実際に使用し、結果に基づいてさらに改善点をAIに提案させる
  - 例：「このプロンプトでは〇〇の部分が不明確でした。より明確なプロンプトを生成してください」
- **メタプロンプト（プロンプトを生成するためのプロンプト）の活用**：
  - 例：「あなたは優秀なプロンプトエンジニアです。以下の目的に最適なプロンプトを作成してください：[目的]」

## 10. 将来の展望

本ガイドラインは現在のAI技術を前提としたものであり、急速なAI技術の進歩により、一部または全体が不要になる可能性があります。

- **技術進化の予測**：AI技術は急速に進化しており、2027年までに大きな進歩が予想されています
  - 参考：[AI 2027 ―― 元OpenAI社員らによる2027年の知能爆発予測](https://note.com/d_1d2d/n/n35a6d72b3f6f)

---

**注意**: このガイドラインは基本的な枠組みを提供するものであり、プロジェクトの特性や使用するAIモデルによって適宜調整することをお勧めします。
