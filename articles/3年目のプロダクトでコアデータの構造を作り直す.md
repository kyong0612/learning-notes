---
title: "3年目のプロダクトでコアデータの構造を作り直す"
source: "https://zenn.dev/nstock/articles/5409e32a0c78c3"
author:
  - "nono"
  - "Nstock Tech Blog"
published: 2025-10-10
created: 2025-10-14
description: |
  Nstock株式会社の株式報酬SaaSにおいて、ローンチから3年目を迎えたプロダクトのコア機能である「ストックオプションの個数/状態管理」をEvent Sourcingを用いて再設計したプロジェクトの実践記録。画面構造に依存したデータ設計から、Single Source of TruthとEvent Sourcingを組み合わせた設計への移行により、データ整合性と拡張性を大幅に向上させた事例。
tags:
  - "migration"
  - "Event sourcing"
  - "リファクタリング"
  - "architecture"
  - "データ設計"
  - "SSOT"
  - "SaaS"
---

## 概要

Nstock株式会社が提供する株式報酬SaaSのコア機能であるストックオプション（SO）の個数/状態管理機能を、Event Sourcingを用いて再設計したプロジェクトの詳細な記録。サービスローンチから3年が経過し、100社以上に導入される中で顕在化した技術的課題を、4ヶ月・延べ8人月のプロジェクトで解決した実践事例。

## 背景と課題

### プロダクトの成長に伴う構造的課題

株式報酬SaaSは、企業が発行するストックオプションについて、事務局と権利者をユーザとして手続きサポートや保有状況の可視化を提供する。開発初期は事務局の実務で遭遾する書面や帳票の情報を整理したUIが共通認知モデルの出発点となり、そのUI構造がそのまま物理的なデータ構造として実装された。

#### 初期設計の合理性

- 機能要件の不確実性が高い状態では、関係者と認識の齟齬を避けることが重要
- 手探りの状態での抽象化は、誤った/早すぎる抽象化のリスクが高い
- 画面に近いデータモデルから始めるのは妥当な判断

#### 顕在化した課題

**構造的な問題：**

- 画面ごとに異なるテーブルを参照（テーブル構造が代表的なユースケースとなる画面構造に一致）
- SO個数・状態変更時に関連するテーブルすべてに同期的に書き込み
- テーブル間の相関関係が断片化し、改修の影響範囲の見積もりが困難
- 基礎的な情報（権利者が保有するSO数など）を得るのに複数テーブルの結合が必要

**運用上の問題：**

- 整合性がアプリケーションロジックに委ねられ、実装誤りで不整合が永続化されやすい
- SQL Opsでのデータ修正時、関連箇所の網羅的な変更が必要で難易度が高い
- 改修時の見通しが悪く、新規メンバーの参入コストが高い

### 2つの抽象化された課題

#### 課題1: 重視したいプロダクト特性とのズレ

**現在重視すべきプロダクト特性：**

| 特性 | 重要度 | 理由 |
|------|--------|------|
| データ整合性 | ◎（最重要） | 金銭に関わるサービスのため、数のズレ・内部不整合は許容不可 |
| 拡張性 | ○（大事） | 機能拡張や変更が引き続き想定される |
| パフォーマンス | △（相対的に低い） | 利用頻度やデータ量から重要度は高くなく、事後改善可能 |

**既存の画面構造ベースの設計の評価：**

| 特性 | 評価 | 理由 |
|------|------|------|
| データ整合性 | △ | アプリケーションやDB制約で追加の工夫がない限り不整合が発生しやすい |
| 拡張性 | △ | ユースケース特化のデータ構造のため、新規ユースケース対応コストが高い |
| パフォーマンス | ◎ | 画面に必要なデータ構造をそのまま保持するため、参照時のコストは最小 |

立ち上げ時期には重要な特性を満たしていたが、ローンチから3年目を迎え、ドメイン理解が進み機能数が増えた状況では、相対的に優先度の下がる特性に最適化された状態となっていた。

#### 課題2: 知らないとバグる（Unknown Unknowns）

複数テーブル間の意味的な関連性はコードを読み解かなければ認知できず、考慮漏れがあれば容易に不整合が永続化される。

**更新処理の複雑さの例：**

「ある権利者が持っているSO個数を減らす」というケースで、以下のテーブルを順次更新する必要があった：

```java
public class AdjustmentEventsCreator {
    public void register(){
        registerAdjustmentEvents();        // 減少の事実を記録
        registerAdjustmentHistories();      // 画面表示用の履歴データ登録
        updateMemberSoSummary();           // 権利者のSO総数を更新
        updatePlan();                      // Planの残SO個数を減らす
        updateAndSaveStockOptions();       // SOの個数を更新
    }
}
```

構造的にすべてのテーブルを候補として関係性を認知する必要があり、機能数の増加に伴いいつかは認知の限界を迎える。データソース間の相関関係がコードとDBスキーマに断片化しており、機能改修時の妥当性検証が困難な「unknown unknowns」的な難しさを抱えていた。

## 技術的アプローチ

### 2段階のアプローチ

1. **Single Source Of Truth (SSOT)** となる基礎的なデータ管理空間を切り出す
2. データ管理空間において **Event Sourcing** を採用し、Eventの積み上げで状態を復元

### Single Source Of Truth

中核となるデータ管理領域を設け、「SOの個数/状態管理」という責務を担当させる設計。

**責務の分離：**

1. **データ管理領域：** 更新リクエストに対して時系列を通じた一貫した整合性保証と、現在の状態の適切な復元に集中
2. **更新処理：** データ管理領域への書き込みに専念し、実現したい変更内容をデータ管理領域への更新リクエストへ変換することと、不整合時のハンドリングに集中
3. **参照時：** 格納されたデータからのデータ抽出・結合に専念し、整合性を信頼

**利点：**

- この空間に「SOはどのような事柄の影響を受け、どのように変化するのか」のカタログが形成される
- 「何をしなければいけない/してはいけないか」がこのモジュールにリスト化され、「unknown unknowns」から脱却可能

### Event Sourcing

SOに状態/個数変化をもたらす出来事を「Event」として抽出し、これを順次適用することで現在、ひいてはある時点のSOの状態を復元可能とする設計。

**既存設計との違い：**

- **既存：** 画面UIに相当する処理結果そのもの（State）を保存
- **新設計：** 状態変化の原因となった事実（Event）を記録

**評価ポイント：**

- 参照方法の拡張について、Stateを保存する方法に比べアプリケーションで吸収できる余地が大きい
- 更新方法の拡張はEventの追加という形で対応可能
- 会計/帳簿管理的なデータ設計との親和性が高い
- 証跡管理の要件（削除の事実を残したい）を、EventをキャンセルするEventという形で自然に取り込める

**データの寿命の観点：**

各画面要件に最適な形に加工された結果（State）ではなく、その原因となった事実（Fact）を記録する考え方は、データの寿命を伸ばす。表示要件は柔軟に変化すべきだが、SOに影響を与える出来事が起きた事実自体は変化しない。

### 設計案の評価

新しい設計（SSOT + Event Sourcing）のプロダクト特性評価：

| 特性 | 以前の評価 | Event Sourcing | 備考 |
|------|-----------|----------------|------|
| データ整合性 | △ | ◎ | 保存時にEvent列の妥当性を検証可能。参照時は唯一のデータソースを参照するため画面間不整合は発生しない |
| 拡張性 | △ | ○ | 参照・更新方法の拡張に柔軟に対応可能 |
| パフォーマンス | ◎ | △ | 更新時は多少改善。参照時は常にEvent集合を復元する場合、悪化が予見される |

**パフォーマンスへの対応：**

- 単純なDBのI/Oが数倍に増加（1行 → 数行〜数十行）
- 多くのユースケースは最新の状態にのみ関心を持つため、最新状態をprojectionとして供給することで対応可能と判断
- Event Drivenな設計まで広げてStateを保持する形式とEventを保存する形式を両立させる選択肢もあったが、パフォーマンスの優先順位が高くないこと、事後的に追加可能なことから見送り

## 意思決定 - いつ倒すか

### タイミングの判断

**課題の緊急性：** 低い

- 向こう1-2年以内の機能は今の構造でも実装可能

**課題の性質：** 時間とともに膨らむ

- 機能間の関連グラフの本数が増えるほど悪化
- SOに関する新規機能の追加は影響範囲が広く、行いづらい状態

**タイミング的な要因：**

- マルチプロダクト間の連携を進めており、連携データの形式や仕様は後から変更しづらい。その前に「プロダクトにとって取り回しやすいデータの出し方」を見極める必要
- データの値域拡張（整数→小数）が予定され、現在のデータ構造では複数テーブルのマイグレーションが必要

**結論：** 重たい課題だが今が一番楽に倒せる

### 個人的なモチベーション

1. Event Sourcedなデータ設計は事業ドメインに近い会計の考え方に近く、アプローチとして筋が良い
2. Event Sourcingにチャレンジしてみたかった。設計に強みを持つ同僚と一緒に携われるタイミング
3. **シンプルな依頼や機能追加で大変なことをしなきゃいけない状況への怒り**

## 移行計画

### スコープ設定

**大前提：**

- **振る舞いは変えない**（ただし、実装過程で検出された仕様未定義の箇所の変更は許容）
- 今後の拡張性に備えた設計は、後から追加が困難なもののみ行う
- ストックオプションの個数と状態にスコープを絞る（権利者の状態管理などには手を出さない）

データ構造の飛躍を伴うため、機械的に・確実に検証できることを重視したスコープ設定。

### データ移行の7ステップ

![移行計画の概要図あり]

1. 基礎的なデータ構造を設計・実装（プロダクションコードから呼び出されないデータ空間の実装）
2. 旧データ構造から新データ構造へのマイグレーション処理を実装し、整合性検証
3. プロダクションコードから新旧両方のデータ構造に二重書き込み
   - 新データの書き込み例外はすべてログ出力のみで握りつぶす
4. プロダクションコードから新旧両方のデータ構造を二重参照し、比較の上旧データを返却
   - 新データの参照/比較時の例外はすべてログ出力のみで握りつぶす
5. **全データの検証バッチを実行**して整合性検証
6. 参照系から旧データ参照・比較処理を除却し、新データ構造から取得したデータを返却
7. 更新系において新データ構造にのみデータを書き込む

**全データ検証の重要性：**

- すべてのSOについて、すべての二重参照処理を通じて参照・比較して齟齬がないことを確認
- プロダクトの性質上、毎日頻繁に操作されるわけではないため、リリース後の早期発見は期待しづらい
- 確実に全件で検証する方法を採用

### 取らなかった選択肢

**1. インフラレベルでの隔離環境構築**

- DB replication + アクセスミラーリング + 新規実装系で動作検証
- 構築コストが過大と判断して見送り
- 愚直な二重参照/二重書き込みでも許容できないサービスレベル低下は見込まれないと判断

**2. 実装のリファクタリングを先行**

- 移行対象テーブルを隠蔽するClassを実装してから移行
- 適切なリファクタには洞察が必要で、実装と格闘した後の方が意義深いリファクタが可能
- 事前のリファクタは最低限に留め、後から整理する作戦を採用

## プロジェクトの成果

### 定量的な成果

- **リードタイム：** 4ヶ月程度
- **工数：** 延べ8人月程度
- **結果：** 概ね当初の予定通りの着地、大きな障害なく移行完了

### コードの簡素化

更新処理の例（`AdjustmentEventsCreator`）が以下のように簡素化：

**移行前：**

```java
public void register(){
    registerAdjustmentEvents();        // 減少の事実を記録
    registerAdjustmentHistories();      // 画面表示用の履歴データ
    updateMemberSoSummary();           // 権利者のSO総数
    updatePlan();                      // PlanのSO個数
    updateAndSaveStockOptions();       // SOの個数
}
```

**移行後：**

```java
public void register(){
    addEventsToStockOption();          // SOに対して減少Eventを追加
    updatePlan();                      // 既存のまま（今回のスコープ外）
    // 以下はEventからの導出項目となったので更新不要
}
```

### 定性的な成果

**プロジェクトを通じた学び：**

- ドメイン理解を深めながら設計・実装を磨き込んでいくプロセスが楽しかった
- 考慮漏れでEventの基礎設計を変更する必要が生じたが、2日で作り直せたことで実装力に自信
- 整合性を厳密に検証する機能により、仕様の余白を多く埋め、チームのドメイン理解を深められた
- プロダクトの中核部分へのディープダイブで解像度が非常に高まった

**後続プロジェクトへの影響：**

- 値域変更に携わったメンバーから、データマイグレーションを最小化して機能提供にかける日数を大幅に短縮できたとフィードバック
- 思ったより早く成果が収穫できている

## まとめ

ローンチ3年目を迎える株式報酬SaaSのコア機能であるストックオプションの個数/状態管理機能を、Event Sourcingを用いて再設計。技術的なチャレンジはあったが、検証を固く進めるなど攻めと守りのバランスを取りながら意思決定してプロジェクトを進行した。

**達成したこと：**

- この先10年の運用・拡張に耐えられるしなやかなデータ構造を生産し続けるよう、アプリケーションを脱皮
- 生み出すデータの寿命を数年伸ばせた

**今後の課題：**

- 安全にリリースするためにスコープアウトした課題は山積み
- 作ったアーキテクチャの時間の試練への挑戦は始まったばかり

**重要な教訓：**

1. プロダクトのフェーズに応じて重視すべき特性は変化する
2. 初期の正しい判断（画面構造ベースのデータ設計）も、時間とともに負債となりうる
3. 課題は時間とともに膨らむため、「今が一番楽に倒せる」タイミングの見極めが重要
4. 大胆な変更も、段階的な検証プロセスを踏めば安全に実施できる
5. Event Sourcingは会計的なドメインとの親和性が高く、データの寿命を伸ばす有効なアプローチ
