---
title: "Context Engineering"
source: "https://zenn.dev/kun432/scraps/d462287d9dbfa9"
author:
  - "kun432"
published: 
created: 2025-07-05
description: |
  「Context Engineering」という概念について、複数の専門家の意見や技術的な解説記事をまとめたZennスクラップの要約。このアプローチは、LLMにタスクを効果的に解決させるために、プロンプトだけでなく、関連する全ての情報（コンテキスト）を動的に設計・提供する技術を指す。
tags:
  - "ContextEngineering"
  - "PromptEngineering"
  - "LLM"
  - "AI"
  - "Agent"
---

## 概要

本稿は、Zennスクラップ「Context Engineering」で `kun432` 氏がまとめた、AI開発における「コンテキストエンジニアリング」という新しい概念に関する議論や技術解説の要約です。コンテキストエンジニアリングは、従来の「プロンプトエンジニアリング」から一歩進み、LLMがタスクを最適に解決できるよう、必要な情報を動的に組み込んで提供する技術体系を指します。

## 専門家による「コンテキストエンジニアリング」の提唱

ShopifyのCEOであるTobi Lütke氏や、著名なAI研究者であるAndrej Karpathy氏などが、「プロンプトエンジニアリング」よりも「コンテキストエンジニアリング」という用語を支持しています。彼らは、産業レベルのLLMアプリケーションにおいて、タスクの説明、 few-shot例、RAG、ツール、履歴といった多様な情報を適切にコンテキストウィンドウに組み込むことの重要性を指摘しています。これは単なるプロンプト作成にとどまらない、複雑で繊細な技術であるとされています。

## Lance Martin氏によるエージェントのためのコンテキストエンジニアリング

[元記事](https://rlancemartin.github.io/2025/06/23/context_engineering/)

LLMをCPU、コンテキストウィンドウをRAMに喩え、限られた「作業用メモリ」に、指示、知識、ツールからのフィードバックといった複数の情報ソースを効率的に詰め込む技術がコンテキストエンジニアリングであると定義しています。特にAIエージェントのような長期タスクでは、コンテキストが肥大化しやすく、コスト増や性能劣化（コンテキスト劣化症候群）を招くため、管理が不可欠です。

その解決策として、以下の3つのカテゴリを提示しています。

![](https://storage.googleapis.com/zenn-user-upload/c4bc7d38a4c1-20250629.png)

1. **コンテキストの圧縮 (Compression)**
    * **要約**: Claude Codeのオートコンパクト機能のように、再帰的・階層的に要約を行い、重要な情報を維持しつつトークン数を削減する。

2. **コンテキストの永続化 (Persistence)**
    * **格納**: ファイル(`CLAUDE.md`)、ベクトルDB、知識グラフなど、外部に情報を保存する。
    * **保存**: Reflexion（自己反省）やGenerative Agents（要約）のように、エージェントが経験から学んだ情報をメモリとして保存する。
    * **取得**: 保存したメモリから、類似度や重要度に基づいて必要な情報を検索・取得する。

3. **コンテキストの分離 (Separation)**
    * **スキーマ**: Pydanticモデルなどで情報を構造化し、必要な部分だけを選択的に読み込む。
    * **マルチエージェント**: OpenAI Swarmのように、関心事ごとにサブエージェントを立て、それぞれが独立したコンテキストを持つことで、全体のコンテキスト量を削減する。
    * **環境隔離**: HuggingFace CodeAgentのように、サンドボックス環境でコードを実行し、生成されたオブジェクト（画像、音声など）をコンテキスト外で管理する。

## Phil Schmid氏によるコンテキストの重要性

[元記事](https://www.philschmid.de/context-engineering)

成功するAIエージェントは、モデルの賢さよりも与えるコンテキストの質が重要であると説きます。コンテキストには、システムプロンプト、会話履歴（短期記憶）、過去のやり取りの要約（長期記憶）、RAGによる外部情報、利用可能なツール定義などが含まれます。

![](https://storage.googleapis.com/zenn-user-upload/a320e879e215-20250630.png)

会議のスケジュール調整を例に、「安っぽいデモ」と「魔法のようなプロダクト」の違いを説明しています。

* **安っぽいデモ**: ユーザーのリクエストのみを見るため、機械的で役に立たない返答になる。
* **魔法のようなプロダクト**: カレンダー、過去のメール、連絡先、利用可能なツール（招待送信機能）といった豊富なコンテキストを参照することで、人間のように状況を判断し、能動的で最適な提案が可能になる。

この「魔法のような」体験は、適切なタスクに適切なコンテキストを提供することで生まれると結論付けています。

## コンテキスト管理の6つの戦術

[元記事](https://www.dbreunig.com/2025/06/26/how-to-fix-your-context.html)

長いコンテキストは、誤情報の繰り返し（ポイズニング）や不要情報による混乱（コンフュージョン）といった問題を引き起こす可能性があります。これらを解決するための具体的な戦術として、以下を挙げています。

1. **RAG (Retrieval Augmented Generation)**: 必要な情報だけを検索してLLMに与える。
2. **ツール・ロードアウト**: タスクに関連するツール定義だけを選択的にコンテキストに含める。
3. **コンテキスト隔離**: タスクごとにスレッドやエージェントを分離し、コンテキストの汚染を防ぐ。
4. **コンテキスト剪定**: 不要な情報をコンテキストから削除する。
5. **コンテキスト要約**: 蓄積した情報を要約して短く保つ。
6. **コンテキスト・オフローディング**: 情報をコンテキスト外（スクラッチパッドなど）に保存し、必要に応じて参照させる。

## Dexter Horthy氏による「12-factor Agents」

[講演動画](https://youtu.be/8kMaTybvDUw)

コンテキストエンジニアリングという用語の提唱者であるDexter Horthy氏が、信頼性、拡張性、保守性の高いLLMアプリケーションを構築するための12の原則を提唱しています。

1. **自然言語からツール呼び出しへ**: 入力を構造化されたアクションに変換する。
2. **プロンプトを管理する**: プロンプトをバージョン管理し、体系的に扱う。
3. **コンテキストウィンドウを管理する**: 上記の戦術を駆使してコンテキストを最適化する。
4. **ツールは構造化された出力**: ツールの実態は、LLMに特定の形式で出力を強制する手段である。
5. **実行状態とビジネス状態を統一する**: エージェントの状態管理を一元化する。
6. **シンプルなAPI**: `start/pause/resume` のような単純なインターフェースでエージェントを制御する。
7. **人間との連携**: ツール呼び出しを介して人間に助けを求められるようにする。
8. **制御フローの所有**: LLMではなく、アプリケーション側が全体の制御フローを管理する。
9. **エラーのコンパクトな要約**: エラー情報を簡潔にまとめてコンテキストに含める。
10. **小型で焦点を絞ったエージェント**: 複数の特化型エージェントを連携させる。
11. **どこからでもトリガー**: ユーザーがいる場所（チャット、IDEなど）でエージェントを起動・対話できるようにする。
12. **ステートレスなリデューサーとして設計**: エージェントを状態（State）と更新ロジック（Reducer）に分離し、スケーラビリティと再現性を確保する。

## まとめと考察

「コンテキストエンジニアリング」は、単なるバズワードではなく、LLMアプリケーションを実用的で信頼性の高いものにするための具体的な技術体系です。RAG、メモリ、ツール利用、状態管理といった要素を、タスクに応じて動的に組み合わせ、LLMの能力を最大限に引き出す設計思想と言えます。Andrew Hong氏が指摘するように、これらの多くは広義の「検索」と捉えることもできますが、その実現手法は多様であり、今後のAIエージェント開発における中核的なスキルセットとなるでしょう。

---
*このファイルは[Zennのスクラップ](https://zenn.dev/kun432/scraps/d462287d9dbfa9)の内容を包括的に要約・再構成したものです。*
