---
title: "DesignCoder: Hierarchy-Aware and Self-Correcting UI Code Generation with Large Language Models"
source: "https://arxiv.org/html/2506.13663v1"
author:
  - "Yunnong Chen"
  - "Shixian Ding"
  - "Yinying Zhang"
  - "Wenkai Chen"
  - "Jinzhou Du"
  - "Lingyun Sun"
  - "Liuqing Chen"
published:
created: 2025-11-19
description: |
  DesignCoderは、UIデザインモックアップから高品質なフロントエンドコードを生成する階層認識型で自己修正機能を持つ自動コード生成フレームワーク。UI Grouping Chainによる階層構造の理解、分割統治アプローチによるコード生成、視覚比較に基づく自己修正メカニズムを組み合わせることで、視覚的一貫性とコード品質の両立を実現。React Nativeフレームワークでの評価では、視覚類似度指標（MSE、CLIP、SSIM）で37.63%、9.52%、12.82%の改善、コード構造類似度指標（TreeBLEU、Container Match、Tree Edit Distance）で30.19%、29.31%、24.67%の改善を達成。
tags:
  - "clippings"
  - "UI Code Generation"
  - "Large Language Models"
  - "React Native"
  - "Multimodal Learning"
  - "Frontend Development"
---

## DesignCoder: Hierarchy-Aware and Self-Correcting UI Code Generation with Large Language Models

## 概要

DesignCoderは、UIデザインモックアップから高品質なフロントエンドコードを自動生成する階層認識型で自己修正機能を持つフレームワーク。マルチモーダル大規模言語モデル（MLLM）を活用し、視覚的一貫性と機能的な完全性を両立させる。既存手法の課題（要素の欠落、配置の歪み、階層構造の誤認識）を解決するため、UI Grouping Chain、階層認識コード生成、自己修正コードリファインメントの3つの主要コンポーネントを導入。

## 1. 背景と課題

### 1.1 既存手法の課題

- **視覚的一貫性の問題**: 生成されたコードのレンダリング結果が、要素の欠落、歪み、配置のずれを引き起こす
- **階層構造の誤認識**: 複雑なUIの階層構造を正確に解釈できない
- **エラー検出・修正の欠如**: 生成されたコードの視覚的・機能的な正確性を評価・修正するメカニズムがない

### 1.2 研究の動機

Figure 1では、既存手法の典型的な問題が示されている：

- 赤いボックス1: 要素の欠落
- 赤いボックス2: 配置の誤り
- 赤いボックス3: 要素の歪み
- 青いボックス4: 構造化されていないコード、機能的な意味の欠如

## 2. アプローチ

### 2.1 全体アーキテクチャ

DesignCoderのワークフローは3つの主要ステップで構成される：

1. **UI Grouping Chain**: UIデザインモックアップを入力として、階層的なコンポーネントツリーを構築
2. **Hierarchy-Aware Code Generation**: コンポーネントツリーに基づいて分割統治アプローチでコードを生成
3. **Self-correcting Code Refinement**: 視覚比較により生成コードのエラーを検出・修正

### 2.2 UI Grouping Chain

UI Grouping Chainは、複雑なUI階層構造を理解するための3つのサブタスクに分解：

#### 2.2.1 UI Division（UI分割）

- デザインファイルからメタデータ（id、type、bbox）を抽出
- LLMベースの分割ツールを使用して、セマンティック関係に基づいてUIを複数の領域に分割
- 検証と後処理により、以下の原則を確保：
  - 各要素は単一の領域に属する（大きなコンテナと背景は別途処理）
  - 領域は相互排他的で重複しない
  - 領域数は3〜10の範囲に収まる

#### 2.2.2 Semantic Extraction（セマンティック抽出）

- 各分割されたサブリージョンに対して、カスタマイズされたセマンティック抽出プロンプトを使用
- UI要素の意味的注釈を生成（例：「'Search for fruit salad combos'を表示するプレースホルダーテキスト」）
- 視覚的強化技術を適用して、識別が困難な要素を注釈

#### 2.2.3 Component Grouping（コンポーネントグループ化）

- 構造化されたグループ化プロンプトを使用して、要素を階層的なコンポーネントツリーに組織化
- 後処理により、ランダムに生成されたリーフノードや重複コンポーネントを防止
- フラットな要素リストを明確な階層構造に変換

### 2.3 Hierarchy-Aware Code Generation

#### 2.3.1 コンポーネントコード生成

- UI Grouping Chainで生成された階層的コンポーネントツリーを入力として使用
- コードプロンプトは4つのステップで構成：
  1. 役割の割り当て: LLMをReact専門家として指定
  2. タスクの説明: コンポーネントツリーに厳密に従ってReactコンポーネントを生成
  3. 詳細要件: サブリージョン名をコンポーネント識別子として割り当て
  4. 出力例: 適切なコンポーネントタグとイベントハンドラを選択

- 例: スクロール可能なビューの場合、デザインでスクロール動作が明示的に定義されていれば、`<ScrollView>`コンポーネントを選択

#### 2.3.2 CSSスタイル生成

- デザインメタデータと構造化されたコンポーネント情報を活用
- レイアウト生成: 階層ツリーを下から上にトラバース
  - リーフノードは要素に対応し、元のbbox属性を保持
  - 非リーフノードは子ノードからバウンディングボックスデータを集約
- テキスト属性（スタイル、色、フォント、太さ）を体系的に抽出
- パディング、ボーダー、シャドウ、コーナースタイルをデザインメタデータに従って生成
- 異なる画面サイズに対応するレスポンシブデザインを提供

### 2.4 Self-correcting Code Refinement

#### 2.4.1 エラー検出

- Appium（UI自動化テストツール）を使用してレンダリングされたページのスクリーンショットをキャプチャ
- コンポーネント属性（バウンディングボックス、要素タイプ、テキストコンテンツ、階層構造）を抽出
- コンポーネントツリーのコンポーネントIDを使用してレンダリングされたコンポーネントをマッチング
- 各コンポーネントのバウンディングボックスに基づいて画像セグメントを抽出

#### 2.4.2 視覚分析とコード修正

- 視覚分析プロンプトを使用して、元の画像とレンダリングされた画像を詳細に比較
- 要素の配置誤りやスタイルエラーを特定
- 修正提案を生成し、関連するコンポーネントコードスニペットと組み合わせて構造化コード修正プロンプトを作成
- 各コンポーネントは独立して修正可能なため、プロセスを並列化可能
- コンポーネントツリーの順序に従ってコードスニペットをマージ

#### 2.4.3 典型的なエラータイプ

Figure 4では、3つの典型的なエラータイプが示されている：

- **赤いボックス**: 配置がずれた要素
- **青いボックス**: 歪んだ要素
- **黄いボックス**: 欠落した要素

Case 1では、誤って生成された青い背景と配置がずれた要素を検出・修正。Case 2では、重複要素の特定と背景画像の角丸の調整を実行。

## 3. 評価

### 3.1 データセット

- 300個のモバイルアプリケーションUIデザインモックアップ
- 5つのカテゴリ: エンターテインメント、教育、健康、ショッピング、旅行
- 250個はFigmaコミュニティから、50個は大手インターネット企業から（Sketchファイル）
- Figma CLIを使用して標準化された画像アセットとデザインメタデータを抽出

### 3.2 ベースライン手法

#### 3.2.1 モバイルUI生成専用手法

- **Prototype2Code**: フラグメント要素グループ化とセマンティックグループ化技術を使用。手作りのルールでレイアウトツリーを生成
- **DeclarUI**: 教師なし要素検出モデルとSegment Anything Modelを統合。ページ遷移グラフを導入してインタラクティブロジックを構築

#### 3.2.2 汎用MLLM

- **GPT-4o**: OpenAI開発。優れた画像理解能力を持つ
- **Claude-3.5**: Anthropic開発。複数のMLLMベンチマークで優れた性能を発揮
- **LLaVA-v1.5-7B**: エンドツーエンドで訓練されたマルチモーダル大規模モデル

### 3.3 評価指標

#### 3.3.1 視覚類似度指標

- **MSE (Mean Squared Error)**: ピクセル単位の差分を測定。値が低いほど類似度が高い
- **CLIP Score**: 生成されたUIと元のUIのセマンティック類似度を定量化。CLIP特徴表現間のコサイン類似度を測定
- **SSIM (Structural Similarity Index Measure)**: レイアウトと構成的正確性を評価。空間配置の類似性に焦点

#### 3.3.2 コード構造類似度指標

- **TreeBLEU**: 生成されたHTMLのDOMツリーとグラウンドトゥルースの類似度を評価。タグ属性（コンテンツやスタイル）を含む終端ノードを除外
- **Tree Edit Distance (TED)**: 1つのツリーを別のツリーに変換するために必要な最小「編集」操作数に基づくツリー類似度の測定
- **Container Match (CM)**: 要素のグループ化に焦点。各コンテナのIoUスコアの平均を計算

### 3.4 RQ1: 有効性

#### 3.4.1 視覚指標の結果

Table 1の結果：

- **Figmaデータセット**: Prototype2Codeと比較して、MSE 37.64%改善、CLIP 9.52%改善、SSIM 12.82%改善
- **企業データセット**: MSE 24.31%改善、CLIP 4.60%改善、SSIM 11.69%改善
- DeclarUIと比較しても、同じ基盤モデル（GPT-4o）を使用しながら優れた性能を発揮

#### 3.4.2 構造指標の結果

Table 2の結果：

- **Figmaデータセット**: TreeBLEU 30.19%改善、Container Match 29.31%改善、Tree Edit Distance 29.47%改善
- **企業データセット**: TreeBLEU 17.78%改善、Container Match 22.45%改善、Tree Edit Distance 26.33%改善

### 3.5 RQ2: アブレーション研究

Table 3の結果：

#### 3.5.1 UI Grouping Chainの除去

- CLIPスコア: 0.92 → 0.84
- SSIM: 0.88 → 0.79
- MSE: 22.43 → 38.92
- TreeBLEU: 42.4%減少
- Container Match: 43.8%減少

UI Grouping Chainが、複雑なUIページを処理するMLLMの能力を大幅に向上させることが示された。

#### 3.5.2 コードリファインメントモジュールの除去

- 視覚的・コード構造類似度スコアが両方とも低下
- フォントサイズ、欠落要素、配置誤り、色の歪みなどの詳細なスタイル問題を検出・修正する能力が確認された

### 3.6 RQ3: ユーザー研究とケーススタディ

#### 3.6.1 ユーザー研究

- **参加者**: React Nativeフレームワークで5年以上の経験を持つ5名のフロントエンド開発者
- **評価対象**: 15個のUIデザインプロトタイプ（旅行、通信、ショッピングの3カテゴリ）
- **評価指標**: コード可用性、修正時間、可読性、保守性

Table 4の結果：

- **コード可用性**: DesignCoder 4.52 vs. DeclarUI 3.57
- **修正時間**: DesignCoder 4.20 vs. DeclarUI 3.24
- **可読性**: DesignCoder 4.75 vs. DeclarUI 4.43
- **保守性**: DesignCoder 4.32 vs. DeclarUI 3.32

参加者のコメント：

- P1: 「以前使用したLLMと比較して、（生成されたコードの）構造がプロジェクトで書くものにより近い」
- P3: 「このコード（DesignCoderが生成）のコンポーネント化が優れており、複数の場所で再利用できる」

#### 3.6.2 ケーススタディ

Figure 5とFigure 6では、DesignCoderが以下の3つの主要側面で優れていることが示されている：

1. **視覚的忠実度**: コンポーネントレイアウトとスタイルを正確に再構築
2. **コンポーネントセマンティック完全性**: デザインパターンを効果的に識別し、同一コンポーネントを再利用
3. **レスポンシブ互換性**: 異なる画面サイズで最適なレンダリングを維持

## 4. 有効性への脅威

### 4.1 内的有効性への脅威

- **評価指標の信頼性**: CLIP ScoreとSSIMは、微妙な違いを捉えられない可能性がある
- **コード構造の手動注釈**: 実際のコード実装のベストプラクティスを完全に反映しない可能性がある

### 4.2 外的有効性への脅威

- **MLLM性能の変動**: 異なるMLLMはプロンプトに応じて異なる結果を生成する可能性がある
- **データセット規模**: 300サンプルでは、モバイルアプリケーションUIのすべてのバリエーションをカバーできない可能性がある

## 5. 関連研究

### 5.1 画像からコードへの生成

- **深層学習ベース**: Pix2Code、Sketch2Code、Screen Parsing
- **MLLMベース**: Design2Code、UICopilot、Vision2UI

### 5.2 モックアップからコードへの生成

- **Figma2Code**: メタデータベースのアノテーションアプローチ
- **企業レベルのプラットフォーム**: Imgcook、CodeFun
- **Prototype2Code**: デザインリント技術を組み込んで入力を改善

## 6. 結論

DesignCoderは、デザインモックアップから高品質なUIコードを生成する階層認識型で視覚誘導型の自己修正アプローチを提案。マルチモーダルチェーンオブソート推論フレームワークを通じてMLLMのUI理解を強化し、複雑なネストされた構造を効果的に認識。実証的評価により、DesignCoderが最先端のベースラインと最新のマルチモーダル大規模言語モデルの両方を上回ることを実証。MLLMと高忠実度フロントエンド開発の間のギャップを埋め、産業アプリケーションで実用的に実行可能なMLLM生成UIコードを実現。製品イテレーションサイクルを加速し、開発チームがコア機能と製品イノベーションにより集中できるようにする。

### 今後の研究

- 明示的なデザイン意図の組み込み
- コンポーネントライブラリの活用による動的コンポーネント動作の強化
- コンテキスト認識状態管理の改善

## 主要な貢献

1. **UI Grouping Chain**: UIマルチモーダルチェーンオブソートを活用してMLLMをガイドし、視覚処理とグループ化推論を通じてUIレイアウト認識を行う革新的アプローチ
2. **DesignCoder**: 階層認識と自己修正機能を持つMLLMベースのGUI-to-Code生成手法。構造化されたコンポーネントを生成しながらデザインメタデータを活用し、視覚的忠実度とコード品質の両方で優れた性能を実現
3. **包括的評価**: DesignCoderを最先端のベースラインと比較する包括的評価を実施。さらに、ユーザー研究を実施し、アプローチの有効性と実用性を検証

## 技術的詳細

### 実装詳細

- **基盤モデル**: GPT-4o（DeclarUIと同様）
- **フレームワーク**: React Native
- **自動化**: Pythonスクリプトを使用してAndroid Studio内の初期プロジェクトに生成コードを自動統合
- **コンパイル失敗時の処理**: コンパイルに失敗したコードには、すべての評価指標に0を割り当て

### パフォーマンス改善の要因

1. **階層関係の捕捉**: UIコンポーネントの階層関係を捕捉し、デザインメタデータを組み込むことで視覚的忠実度が向上
2. **マルチモーダルチェーンオブソート**: UIマルチモーダルチェーンオブソートを通じてMLLMのUI理解能力を強化し、UIコンポーネント間のセマンティック関係をより深く理解
3. **自己修正メカニズム**: 微妙な問題を検出し、自律的に修正する自己修正コードリファインメントメカニズムにより、元のUIとの視覚的一貫性が向上
