---
title: "イベントストーミング＆イベントソーシング入門"
source: "https://www.youtube.com/watch?v=Bt_kXHlNL98"
author:
  - "[[なるセミ]]"
  - "[[成瀬允宣]]"
published: 2022-06-19
created: 2026-02-13
description: "JJUG CCC 2022 Springで発表されたセッション。イベントソーシングの基本概念（ジャーナル・リードモデル・スナップショット）、イベントストーミングによるドメインモデリング手法、およびAkka（Java/Scala）を用いた実装方法を、ECサイトの注文フローを題材にデモを交えて解説する。"
tags:
  - "clippings"
  - "event-sourcing"
  - "event-storming"
  - "domain-driven-design"
  - "akka"
  - "microservices"
---

## 概要

JJUG Cross Community Conference 2022 Spring における成瀬允宣氏（なるセミ）のトークセッション。ECサイトの注文フローを題材に、**イベントソーシング**の基本概念、**イベントストーミング**によるモデリング手法、そして**Akka**を使った実装までを一気通貫で解説する入門セッション（約40分）。

### 関連リソース

- [イベントストーミング ノーカット編集動画](https://youtu.be/jC9lE4YqgyY)
- [イベントストーミング図（Miroテンプレート付き）](https://miro.com/app/board/uXjVOM6Bdp0=/?share_link_id=945983148598)
- [サンプルコード（GitHub）](https://github.com/nrslib/akka-java-sample-order-service)

---

## 1. イベントソーシングとは

### 従来のデータベースとの違い

| 項目 | 従来方式（ステートソーシング） | イベントソーシング |
|------|------|------|
| 保存対象 | 現在のスナップショット（最新状態） | イベント（起きた事実）の履歴 |
| 履歴 | 上書きされ失われる | 完全に保持される |
| 類似システム | — | **Git**（差分の積み重ねで現在の状態を再構成） |

### 基本的な仕組み

- イベントごとに1行ずつデータを保存する
- すべてのイベントを最初から再生（リプレイ）することで、最新のデータ（スナップショット）を得る
- **Gitと同じ原理**: Gitがコミット（差分）からファイルの現在の状態を構築するように、イベントソーシングもイベントからシステムの状態を構築する

### 主要概念

- **ジャーナル（Journal）**: イベントを保存するデータストア。単一のイベント履歴がシステム全体の信頼できるデータソース（Single Source of Truth）となる
- **リードモデル（Read Model）**: ジャーナルのイベントから構築される読み取り用のビュー。各システムが自分にとって都合の良いリードモデルを自由に作成できる
- **Publisher / Subscriber**: イベントを保存する側（Publisher）と、イベントを購読してリードモデルを作る側（Subscriber）に分かれる

### イベントソーシングの利点

1. **新しいSubscriberの追加が容易**: ジャーナルにすべての履歴が残っているため、新しい読み取りシステムを追加しても、Publisher側のシステムに修正が不要
2. **Pub/Subアーキテクチャの自然な実現**: イベントソーシングはPub/Subパターンと非常に相性が良い
3. **マイクロサービスの課題解決**: マイクロサービスではデータストアが分離されるためJOINができないが、各サービスがジャーナルのイベントを購読して自分用のリードモデルを構築することで、この問題を解決できる

---

## 2. イベントストーミング

### イベントストーミングとは

- **ブレインストーミングのイベント版**: イベントを軸にシステムをモデリングする手法
- 色分けされた付箋を使い、まず思いつく限りイベントを出していき、そこに情報を書き足して段階的にモデルを完成させる
- **出来上がった図がそのままコードに落ちる**という点が大きなメリット

### 付箋の色と役割

| 色 | 要素 | 説明 |
|---|---|---|
| オレンジ | **イベント（Event）** | システムで起きた事実（過去形で表記） |
| 青 | **コマンド（Command）** | イベントを発生させるきっかけとなるアクション |
| 黄色 | **集約（Aggregate）** | 自システム内のビジネスロジックを持つオブジェクト |
| ピンク | **外部システム（External System）** | 自システム外のシステム（例: 銀行システム） |
| 紫（ライラック） | **ポリシー（Policy）** | 自動的に/条件付きで実行されるルール（「いつでも」「〜の場合」） |
| 緑 | **リードモデル（Read Model / View）** | 誰かが閲覧するもの（例: メール） |
| 小さい黄色 | **アクター（Actor）** | 操作を行う人（例: ユーザー） |
| ピンク（ダイヤ形）| **ホットスポット（Hot Spot）** | 留意点・後で議論すべき事項 |

### イベントストーミングの進め方（ECサイトの注文フローの例）

#### Phase 1: イベントの洗い出し

1. 一つのユースケース（例:「商品を注文して発送されるまで」）を選ぶ
2. 最初のきっかけとなるイベントを書く（例:「商品が注文された」）
3. 参加者全員でどんどんイベントを書き出す:
   - 商品が注文された
   - 決済がされた
   - 注文受付メールが送信された
   - 在庫が確保された
   - 商品が発送された　など
4. **ホットスポット**で留意点を記録（例: 決済方法 — クレジットカード/銀行振込/QRコード決済）
5. まずは「うまくいくケース」を考える

#### Phase 2: 時系列に並べる

- イベントを時系列順に並べ、矢印でつなぐ
- 並べることで抜けているイベントに気づきやすくなる

#### Phase 3: コマンド・集約・ポリシー等の追加

イベント間のつながりを色付き付箋で表現する。イベントからイベントへ直接つなげることはできないため、以下のルートで接続する：

- **上のルート（自動）**: イベント → ポリシー（紫） → コマンド（青） → 集約/外部システム → イベント
- **下のルート（手動）**: イベント → リードモデル（緑） → アクター → コマンド（青） → 集約/外部システム → イベント

#### Phase 4: 集約ごとにグルーピング

- 同じ集約に関連する要素をまとめる
- コマンドのオブジェクト名は目的語から決める（例:「商品の注文をする」→ 集約名は「注文」）
- **システム的な言葉ではなくドメイン的な言葉を使う**ことが推奨される
- 名前は気軽に決めてよく、参加メンバーで合意が取れればOK

#### Phase 5: 境界づけられたコンテキスト（Bounded Context）の分割

- 集約をグルーピングした後、さらにコンテキスト（サブドメイン）ごとに分ける
- 例: 注文、請求、通知、在庫 など
- 「これとこれは同じシステムだよね」というふわっとしたイメージで分割する

> **成瀬式の工夫**: ワークフロー図（元の時系列の図）は残しておき、集約ごとのグルーピングは別途コピーして作成することを推奨。ワークフロー図は開発者とドメインエキスパートの知識がマージされた重要な成果物であるため。

---

## 3. Akkaを使ったイベントソーシングの実装

### 技術選定

- **Akka**: リアクティブシステムを構築できるツールキットで、イベントソーシングをサポート
- Scala製だがJavaでも利用可能
- 発表者が検証した中で、最も自然かつ簡単にイベントソーシングを実現できたライブラリ
- ステートソーシング（従来方式）でも実装可能だが、イベントストーミングの図とシステムが乖離しやすい

### コード構造

#### コマンド（Command）

- `CommandRequest` インターフェースを定義し、各コマンドが実装する
- 例: `CreateOrderRequest` — ID等のオブジェクトを保持
- Javaの `record` 型を使用（フィールドがすべてfinalなクラス）
- `ReplyTo` でActorプログラミングにおける応答先を指定（成功/失敗の2種類）

#### イベント（Event）

- イベント用のインターフェースを定義し実装する（Akka Javaの都合上のインターフェースを使用）
- 例: `OrderCreated`（注文が作成された）、`OrderShipped`（注文が発送された）
- 必要なデータを保持するオブジェクト

#### 集約（Aggregate）

- 例: `Order`（注文）
- **作成メソッド**: `Order.create()` → イベント（`OrderCreated`）を返却する（stateの変更ではなくイベントを返す）
- **applyメソッド**: イベントを受け取り、そのイベントに従って状態を更新した新しいインスタンスを返却する（record型のため不変＝インスタンスを再作成）
- **ビジネスロジック**: 例えば `makeShip()` はstateが発送可能な状態であれば `OrderShipped` イベントを発行し、そうでなければエラーを返す

#### アグリゲートアダプター（Aggregate Adapter）

コマンドの受け取り → 集約への処理委譲 → イベントの永続化を担当する。3つの部分で構成：

1. **集約が空のとき**: 初期状態（null/empty）を設定
2. **コマンドを受けたとき**: コマンドに応じて集約のメソッドを呼び出し、結果のイベントを `Effect.persist()` で永続化
3. **イベントが保存されたとき**: 保存されたイベントを集約に `apply` して状態を更新

### イベントソーシングの動作原理

1. アダプターにコマンドをリクエスト
2. アダプターが集約のメソッドを呼び出し → イベントが返る
3. イベントをデータストアに永続化（persist）
4. 永続化後、イベントを集約に適用（apply） → 集約の状態が更新される

### リプレイ（Replay）

- リクエスト処理時、まず集約をnullでインスタンス化し、データストアから過去のすべてのイベントを読み出して1個ずつ適用していく
- 例: `OrderCreated` をapply → 状態が「作成済み」に → `OrderCancelled` をapply → 状態が「キャンセル済み」に → 新しいリクエストを処理
- **課題**: 毎回最初からイベントを再生するのは処理が重い

### スナップショット（Snapshot）

- リプレイの効率問題を解決する仕組み
- 特定のタイミングで集約の現在状態をシリアライズして保存しておく
- 次回のリクエスト処理時はスナップショットから状態を復元し、スナップショット以降のイベントだけを適用すればよい
- データストアからの全イベント読み出しをスキップできる

---

## 4. まとめ

1. **イベントソーシングはシステムをスケーラブルにする**: Pub/Subパターンにより、新しい読み取りシステムを柔軟に追加可能
2. **マイクロサービスの課題を解決する手法の一つ**: データストアが分離されてJOINができない問題を、イベント購読によるリードモデル構築で解消
3. **イベントストーミングはビジネスドメインのモデリングに最適**: 開発者とドメインエキスパートが共同でシステムの全体像を把握できる
4. **イベントストーミングの図を使った実装にはAkkaが適している**: 発表者の検証では学習コストが最も少なかった
5. **今回未紹介**: 実際のPub/Sub部分の実装は別の機会に

> **注意**: 本セッションではPub/Sub（Publisher/Subscriber間のイベント配信）の実装部分については扱われていない。