---
title: "バリューオブジェクト - Martin Fowler's Bliki (ja)"
source: "https://bliki-ja.github.io/ValueObject"
author:
  - "Martin Fowler"
  - "kdmsnr (翻訳者)"
published: 2016-11-14
created: 2025-10-11
description: "バリューオブジェクトとは、プロパティの値が同じであれば等価として扱われるオブジェクトのこと。プログラミングにおいて、複合データ（座標、金額、日付範囲など）を値として扱う際の設計パターンと実装方法、不変性の重要性について解説。"
tags:
  - "domain-driven-design"
  - "value-object"
  - "immutability"
  - "object-oriented-programming"
  - "software-design"
---

## 概要

バリューオブジェクトは、プロパティの値が同じであればオブジェクトとして等価と見なされるオブジェクトのことです。これは参照オブジェクト（同一性によって識別されるオブジェクト）と対比される重要な設計概念です。

## バリューオブジェクトとは

### 基本概念

プログラミングでは、物事を複合物として表現すると便利な場合が多くあります：

- **2次元座標**: x軸とy軸で構成
- **金額**: 数値と通貨で構成
- **日付範囲**: 開始日と終了日で構成
- **日付**: 年、月、日で構成

これらの複合オブジェクトが「同じものであるか」を判断する際、プロパティの値が同じであれば等価として扱うのがバリューオブジェクトです。

### 参照オブジェクトとの違い

**参照オブジェクト（エンティティ）**:

- オブジェクトの同一性（アイデンティティ）で識別
- 例: 販売注文（注文番号で識別）

**バリューオブジェクト**:

- プロパティの値で等価性を判断
- 例: 座標点(2,3)は別のインスタンスでも同じ値なら等価

## 言語ごとの実装

### JavaScript の問題点

素朴な実装では期待通りに動作しません：

```javascript
const p1 = {x: 2, y: 3};
const p2 = {x: 2, y: 3};
assert(p1 !== p2);  // 参照が異なるため不等価
```

クラスでequalsメソッドを実装する必要があります：

```javascript
class Point {
  constructor(x, y) {
    this.x = x;
    this.y = y;
  }
  equals (other) {
    return this.x === other.x && this.y === other.y;
  }
}
```

しかし、JavaScriptの標準ライブラリはこのequalsメソッドを認識しないため、`includes`などのメソッドでは使えません。

### Java の利点

JavaではPointクラスが`equals`メソッドをオーバーライドし、標準ライブラリ全体がこれを利用するため、期待通りに動作します：

```java
assertEquals(new Point(2, 3), new Point(2, 3)); // 成功
```

### 関数型言語

Clojureなどの関数型言語では、デフォルトで値として比較されます：

```clojure
(= {:x 2, :y 3} {:x 2, :y 3})  ; true
```

## 不変性の重要性

### エイリアスバグの問題

バリューオブジェクトは**不変であるべき**です。可変なバリューオブジェクトはエイリアスバグを引き起こします：

```java
Date retirementDate = new Date(Date.parse("Tue 1 Nov 2016"));
Date partyDate = retirementDate;  // 同じオブジェクトへの参照
partyDate.setDate(5);  // partyDateを変更
// retirementDateも変更されてしまう！
```

### 不変性による解決

不変なバリューオブジェクトを実装することで、エイリアスバグを回避できます：

```javascript
class Point {
  constructor(x, y) {
    this._data = {x: x, y: y};
  }
  get x() {return this._data.x;}
  get y() {return this._data.y;}
  // setterを提供しない
  equals (other) {
    return this.x === other.x && this.y === other.y;
  }
}
```

変更が必要な場合は、新しいオブジェクトを生成します。

## バリューオブジェクトの利点

### 1. プリミティブの置き換え

文字列などのプリミティブを適切なバリューオブジェクトに置き換えることで：

- **明確性の向上**: 変数やパラメータの意図が明確になる
- **型安全性**: 型チェックによる安全性（言語がサポートしている場合）
- **振る舞いの追加**: ドメイン固有のロジックをカプセル化できる
- **不適切な操作の防止**: 電話番号で算術演算するなどのミスを防ぐ

例: 電話番号を文字列ではなく`PhoneNumber`オブジェクトとして扱う

### 2. リッチな振る舞い

小さなバリューオブジェクトでも、リッチな振る舞いを持たせることができます：

- **範囲オブジェクト**: 重複チェック、包含判定など
- **金額オブジェクト**: 通貨換算、加算ルールなど
- **座標オブジェクト**: 距離計算、変換など

ドメイン固有のバリューオブジェクトに焦点を当てたリファクタリングによって、システムが劇的に単純化することが少なくありません。

## 設計上の考慮事項

### 文脈依存の判断

概念を参照オブジェクトとして扱うか、バリューオブジェクトとして扱うかは文脈に依存します：

- **住所**: 郵便物の配送では値として扱う
- **住所**: 高度なマッピングシステムでは階層化モデルとして参照オブジェクト化

### サイズの制約なし

- 小さなオブジェクト（点、金額、範囲）が典型例
- より大きな構造体でも、概念的な同一性を持たない場合はバリューオブジェクトとして実装可能
- 関数型言語では不変性がデフォルトのため、より自然に適合

## ドメイン駆動設計との関連

ドメイン駆動設計（DDD）では、Evansがバリューオブジェクトとエンティティを対比関係として分類しています：

- **エンティティ**: 参照オブジェクトの一般的な形態（ドメインモデル内でのみ使用）
- **バリューオブジェクト**: 値による等価性（すべてのコードで使用可能）

Vaughn Vernon氏の説明は、DDDの観点からバリューオブジェクトを議論したものとして最高のリソースとされています。

## 歴史的背景

- **90年代初頭**: 用語が広まり始める
- **PoEAAとDDD**: この概念を詳述した重要な書籍
- **混乱の原因**: J2EE文献でData Transfer Objectに対して「バリューオブジェクト」が使われたことがある（現在はほぼ使われない）

## まとめ

バリューオブジェクトは、一見些細に思えるかもしれませんが、適切に使用することで：

1. コードの明確性と安全性が向上
2. ドメインロジックを適切な場所にカプセル化
3. エイリアスバグを回避
4. システム全体の複雑性を劇的に削減

良いバリューオブジェクトのセットを見つけることで、システムは驚くほど単純化されます。不変性を原則とし、プリミティブの置き換えから始めることで、その恩恵を実感できるでしょう。
