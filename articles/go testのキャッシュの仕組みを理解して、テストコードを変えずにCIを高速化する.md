---
title: "go testのキャッシュの仕組みを理解して、テストコードを変えずにCIを高速化する"
source: "https://zenn.dev/drsprime/articles/go-test-cache-ci-optimization"
author:
  - "はやせ"
published: 2025-10-06
created: 2025-10-07
description: |
  go testのキャッシュ機構の内部実装を詳細に解説し、テストコードを変更せずにGitHub ActionsのCI実行時間を短縮する方法を紹介。パッケージ単位のキャッシュ管理、2段階のキャッシュ検索の仕組み、条件付きキャッシュクリアによる偽陰性の回避方法まで、実践的な最適化手法を解説します。
tags:
  - "Go"
  - "test"
  - "GitHub Actions"
  - "CI"
  - "キャッシュ"
  - "パフォーマンス最適化"
  - "clippings"
---

# サマリ

* `go test`は、パッケージごとにテスト結果をキャッシュする
* ソースコードに加え、テストコマンドの引数やテスト内で参照したファイル・環境変数がすべて同じならキャッシュが利用される
* 基本的にはCI上でもGoのキャッシュ機構を使用しても問題ない
* Goが検知できない変更（設定ファイルやデプロイ設定の変更など）がある場合は、キャッシュをクリアすることで偽陰性を回避する必要がある

# はじめに

GoのCI環境でテスト実行時間を短縮したいが、テストコード自体を改善するには大きな変更が必要な場合があります。本記事では、`go test`のキャッシュ機構をCI環境で活用し、テストコードを変更せずに実行時間を短縮する方法を紹介します。

ローカル環境では`go test`のキャッシュが自然に効いていますが、CI環境でも同じように活用できないかという疑問から、Goのソースコード（`src/cmd/go/internal/test/test.go`）を読み解き、キャッシュの内部実装を詳しく調査しました。

# go testのキャッシュとは

## 概要

Go 1.10からテストキャッシュ機能が導入されており、テストの実行結果をキャッシュして、同じ条件で実行する際には前回の結果を再利用できます。キャッシュが利用されると、テスト実行時に`(cached)`と表示されます。

```bash
$ go test ./...
ok      github.com/example/pkg1    0.123s
ok      github.com/example/pkg2    (cached)
ok      github.com/example/pkg3    0.456s
```

この機能により、変更されていないパッケージのテストをスキップし、テストの実行時間を短縮できます。

# キャッシュの仕組み

## パッケージ単位でのキャッシュ管理

**Goのテストキャッシュはパッケージ単位で管理されています**。`go test ./...`のように複数のパッケージをテストする場合、各パッケージごとに個別にテストが実行され、それぞれのテスト結果が別々にキャッシュされます。

```bash
$ go test ./...
ok      github.com/example/pkg1    0.123s
ok      github.com/example/pkg2    (cached)  # pkg2だけキャッシュヒット
ok      github.com/example/pkg3    0.456s
```

この例では、`pkg2`だけがキャッシュヒットしています。これは`pkg2`のソースコード、テストコード、依存するファイル、環境変数が前回の実行から変更されていないことを意味します。

このパッケージ単位のキャッシュ管理により、大規模なプロジェクトでも効率的にキャッシュを活用できます。あるパッケージを変更しても、変更していない他のパッケージのキャッシュは維持されるため、変更した部分のテストだけが実行されます。

## キャッシュ判定の全体フロー

`go test`を実行すると、各パッケージごとに以下のフローでキャッシュが判定されます：

1. **前提条件のチェック** - ローカルディレクトリモードやパッケージのルートチェック
2. **テスト引数の検証** - キャッシュ可能なフラグのみが使用されているかチェック
3. **2段階のキャッシュ検索**
   * 第1段階：テストIDの計算とテストログの取得
   * 第2段階：テストインプットIDの計算と結果の取得

## 1. 前提条件のチェック

### ローカルディレクトリモードの判定

`pkgArgs`が空の場合、つまり`go test`のように引数なしで実行された場合は、キャッシュが無効化されます。`go test ./...`や`go test ./pkg`のように明示的にパッケージを指定する必要があります。

### パッケージルートの確認

テスト対象のパッケージが、モジュール、`GOPATH`、`GOROOT`のいずれかの配下にある必要があります。これらの外にあるパッケージはキャッシュの対象外となります。

## 2. テスト引数の検証

コマンドライン引数がキャッシュ可能かどうかをチェックします。キャッシュ可能なフラグは以下のとおりです：

* `-test.benchtime`
* `-test.cpu`
* `-test.list`
* `-test.parallel`
* `-test.run`
* `-test.short`
* `-test.skip`
* `-test.timeout`
* `-test.failfast`
* `-test.v`
* `-test.fullpath`

これら以外のフラグが含まれている場合、キャッシュは利用されません。

**特別な扱いのフラグ**: `-test.coverprofile`と`-test.outputdir`は「キャッシュ可能だが、値が変わってもキャッシュを無効化しない」という扱いです。これらは出力先を変更するだけで、テストの実行結果には影響しないためです。

## 3. 2段階のキャッシュ検索

Goのテストキャッシュの核心部分は**2段階の検索**です。この仕組みにより、単純に「ソースコードが同じならキャッシュを使う」というだけでなく、「テストが依存する外部のファイルや環境変数の内容が同じか」までチェックすることで、キャッシュの検索を効率化しつつ、信頼性も高めています。

2つの異なるIDを組み合わせた**最終的なキー**でキャッシュを検索します：

* **`testID`**: テストのコード、ビルドフラグ、Goのバージョンなど、**テストバイナリ自体を決定する要素**から作られるID
* **`testInputsID`**: テスト実行時に**読み込まれる外部ファイル**や**参照される環境変数**の内容から作られるID

### 第1段階：テストIDの計算とテストログの取得

まず、テストバイナリの内容とコマンドライン引数から`testID`を計算します。この`testID`は、テストバイナリの内容（ソースコードやテストコード）、コマンドライン引数、実行コマンドから計算されます。ソースコードが変更されると、この`testID`も変わります。

次に、この`testID`を使って、前回のテスト実行時に記録された「テストログ」を取得します。テストログとは、前回のテスト実行時に**どの環境変数を参照し、どのファイルを読み込んだか**を記録したものです。

例えば、テストが`config.json`を読み、環境変数`API_KEY`を参照した場合、テストログには以下のような内容が記録されます：

```
# test log
getenv API_KEY
open /home/user/project/testdata/config.json
stat /home/user/project/testdata
```

### 第2段階：テストインプットIDの計算と結果の取得

取得したテストログを元に、現在の環境変数とファイルの状態から`testInputsID`を計算します。この`computeTestInputsID`関数が、2段階キャッシュの最も重要な処理です。

先ほど取得したテストログを元に、そこに書かれているファイルや環境変数を**現在のファイルシステムや環境から実際に読み込み**、読み込んだ**現在の内容**すべてのハッシュ値を計算します。

この仕組みにより、「テストコードは全く同じでも、`config.json`の中身が書き換わっている」といった状況を検知できます。その場合、`testInputsID`が前回と異なる値になるため、キャッシュはヒットしません。

#### 環境変数のハッシュ計算

環境変数が存在しない場合は`0`、存在する場合は`1`に続けて値をハッシュに含めます。環境変数の値が変わると、このハッシュ値も変わるため、キャッシュが無効化されます。

#### ファイルのハッシュ計算

ファイルのハッシュ計算では、ファイルの内容をハッシュ化するのではなく、**ファイルサイズとmodtime（更新時刻）をハッシュ化**しています。ファイルが非常に大きい可能性があるため、内容全体をハッシュ化するのを避け、mtimeとサイズで代用しています。

さらに、`modTimeCutoff`（2秒）よりも新しいファイルは、ファイルシステムの精度の問題で変更を検知できない可能性があるため、キャッシュを拒否します。

### 最終的なキャッシュキーでテスト結果を取得

`testID`と`testInputsID`の両方が計算できたら、それらを組み合わせた最終的なキャッシュキーで、実際のテスト結果を取得します。ここでデータが正しく取得できれば、テストはキャッシュヒットと見なされます。

キャッシュがヒットした場合、実行時間を`(cached)`に書き換えて出力します。

# GitHub Actionsでの実装

## Goのキャッシュ機構を活用する

これまで見てきたように、`go test`は以下の要素が変更されていない場合、自動的にキャッシュを利用します：

* ソースコードやテストコード（パッケージ単位）
* テスト実行時に参照した環境変数
* テスト実行時に読み込んだファイル

そのため、CI上で実行する場合も**基本的にはGoのキャッシュ機構に任せれば良い**です。GitHub Actionsの`setup-go`アクションを使っている場合は、ビルドキャッシュ（`~/.cache/go-build`）が流用されるため、Goのテストキャッシュも自然と利用されます。

```yaml
name: Test

on:
  push:
    branches: [main]
  pull_request:

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - uses: actions/setup-go@v5
        with:
          go-version-file: 'go.mod'

      - name: Run tests
        run: go test -v ./...
        # 変更されていないパッケージは (cached) と表示される
```

著者のプロジェクトでは、`~/.cache/go-build`自体は復元されていたものの、テストコマンドに`-race`などの非キャッシュ可能なフラグが含まれていたため、キャッシュが全く利用されていませんでした。これらのフラグを削除することで、キャッシュが正しく機能するようになりました。

## Goが検知できない変更への対処

**重要な注意点**: `go test`のキャッシュは**テスト実行時に実際に読み込まれたファイル**のみを追跡します。

以下のようなケースでは、Goのキャッシュ機構だけでは不十分です：

* 設定ファイル（`.yaml`など）やマイグレーションファイルを変更したが、ソースコードには含まれていない
* Dockerfileやデプロイ設定を変更した
* ドキュメントだけを更新した

これらの変更は、テスト実行に影響を与える可能性がありますが、Goのキャッシュ機構では検知できません。その結果、本来テストすべき変更があるのにキャッシュがヒットしてしまうため、**偽陰性**（テストが通ったように見えるが実際には問題がある）が発生するリスクがあります。

### 条件付きキャッシュクリア

この問題に対処するため、Goファイル以外の変更があった場合にキャッシュをクリアするGitHub Actionsを作成できます。`dorny/paths-filter`を使って、変更されたファイルがGoファイルのみかどうかを判定し、Goファイル以外の変更がある場合やmainブランチの場合は`go clean -testcache`でキャッシュをクリアします。

```yaml
name: Clean Go Cache Conditionally

runs:
  using: "composite"
  steps:
    - name: Check non go file changes
      id: changes
      uses: dorny/paths-filter@de90cc6fb38fc0963ad72b210f1f284cd68cea36 # v3.0.2
      with:
        predicate-quantifier: 'every'
        filters: |
          has-not-go-file:
            - '!**/*.go'
            - '!**/*.mod'
            - '!**/*.sum'
    - name: Clean test cache if needed
      shell: bash
      run: |
        if [ "${{ steps.changes.outputs.has-not-go-file }}" == "true" ] || [ "${{ github.ref }}" == "refs/heads/main" ]; then
          echo "Cleaning test cache due to non-go file changes or main branch"
          go clean -testcache
        else
          echo "Skipping cache clean - only go files changed and not on main branch"
        fi
```

このアクションを`.github/actions/clean-go-cache/action.yml`として保存し、ワークフローから以下のように呼び出せます：

```yaml
jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@08eba0b27e820071cde6df949e0beb9ba4906955 # v4.3.0

      - uses: actions/setup-go@d35c59abb061a4a6fb18e82ac0862c26744d6ab5 # v5.5.0
        with:
          go-version-file: 'go.mod'

      - name: Clean cache conditionally
        uses: ./.github/actions/clean-go-cache

      - name: Run tests
        run: go test -v ./...
```

これにより、Goファイルのみの変更の場合はキャッシュを保持してCIを高速化し、Goファイル以外の変更がある場合とmainブランチの場合はキャッシュを削除して完全なテストを保証できます。

# まとめ

`go test`のキャッシュの仕組みを理解することで、テストコードを変更せずにCIを高速化できます。

**重要なポイント**:

1. **パッケージ単位のキャッシュ**: 各パッケージごとに独立してキャッシュが管理される
2. **2段階のキャッシュ検索**: テストバイナリのID（`testID`）と外部依存のID（`testInputsID`）を組み合わせて判定
3. **キャッシュ可能な条件**:
   * ソースコード/テストコードが未変更
   * テスト引数が変更なし（キャッシュ可能なフラグのみ）
   * 参照した環境変数の値が同じ
   * 読み込んだファイルの内容が同じ
4. **CI環境での活用**: 基本的にはGoのキャッシュ機構に任せて良い
5. **偽陰性の回避**: Goが検知できない変更（設定ファイルなど）がある場合は条件付きキャッシュクリアで対処

実際の導入例では、**CIでのテスト実行時間を約9分から約3.5分へと、半分以下に短縮**することに成功しました。

導入は非常に簡単なので、テストの実行時間に悩んでいる方はぜひ試してみてください！
