---
title: "Effective context engineering for AI agents"
source: "https://www.anthropic.com/engineering/effective-context-engineering-for-ai-agents"
author:
  - "Prithvi Rajasekaran"
  - "Ethan Dixon"
  - "Carly Ryan"
  - "Jeremy Hadfield"
published: 2025-09-29
created: 2025-10-02
description: "Anthropic's Applied AI team explains how to curate high-signal context for LLM agents, covering strategies from prompt design to runtime retrieval, memory, and multi-agent workflows."
tags:
  - "context engineering"
  - "AI agents"
  - "prompt design"
  - "LLM memory"
  - "tooling"
---

## 概要

- **主張**: LLMエージェントの成功には、有限なコンテキストを高シグナルな情報で満たす「コンテキストエンジニアリング」が鍵になる（信頼度 9/10）。
- **背景**: プロンプト単体の調整から、ツール、履歴、外部データを含む全体的なコンテキスト設計へと関心が移行している。
- **重要イメージ**: ![Prompt engineering vs. context engineering](https://www-cdn.anthropic.com/images/4zrzovbb/website/faa261102e46c7f090a2402a49000ffae18c5dd6-2292x1290.png)
- **重要イメージ**: ![Calibrating the system prompt in the process of context engineering.](https://www-cdn.anthropic.com/images/4zrzovbb/website/0442fe138158e84ffce92bed1624dd09f37ac46f-2292x1288.png)

## コンテキストエンジニアリングとは

- **定義**: コンテキストエンジニアリングは、プロンプトだけでなくツールや履歴などを含むコンテキスト全体を最適化して望ましい挙動を引き出す設計手法。
- **関心の変化**: 単発タスク中心のプロンプトエンジニアリングから、複数ターンで動作するエージェントの状態管理へ焦点が移動。
- **課題意識**: エージェントはループ内で膨大なデータを蓄積するため、毎ターンでの取捨選択が必要。
- **用語整理**: MCPなどの外部プロトコルやメッセージ履歴もコンテキスト構成要素として扱う（信頼度 8/10）。

## なぜ重要なのか

- **コンテキストロット**: 長大なトークン列では正しい情報想起が難しくなる現象が全モデルに共通して確認される。
- **有限の注意資源**: トランスフォーマーは O(n^2) の注意計算のため、トークンが増えるほど重要箇所への注意が希薄化。
- **訓練分布の偏り**: 多くのモデルは短文中心で訓練されており、長文での精度低下が発生しやすい。
- **技術的背景**: 位置エンコーディング補間などで長文対応は可能だが、ポジション理解が劣化するトレードオフが残る（信頼度 8/10）。

## 効果的なコンテキストの構成要素

- **システムプロンプト**: 適切な「高度（right altitude）」を保ち、具体性と柔軟性のバランスを取る。過剰なif-elseや曖昧指示は避ける。
- **構造化**: `<instructions>` や Markdown見出しを使って明確に区切り、最小限で必要十分な情報を渡す。
- **ツール設計**: 重複機能を避け、入出力を明確かつトークン効率良くする。ツール数が多すぎるとエージェントの判断が不安定化。
- **例示管理**: 多数のエッジケース詰め込みよりも、多様で代表的なFew-shot例を厳選。

## コンテキストの取得とエージェント的探索

- **定義の再確認**: エージェント=LLMがループ内で自律的にツールを使う存在。
- **事前取得からオンデマンドへ**: 埋め込み検索などの事前取得に加え、実行時に必要情報を工具で引き込む「Just in time」戦略が普及。
- **Claude Code事例**: SQLクエリや`head`/`tail`で必要部分のみ読むことで、大規模データでもコンテキスト節約。
- **メタデータ活用**: ファイルパスや命名規則など周辺情報が取捨選択のヒントを与え、段階的な理解構築を助ける。
- **制約とハイブリッド**: 探索は遅くなるため、静的情報は事前取得・動的情報はオンデマンドというハイブリッド構成が有効（信頼度 8/10）。

## 長期タスク向け手法

- **課題設定**: コードベース移行やリサーチのような長時間タスクでは、コンテキスト窓を超える情報保持が必須。
- **コンパクション**: 会話履歴を高忠実に要約し、重要決定・未解決事項を残したまま新規コンテキストへ再投入。ツール結果クリアが低リスク施策。
- **構造化ノート**: エージェントが外部メモ（例: NOTES.md）に進捗・戦略を記録。Claudeのポケモン例で長期整合性を実証。
- **メモリツール**: Sonnet 4.5リリースとともに、ファイルベースで永続メモリを扱える公式機能を提供。
- **サブエージェント構成**: メインが計画を維持し、各サブが詳細探索を担当。結果を要約してメインに返すことでコンテキスト汚染を回避。
- **使い分け**: コンパクション=対話継続、ノート=マイルストーン管理、サブエージェント=大規模調査で効果的（信頼度 7/10）。

## まとめと提言

- **核心原則**: 有限な注意予算を意識し、高シグナルな最小トークン集合を設計することが成功要因。
- **進化の方向性**: モデル能力向上により自律性は上がるが、コンテキストの希少資源性は変わらない。
- **実装指南**: まず最小構成で試行し、失敗モードに応じて指示・例・ツールを段階的に追加。
- **リスク・制限**: オンデマンド探索は速度低下を招き、コンパクション過剰は重要情報喪失の危険あり。適切な検証とチューニングが必要（信頼度 7/10）。
- **リソース**: メモリとコンテキスト管理の実践例としてClaude Developer Platformとcookbookを参照可能。
