---
title: "Memory and Learning"
source: "https://www.greptile.com/docs/how-greptile-works/memory-and-learning"
author:
  - "[[Greptile]]"
published:
created: 2025-10-27
description: "Greptileのメモリシステムがどのようにチームとのやり取りから学習し、コードレビューの提案をパーソナライズしていくかを解説。チームのコメント、リアクション、コミット履歴から学習し、ノイズを削減しながら実用的な提案を提供する。"
tags:
  - "AI"
  - "code-review"
  - "machine-learning"
  - "developer-tools"
  - "greptile"
  - "clippings"
---

## 概要

Greptileのメモリシステムは、チームとのすべてのインタラクションから学習し、パーソナライズされた実用的なコードレビュー提案を提供します。時間とともに、チームの好みやコーディングスタイルを理解し、よりチームに特化した提案へと進化します。

## Greptileがチームから学習する3つの方法

### 1. PR上のチームコメントから学習

GreptileはPRでのコードレビューディスカッションのパターンを観察します。

**学習例：**

- チームが頻繁に「エラーハンドリングを追加して」とコメント  
  → Greptileの学習：**このチームはエラーハンドリングを重視する**

- チームがよく「これは非同期にすべき」と指摘  
  → Greptileの学習：**チームは非同期パターンを好む**

- チームが「これをサービスレイヤーに移動して」とフラグ  
  → Greptileの学習：**チームはレイヤードアーキテクチャに従っている**

### 2. Greptileへの返信から学習

開発者の応答から何が重要かを学習します。

**ポジティブな応答例：**

```text
Greptile: "このロジックをユーティリティ関数に抽出することを検討してください"
開発者: "良い指摘！リファクタリングします。"
→ Greptileの学習：コード構成の提案が評価されている
```

**文脈を設定する応答例：**

```text
Greptile: "これをキャッシュすることを検討してください"
開発者: "このエンドポイントは1日1回しか呼ばれないので不要です"
→ Greptileの学習：使用頻度の低いエンドポイントではキャッシュを提案しない
```

**否定的な応答例：**

```text
Greptile: "インデントを修正してください"
開発者: "自動フォーマッタが処理します"
→ Greptileの学習：スタイル関連の提案を抑制する
```

### 3. リアクションから学習

👍👎のリアクションが提案の品質について即座にフィードバックを提供します。

- **👍 = 有用な提案** → 類似の提案を継続
- **👎 = ノイズ/無関係** → 類似の提案を抑制
- **反応なし = 評価されていないか無視された** → 信頼度を低下

## 細かさレベルの学習

Greptileは、コミット分析とリアクションを通じて、チームの軽微な提案への許容度を学習します。

### コミットベースの学習

最初のコミットと最後のコミットを比較して、どのコメントが対応されたかを分析：

- **対応されたコメント** → 重要な問題
- **無視されたコメント** → ノイズの可能性
- **パターン追跡** → 繰り返し無視される問題タイプ

### 適応的ノイズフィルタリング

**高細かさチーム（スタイル問題に対応）：**

```text
✅ セミコロン不足
✅ import の整理
✅ 関数命名
✅ ドキュメント不足
```

**低細かさチーム（スタイル問題を無視）：**

```text
❌ セミコロン不足（3回無視後に抑制）
❌ import の整理（チームは気にしない）
✅ セキュリティ問題（常にフラグ）
✅ ロジックエラー（決して抑制しない）
```

### 学習しきい値

```javascript
// Greptileが追跡するパターン例：
const learningData = {
  semicolonComments: { made: 10, addressed: 0, reactions: -3 },
  securityComments: { made: 5, addressed: 5, reactions: +4 },
  performanceComments: { made: 8, addressed: 6, reactions: +2 }
};

// 結果：セミコロンコメントを停止し、セキュリティを優先
```

## 学習とメモリの影響

### より実用的なコメント

学習により、一般的な提案がチーム固有のガイダンスに変換されます。

**学習前（一般的）：**

```text
🤖 "エラーハンドリングの追加を検討してください"
🤖 "この関数は短くできます"
🤖 "ここにドキュメントを追加してください"
🤖 "インデントを修正してください"
```

**学習後（パーソナライズ）：**

```text
🤖 "チームのResult<T>パターンを使用したエラーハンドリングを追加してください"
🤖 "複数のドメインメソッドに分割することを検討してください（アーキテクチャに従って）"
🤖 "セキュリティ検証が不足 - 支払い機能に必要です"
```

### 文脈理解

Greptileはルールがいつ適用され、いつ適用されないかを学習します。

**文脈に応じたルール例：**

```javascript
// Greptileが学習するパターン：
class PaymentService {
  // ✅ ドメインロジックでは長い関数もOK
  processComplexPayment(data: PaymentData) {
    // 50行以上のビジネスロジック - チームはこれを受け入れる
  }
}

// ❌ しかしユーティリティでは長い関数をフラグ
function formatString(input: string) {
  // ここで20行以上あるとフラグされる
}
```

**チーム固有の基準：**

- テストファイルではアサーションの繰り返しを許可
- 設定ファイルでは長いオブジェクトリテラルを許可
- APIレイヤーでは検証が必須
- UIコンポーネントでは小さい関数を優先

### レビュー疲労の軽減

メモリがノイズを排除し、重要なことに焦点を当てます。

**測定可能な影響：**

- 無視されるコメントが **80%削減**
- 提案採用率が **3倍向上**
- PRレビューサイクルの高速化
- スタイルではなくアーキテクチャとロジックに焦点

## カスタムルールの発見

Greptileは手動設定なしで、チームの行動からカスタムルールを自動推測します。

### 自動生成ルール

**チームコメントから：**

```text
観察されたパターン：チームが常に「DB呼び出しをサービスレイヤーに移動して」とコメント
→ 自動生成ルール：「コントローラーは直接データベース呼び出しを含むべきではない」

観察されたパターン：チームが一貫して「入力検証を追加して」とリクエスト
→ 自動生成ルール：「APIエンドポイントには入力検証が必要」
```

**チーム固有のパターン：**

- 認証ミドルウェアの使用パターン
- エラーハンドリングの慣習
- 命名規則
- アーキテクチャ境界

### 学習の進化

**進化のタイムライン：**

- **第1-2週**：標準的な提案、高いノイズ
- **第3-4週**：チームの好みを学習、フィルタリング開始
- **第5-8週**：カスタムパターンが浮上、提案が改善
- **第9週以降**：高度にパーソナライズされた実用的な推奨事項

**学習の加速要因：**

- アクティブなPR活動
- 詳細なコメントフィードバック
- 一貫したリアクションの使用
- 明確なコーディング基準

## 実際の学習例

### チームA：セキュリティ重視のFintech

**学習の軌跡：**

```text
1ヶ月目：一般的なセキュリティ提案が無視される
2ヶ月目：チームが「カスタム認証ミドルウェアを使用している」とコメント
3ヶ月目：Greptileがチームの認証パターンを提案するように学習
結果：セキュリティ問題の提案採用率90%
```

**学習した項目：**

- カスタム認証フロー
- PCI準拠パターン
- 監査ログ要件
- 暗号化基準

### チームB：パフォーマンス重視のゲーム

**学習の軌跡：**

```text
第1週：スタイルコメントが👎リアクションを受ける
第3週：パフォーマンスコメントが👍リアクションを受ける
第6週：Greptileがスタイル提案を停止し、パフォーマンスに焦点
結果：より速いレビュー、より良いパフォーマンス最適化
```

**学習した項目：**

- メモリ割り当てパターン
- レンダリング最適化
- キャッシング戦略
- プロファイリングのベストプラクティス

## 学習とメモリが重要な理由

### 主要な利点

| 利点 | 説明 |
|------|------|
| **ノイズの排除** | チームが一貫して無視する提案をフィルタリングすることを学習 |
| **コンテキストの構築** | チームのユニークなパターンと好みを理解 |
| **採用の向上** | 提案の受け入れ率が高まり、コード品質が向上 |
| **時間の節約** | 無関係な提案についての往復議論を削減 |

## 学習の利点

従来の静的解析ツールは、すべてのチームに同じ一般的な提案を提供します。Greptileのメモリシステムは、以下のような個別化されたコードレビュー体験を作成します：

- **適応する** - チームのコーディングスタイルと好みに
- **学習する** - すべてのインタラクションとフィードバックから
- **進化する** - 時間とともにより価値を提供
- **焦点を当てる** - チームにとって実際に重要な問題に

**結果：** コードベースを理解し、決定を尊重し、ノイズなしでより良いコードを書く手助けをする、知識豊富なチームメイトのように感じられるAIコードレビュアー。
