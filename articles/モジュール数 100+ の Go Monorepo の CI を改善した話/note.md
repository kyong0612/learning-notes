# モジュール数 100+ の Go Monorepo の CI を改善した話

ref: <https://zenn.dev/knowledgework/articles/5d19395eb9e07c>

## 概要

- この記事は、株式会社ナレッジワークのSREである tapih さんによる、100 以上のモジュールを持つ Go Monorepo の CI（継続的インテグレーション）の改善事例について詳細に報告しています。
- 主な成果として、CI インスタンスのコストをピーク時から 50% 以上削減したことが挙げられます。
- GitHub Actions の実践的な Tips や、施策の進め方、考え方も学ぶことができます。

## 背景

- **Monorepo の特徴**
  - Go を用いたバックエンド開発を行うための 100+ モジュールのマルチモジュール構成。
  - モジュール間の依存関係は `go.mod` の `replace` ディレクティブで解決（`go work` は未使用）。
  - Go 以外のコードも同じリポジトリ内で管理。
- **従来の CI 運用**
  - 各モジュールごとに CI のワークフロー定義を自動生成し、プルリクエストの変更に応じて必要な CI のみを実行する方式を採用していた。

## 課題

- **CI インスタンスコストの増加**
  - 多数のモジュールによるジョブの増加で、GitHub Hosted Runner の利用料金が膨らむ。
  - 原因：
    - 環境構築処理（例：Go SDK のインストール）がジョブごとに繰り返される。
    - Cache API の並列呼び出しによる HTTP 429 エラーやキャッシュ容量制限の超過。
    - 直接変更がないモジュールに対しても全てのリントを実行してしまう。
- **CI 待ち時間の増加**
  - 多数の Runner インスタンスが同時に起動され、キューが混雑することで CI 開始までの時間が延びる。
- **CI 実行状況把握の認知コストの増加**
  - 各モジュールごとに分かれたワークフローが多数同時に実行され、どの CI が起動しているか把握しづらい。

## 改善方針

- **シンプルかつミニマルなアプローチ**
  - 複雑なツール（Bazel や Nx、Self Hosted Runner など）を導入せず、既存の仕組み内で問題解決を図る。
  - CI の並列数を制御し、実行時間と失敗率（SLO）を低く保ちながら、開発生産性を維持することが目標。
- **具体的な施策**
  - ワークフロー定義の自動生成を廃止し、CI 実行時に変更のあったモジュールを解析して対象を決定。
  - 変更のあったモジュールを、事前に定義した JSON のルールに従いグループ化し、グループごとにテストとリントを並列実行。
  - 同一ジョブ内で複数モジュールを直列実行し、不要なリント実行を削減。
  - 直接変更のない依存先モジュールでは、一部のリントルールのみ実行する。

## 実装の詳細

- **主要なワークフロー**
  - `.github/workflows/pr--golang.yaml`: 依存解析用ワークフロー
  - `.github/workflows/call--golang-test.yaml`: テスト実行用 Workflow Call
  - `.github/workflows/call--golang-lint.yaml`: リント実行用 Workflow Call
- **コード例の解説**
  - Git Diff で変更ファイルを取得し、`go.mod` が存在するディレクトリを特定。
  - `go.mod` の `replace` を解析して依存関係マップを構築し、間接的に変更のあったモジュールを抽出。
  - JSON に定義された正規表現ルールを使い、モジュールをグループ化（例：特定のパスは `example [L]` グループにまとめる）。
- **Artifact を活用したキャッシュ管理**
  - GitHub Actions のキャッシュ容量（レポジトリ毎 10GB）を回避するため、サイズの大きい一部キャッシュを GitHub Artifact Storage にアップロード。
  - zstd を利用して圧縮/解凍し、高速化を図る。
- **JUnit レポートの集約**
  - 複数モジュールのテスト結果を JUnit レポートとして一つの PR コメントに集約する仕組みを自作の Action で実装。
- **その他の Tips**
  - concurrency を用いた重複ワークフローのキャンセル。
  - 必要なコミット履歴のみを取得することで fetch 時間を最小化。
  - Matrix 定義の調整による GitHub Web UI 上での見やすさの向上。
  - ARM インスタンスの活用によるインスタンスコストの削減。
  - Datadog CI Visibility を用いた可視化など。

## 移行プロセス

- 新 CI を旧 CI と並行稼働させ、一部モジュールのみで検証を実施。
- 利用者からのフィードバックを収集し、問題が発生しないことを確認後、完全に新 CI へ移行。

## 結果と今後の展望

- **コスト削減**
  - インスタンスコストをピーク時と比較して最低 50% 削減に成功。
- **パフォーマンスの改善**
  - PR からデフォルトブランチへのマージまでの Latency:
    - P50: 約 4.5 分
    - P95: 約 7.2 分
  - CI 起因のエラー率が、リリース前は 2.4% から、対策後は 0.7% に低下。
- **安定運用と今後の展開**
  - 新 CI はリリース後、ほぼ手を加えることなく安定して運用中。
  - 今後は、さらに Go のビルド・テストフローへの踏み込みや、ビルドツールの導入など、仕組みの進化を図る予定。
  - 同様の課題に悩む他チームへのフィードバックや議論も歓迎。
