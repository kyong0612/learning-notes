# マイクロフロントエンド入門書

ref: <https://intro-to-micro-frontends.netlify.app>

## バックエンドのMicroservices

- モチベーション
    1. システム規模が拡大するにつれて開発サイクルが伸びる
       - その結果、**ユーザへの価値提供がおそくなってしまう**
       - 理由としては開発者側への負担が大きいため
         - 様々な機能を1つのコンポーネントに含めるということは、開発者はそれを全て理解しなければならない
    2. システムや組織的なスケーラビリティ性がボトルネックになること
       - 特定の機能だけスケールすることが難しくなる(人・サーバ)

## モノリスフロントエンドの課題

1. フロントエンド領域の変化が激しく、追従することが困難
   - 変化を激しくする要因
     - 利用者側の要求変化
     - 開発者側の要求変化
     - 自由度の高いwebというプラットフォーム
2. システム・組織のスケールに、フロントエンドがボトルネック
   - 機能別のサーバのスケールが難しい
   - 次に組織は、短い開発サイクルで施策を打ち出し、継続的なフィードバックを得る必要がある。
     - そのためには、開発者は高速に開発を進めなければならない。
     - しかし、モノリスなフロントエンドの場合、難しいことがある。 それは、次の点が挙げられる。
        - 幅広い知識（ドメイン）が要求される
        - 全体バランスを整える高度な設計が要求される
        - 調査やテストの奥深さが要求される
        - 幅広い知識（ドメイン）が要求される
        - 全体バランスを整える高度な設計が要求される
        - 調査やテストの奥深さが要求される
     - これらを満たすエンジニアの育成・採用することは、困難だ。
  
## マイクロフロントエンドのメリット・デメリット

- メリット
  - 独立性
    - 任意のテクノロジーと任意のチームで開発可能
  - 展開
    - 特定の機能をエンドツーエンド（バック、フロント、デプロイ）で確実に実行可能
  - 俊敏性
    - 特定のドメインについて最高の知識をもつチーム間で作業を分散すると、リリースプロセスが確実にスピードアップして簡素化される
    - フロントエンドとリリースが小さいということは、リグレッションテストがはるかに小さい
    - フロントエンドのアップグレード/変更にはコストが小さい
  - 専門性
    - 特定の機能だけに集中できる

- デメリット
  - 独立性
    - ドメインが適切に分割できていない場合、相互接続するチームが存在してしまう
    - 複数のマイクロフロントエンドにまたがる機能共有は、独立性が低下
    - コンポーネント間の通信は、実装と維持が困難であるだけでなく、コンポーネントの独立性が低下
    - 横断的関心事への変更で、すべてのマイクロフロントエンドを変更することは、独立性が低下
    - 全チームへ共有すべき関心事を周知する仕組みが必要
      - デザインシステム、パフォーマンス、ナレッジ
  - 展開
    - サイト全体のCI/CDプロセスが必要
  - 俊敏性
    - 重複作業が発生
    - 検出可能性が低下した結果、一部の標準コンポーネントを共有できず、個別のフロントエンドで実装が重複してしまう
    - 共有キャッシュがないと、各コンポーネントは独自のデータセットをプルダウンする必要があり、大量の重複呼び出しが発生する
  - パフォーマンス
    - マイクロフロントエンドの実装に不適切な場合、パフォーマンスの低下がある
    - 特定チームが改善しても、チーム全体が改善できない
      - ex. あるチームがビルド時間短縮に成功しても、他のチームはその恩恵を享受できない
      - ex. すべてのチームが採用しているライブラリのセキュリティパッチは、それぞれのチームが更新しなければならない
  - その他
    - エッジな技術スタック採用は、チームメンバー移動を困難にする
      - ex. パラダイムシフトが発生してしまう技術スタック

## マイクロフロントエンドの組成パターン

### クライアントサイド組成パターン

- クライアントサイドレンダリングするタイミングで組成する
  - iframeやweb componentを利用する
  - ![alt text](<assets/CleanShot 2024-10-18 at 18.04.08@2x.png>)
- メリット
  - web標準技術のみで実現可能
  - iframeやシャドウDOMによる堅牢な作り
- デメリット
  - サポートブラウザに依存する
  - クライアント側のJSが有効であること

#### 選択基準

- 様々なチームのユーザインターフェースを1つの画面に統合する必要があること
- インタラクティブなアプリケーションを構築すること

#### 技術

- Ajax
- Iframe
- Web Component
- Luigi
- Single-SPA
- FrintJS
- Hinclude
- Mashroom

### サーバーサイド組成パターン

- サーバーサイドレンダリングのタイミングで組成する
  - SSI
  - ![alt text](<assets/CleanShot 2024-10-18 at 18.10.00@2x.png>)

- メリット
  - 初回ロードパフォーマンスが優れている
- デメリット
  - インタラクションアプローチが不得意

#### 選択基準

- 以下がプロジェクトの優先事項であること
  - 良好な読み込みパフォーマンス
  - 検索エンジンのランキング

#### 技術

- SSI
- Podium
- Ara-Framework
- Tailor
- Micromono
- PuzzleJS
- namecheap/ilc

### エッジサイド組成パターン

- サーバーサイド組成の組成場所がエッジになる

#### 技術

- ESI
- Varnish EDI
- Edge Worker

### ビルドタイム組成パターン

- ビルドタイミングで組成する
- 各フロントエンドチームがフラグメントモジュールを開発する

#### 選択基準

- 他の結合が非常に複雑と思われる場合に選択する

#### 技術

- Bit.dev
- Open Components
- Piral

### マイクロフロントエンドの分割ポリシー

- 水平分割
  - 画面内にある要素で分割
- 垂直分割
  - 画面毎に分割
![alt text](<assets/CleanShot 2024-10-18 at 18.17.27@2x.png>)
