# How to think about agent frameworks

ref: <https://blog.langchain.dev/how-to-think-about-agent-frameworks/>

## TL;DR (要点)

* **信頼性の高いエージェントシステム構築の難所**: 各ステップでLLMが適切なコンテキストを持つこと。これには、LLMへの入力内容の正確な制御と、関連コンテンツを生成するための適切なステップの実行が含まれる。
* **エージェントシステム**: ワークフローとエージェント（およびその中間）の両方で構成される。
* **多くのエージェントフレームワーク**: 宣言的または命令的なオーケストレーションフレームワークではなく、単なるエージェント抽象化のセットである。
* **エージェント抽象化**: 開始は容易にするが、LLMが各ステップで適切なコンテキストを持つことを保証するのを難しくし、不明瞭にする可能性がある。
* **エージェントシステム（エージェントまたはワークフロー）**: フレームワークによって提供されるか、スクラッチから構築できる、同じ一連の有用な機能から恩恵を受ける。
* **LangGraph**: 宣言的APIと命令的APIの両方を備えたオーケストレーションフレームワークとして考えるのが最適であり、その上に一連のエージェント抽象化が構築されている。

## 背景情報

* **エージェントとは何か？**
  * OpenAIの定義: 「あなたに代わって独立してタスクを達成するシステム」。著者はこれを曖昧で実用的でないと評価。
  * Anthropicの定義:
    * **ワークフロー**: 事前に定義されたコードパスを通じてLLMとツールがオーケストレーションされるシステム。
    * **エージェント**: LLMが自身のプロセスとツール使用を動的に指示し、タスク達成方法を制御するシステム。
    * 著者はAnthropicの定義（特に「エージェントシステム」という概念）を好み、多くの本番システムは「ワークフロー」と「エージェント」の**組み合わせ**であると指摘。
    * エージェントは、環境フィードバックに基づいてツールを使用するLLMのループとして定義されることが多い。
        ![Anthropicのエージェントループ図](https://blog.langchain.dev/content/images/2025/04/58d9f10c985c4eb5d53798dea315f7bb5ab6249e-2401x1000.webp)
  * OpenAIとAnthropicの両方が、常にエージェントが必要なわけではなく、多くの場合ワークフローの方がシンプルで信頼性が高いと指摘している。
  * 著者は、「エージェントかどうか」ではなく、「システムがどの程度エージェント的か」を考えることを好む（Andrew Ng氏の考え方を参照）。

* **エージェント構築の難しさ**
  * プロトタイプ作成は容易だが、信頼性の高い本番用エージェントの構築は難しい。
  * 主な課題は**信頼性**。LangChainの調査では、「パフォーマンス品質」が本番投入の最大の障壁。
    ![エージェント本番投入の障壁に関する調査結果](https://blog.langchain.dev/content/images/2025/04/67347b1aed9686aad4544fef_9.-What-is-your-biggest-limitation.svg)
  * パフォーマンス低下の原因はLLMのエラーであり、その理由はモデルの能力不足か、**不適切なコンテキストの提供**。後者が非常に多い。
  * 不適切なコンテキストの原因: 不完全なシステムメッセージ、曖昧なユーザー入力、不適切なツールアクセス/説明、コンテキスト不足、不適切なツール応答形式など。
  * **結論**: 信頼性の高いエージェントシステム構築の難所は、**各ステップでLLMが適切なコンテキストを持つようにすること**。LLMへの入力を正確に制御し、関連コンテンツ生成ステップを実行することが重要。

* **LangGraphとは何か？**
  * **結論**: LangGraphは、宣言的APIと命令的APIの両方を備えた**オーケストレーションフレームワーク**であり、その上に一連の**エージェント抽象化**が構築されている。
  * イベント駆動型フレームワーク。グラフベースの宣言的構文やエージェント抽象化を通じて使用されることが多い。
  * PythonとTypeScript版がある。
  * ノード（作業単位）とエッジ（遷移）で構成。ノードとエッジは通常のコードであり、グラフ構造は宣言的だが内部ロジックは命令的。エッジは固定または条件付きにできるため、グラフパスは動的。
  * 組み込みの永続化レイヤーにより、耐障害性、短期/長期メモリ、Human-in-the-loop/Human-on-the-loop（中断、承認、再開、タイムトラベル）をサポート。
  * トークン、ノード更新、任意イベントのストリーミングをサポート。
  * LangSmithとシームレスに統合し、デバッグ、評価、可観測性を提供。

## エージェントフレームワークの種類

* **ワークフロー vs エージェント**
  * 多くのフレームワークは高レベルのエージェント抽象化を含むが、ワークフロー抽象化は少ない。
  * LangGraphは低レベルのオーケストレーションフレームワークであり、**ワークフロー、エージェント、およびその中間をサポート**。本番システムは両方の組み合わせであることが多いため、これが重要。
  * ワークフローは、LLMに適切なコンテキストを渡すことを容易にするため有用。
  * 考慮点:
    * **予測可能性 vs エージェンシー**: エージェント的になるほど予測可能性は低下する。LangGraphは、このスペクトル上の任意の点にアプリケーションを構築できる。
        ![予測可能性とエージェンシーのトレードオフ](https://blog.langchain.dev/content/images/2025/04/Screenshot-2025-04-20-at-10.43.31-AM.png)
    * **低い床、高い天井**:
      * ワークフローフレームワーク: 高い天井だが高い床（多くのロジックを自作する必要がある）。
      * エージェントフレームワーク: 低い床だが低い天井（開始は容易だが、すぐに限界が来る）。
      * LangGraph: 低い床（組み込みのエージェント抽象化）と高い天井（低レベル機能）を目指す。

* **宣言的 vs 非宣言的**
  * LangGraphは部分的に宣言的（接続）だが、ノード/エッジは命令的コードであり、関数型APIやイベント駆動型APIもサポートする。
  * Agents SDKのようなフレームワークは宣言的でも命令的でもなく、単なる**抽象化**である。これらはオーケストレーションフレームワークではない。

* **エージェント抽象化**
  * 多くのフレームワークが提供するクラスベースの抽象化は、多くのパラメータを持ち、内部ロジックを隠蔽する。
  * **結論**: これらの抽象化は、**LLMへの入力を正確に理解・制御することを非常に困難にする**。これは信頼性の高いエージェント構築にとって重要であり、抽象化の危険性である。
  * LangChainの初期の課題もこれだった。抽象化が邪魔になった。
  * 抽象化は開始を容易にするが、信頼性の高いエージェント構築には不十分（かもしれない）。
  * Kerasのようなものと考えるのが良い。高レベル抽象化を提供するが、低レベルフレームワーク上に構築されていることが重要。LangGraphのエージェント抽象化はこのアプローチ。

* **マルチエージェント**
  * 複雑なワークフローでは、複数のエージェントに分割することでパフォーマンスとスケーラビリティが向上することがある（OpenAI）。
  * **結論**: マルチエージェントシステムの鍵は**コミュニケーション**。エージェント間の情報伝達が重要。
  * ハンドオフ（Agents SDK）などの方法があるが、最適なコミュニケーション方法は**ワークフロー**である場合が多い。ワークフローとエージェントの組み合わせが最良の信頼性をもたらすことが多い。
    ![Anthropicのワークフロー図（LLMをエージェントに置き換え可能）](https://blog.langchain.dev/content/images/2025/04/7418719e3dab222dccb379b8879e1dc08ad34c78-2401x1000.webp)
  * エージェントシステムはワークフローだけでもエージェントだけでもなく、両方の組み合わせであることが多い（Anthropic）。

## よくある質問

* **フレームワークの価値は何か？**
  * **エージェント抽象化**: 開始を容易にし、共通の方法を提供（ただし前述の欠点あり）。
  * **短期メモリ**: マルチターン体験（チャットなど）のための本番用ストレージ（LangGraph）。
  * **長期メモリ**: 会話間での学習のための本番用ストレージ（LangGraph）。
  * **Human-in-the-loop**: ユーザーフィードバック、ツール承認などのワークフローサポート（LangGraph）。
  * **Human-on-the-loop**: 事後のエージェント軌跡の検査、変更を伴う再実行（LangGraph）。
  * **ストリーミング**: ユーザー体験向上のための更新通知（トークン、グラフステップなど）（LangGraph）。
  * **デバッグ/可観測性**: LLMへのコンテキストを理解するためのステップごとの検査。LangGraphはLangSmithと統合。AI可観測性は従来のソフトウェア可観測性とは異なる。
  * **耐障害性**: 分散アプリケーション構築のための重要な要素。LangGraphは永続的ワークフローと再試行設定でこれを容易にする。
  * **最適化**: 評価データセットに基づく自動最適化（LangGraphは未サポートだが注目。`dspy`が現在最良）。
  * **結論**: これらの価値（抽象化を除く）は、エージェント、ワークフロー、およびその中間の**すべての**エージェントシステムに有益。
  * フレームワークが必要か？: これらの機能が不要、または自作したい場合は不要かもしれない。短期メモリは単純だが、Human-on-the-loopやLLM特有の可観測性は複雑。

* **モデルが改善されれば、すべてがワークフローではなくエージェントになるか？**
  * 著者の考え:
    * ツール呼び出しエージェントのパフォーマンスは向上する。
    * LLMへの入力制御は依然として重要（Garbage in, garbage out）。
    * 一部のアプリではツール呼び出しループで十分になる。
    * 他のアプリではワークフローが依然としてシンプル、安価、高速、高性能。
    * **ほとんどのアプリでは、本番エージェントシステムはワークフローとエージェントの組み合わせになる**。
  * OpenAI/Anthropicも同様の見解。
  * 単純なツール呼び出しループで十分な場合:
    * **タスクがユニーク**: 大量のデータでモデルを独自に訓練/ファインチューン/RLした場合（例: OpenAIのDeep Research）。多くの企業ユースケースがこれに該当する可能性が高い。Sierraのような企業はプラットフォームを構築している。SOTAモデルを訓練できる企業は現状限られている（大規模ラボのみ？）。
    * **タスクがユニークでない**: 大規模ラボが一般的なタスクのデータでモデルを訓練/ファインチューン/RLした場合（例: コーディングエージェント、OpenAIのComputer Useモデル）。ただし、訓練データの形状が重要（Cursorの例）。他のタスクでの訓練が特定タスクの性能を低下させる可能性もある。
  * **結論**: エージェントがワークフローより好まれる場合でも、**短期/長期メモリ、Human-in-the-loop/on-the-loop、ストリーミング、耐障害性、デバッグ/可観測性といったフレームワークの機能は依然として有益**。

* **OpenAIの主張の誤りは何か？**
  * OpenAIの主張は、「宣言的 vs 命令的」と「エージェント抽象化」、「ワークフロー vs エージェント」を混同し、自社の単一抽象化の価値を過大評価している。
  * **結論**: **本番エージェントシステム構築の主要な課題とフレームワークが提供すべき主要な価値を見誤っている**。それは、開発者がLLMへのコンテキストを明示的に制御でき、永続性、耐障害性、Human-in-the-loopといった本番懸念をシームレスに処理できる、信頼性の高いオーケストレーションレイヤーである。
  * 具体的な批判点:
    * 「宣言的 vs 非宣言的グラフ」: Agents SDKは命令的フレームワークではなく抽象化。
    * 「ワークフローが動的で複雑になると扱いにくくなる」: これはワークフロー vs エージェントの問題であり、宣言的かどうかの問題ではない。ワークフローが必要な場合もある。
    * 「専門的なドメイン固有言語の学習が必要」: Agents SDKも独自の抽象化（DSL）を持つ。LangGraphの方が通常のコードを多く書く。
    * 「より柔軟」: これは誤り。LangGraphの方がはるかに柔軟性が高い。
    * 「コードファースト」: LangGraphの方が通常のコードを多く書く。
    * 「使い慣れたプログラミング構造を使用」: Agents SDKは新しい抽象化を学ぶ必要がある。
    * 「より動的で適応性のあるエージェントオーケストレーションを可能にする」: これはワークフロー vs エージェントの問題。

* **エージェントフレームワークの比較**
  * 比較の軸:
    * 柔軟なオーケストレーションレイヤーか、単なるエージェント抽象化か？
    * オーケストレーションレイヤーの場合、宣言的か、それ以外か？
    * エージェント抽象化以外の機能を提供しているか？
  * 著者はスプレッドシートで各種フレームワーク（Agents SDK, Google ADK, LangChain, Crew AI, LlamaIndex, AutoGen, Temporal, DSPyなど）を比較している。
  * **結論**: 生きているスプレッドシートへのリンク: [こちら](https://docs.google.com/spreadsheets/d/1B37VxTBuGLeTSPVWtz7UMsCdtXrqV5hCjWkbHN8tfAo/edit?usp=sharing&ref=blog.langchain.dev)

## 結論 (再掲)

* **信頼性の高いエージェントシステム構築の難所**: 各ステップでLLMが適切なコンテキストを持つこと。
* **エージェントシステム**: ワークフローとエージェント（およびその中間）で構成される。
* **多くのエージェントフレームワーク**: オーケストレーションフレームワークではなく、単なるエージェント抽象化のセット。
* **エージェント抽象化**: 開始は容易だが、LLMコンテキストの制御を難しくする可能性。
* **エージェントシステム**: フレームワークが提供する共通の有用な機能（メモリ、HIL、ストリーミングなど）から恩恵を受ける。
* **LangGraph**: 宣言的/命令的APIを持つオーケストレーションフレームワークであり、その上にエージェント抽象化が構築されている。
