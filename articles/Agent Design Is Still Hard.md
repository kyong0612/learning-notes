---
title: "Agent Design Is Still Hard"
source: "https://lucumr.pocoo.org/2025/11/21/agents-are-hard/"
author:
  - "[[Armin Ronacher]]"
published: 2025-11-21
created: 2025-11-24
description: |
  エージェント構築の実践的な課題と学びをまとめた記事。SDK抽象化の問題、キャッシング戦略、強化学習の活用、失敗の分離、サブエージェント設計、出力ツールの課題、モデル選択、テストと評価の難しさなど、実際のエージェント開発で直面する具体的な問題と解決策を詳述している。
tags:
  - "clippings"
  - "ai"
  - "agents"
  - "llm"
  - "tool-calling"
  - "agent-design"
---

## TL;DR

エージェント構築は依然として複雑。SDK抽象化は実際のツール使用時に破綻する。キャッシングは自分で管理する方が効果的だが、モデル間で異なる。強化学習が予想以上に重要で、失敗は厳密に分離しないとループを破壊する。ファイルシステムのような共有状態レイヤーは重要な構成要素。出力ツールは驚くほど難しい。モデル選択はタスクに依存する。

## どのエージェントSDKをターゲットにするか？

独自のエージェントを構築する際、OpenAI SDKやAnthropic SDKのような低レベルSDKをターゲットにするか、Vercel AI SDKやPydanticのような高レベル抽象化を使うかの選択がある。

著者のチームは以前、Vercel AI SDKを採用したが、プロバイダー抽象化のみを使用し、エージェントループは自分たちで制御していた。現在はこの選択を再考している。

### 問題点

1. **モデル間の違いが大きすぎる**: エージェントに適した抽象化を構築するには、各モデルの違いに対応する必要がある。ツールによって抽象化の難易度が変わる（キャッシュ制御、強化学習の要件、ツールプロンプト、プロバイダー側ツールなど）。

2. **プロバイダー側ツールとの互換性問題**: Vercel SDKでプロバイダー側ツールを扱うのは非常に困難。メッセージ形式の統一化がうまく機能しない。例：AnthropicのWeb検索ツールがVercel SDKでメッセージ履歴を破壊する。

3. **エラーメッセージの明確さ**: Anthropic SDKを直接ターゲットにした方が、キャッシュ管理が容易で、エラーメッセージも明確。

**結論**: 現時点では、抽象化を使わずに直接SDKをターゲットにする方が良い。少なくとも状況が落ち着くまでは。

## キャッシングの教訓

プラットフォームごとにキャッシングのアプローチが大きく異なる。

### Anthropicの明示的キャッシュ管理

Anthropicはキャッシングに対して課金し、キャッシュポイントを明示的に管理する必要がある。当初は手動管理が煩雑に感じたが、現在は明示的管理を強く支持している。

**メリット**:

- コストとキャッシュ利用率が予測可能
- 会話を分割して2つの方向に同時実行可能
- コンテキスト編集の機会がある
- エージェントのコストを理解しやすい

**実装戦略**:

- システムプロンプトの後に1つのキャッシュポイント
- 会話の開始時に2つのキャッシュポイント（最後の1つは会話の末尾と共に移動）
- システムプロンプトとツール選択をほぼ静的にする必要があるため、現在時刻などの動的情報は後から動的メッセージで提供

他のプラットフォームではキャッシュ利用率が不安定で、明示的管理の方が優れている。

## エージェントループでの強化学習

エージェントがツールを実行するたびに、ツールが生成するデータを返すだけでなく、ループに追加情報をフィードバックする機会がある。

### 強化学習の用途

1. **全体目標と個別タスクの状態のリマインド**: エージェントに全体的な目標と個別タスクの状態を思い出させる
2. **失敗時のヒント提供**: ツール呼び出しが失敗した際に、成功の可能性についてヒントを提供
3. **バックグラウンドでの状態変化の通知**: 並列処理を使用するエージェントの場合、状態が変化した際に情報を注入
4. **自己強化**: Claude Codeの`todo write`ツールのように、エージェントが自分でタスクリストを管理し、それをエコーするだけでも前進を促進

### 環境変化の通知

エージェントが失敗して特定のステップから再試行する際、回復が壊れたデータで動作している場合、数ステップ戻って以前のステップをやり直すよう促すメッセージを注入する。

## 失敗の分離

コード実行中に多くの失敗が予想される場合、それらの失敗をコンテキストから隠す機会がある。

### 方法1: サブエージェントでの実行

反復が必要なタスクを個別に実行し、サブエージェントで成功するまで実行し、成功と失敗したアプローチの要約のみを報告する。エージェントが何が機能しなかったかを学習することで、次のタスクでその情報を活用できる。

### 方法2: コンテキスト編集（Anthropicのみ）

コンテキスト編集により、ループの後半のためにトークンを保持できる。成功に寄与しなかった失敗をコンテキストから削除できるが、完全な状態とすべての失敗の完全な出力は必要ないかもしれない。

**課題**: コンテキスト編集は自動的にキャッシュを無効化する。キャッシュを破棄する追加コストとのトレードオフが不明確な場合がある。

## サブエージェント / サブ推論

著者のエージェントのほとんどはコード実行とコード生成に基づいている。これにはエージェントがデータを保存する共通の場所が必要。

### ファイルシステムの重要性

**選択**: 仮想ファイルシステムを使用。これにより、異なるツールが同じデータにアクセスできる。

**デッドエンドの回避**: タスクがサブツール内でのみ実行を継続できるようなデッドエンドを避ける必要がある。例：画像生成ツールが画像を生成しても、それを1つのツールにしかフィードバックできない場合、コード実行ツールでその画像をZIPアーカイブに入れることができない。

**解決策**: 画像生成ツールが画像を書き込む場所と、コード実行ツールが読み取る場所を同じにする。つまり、ファイルシステムが必要。

逆方向も同様：コード実行ツールでZIPアーカイブを展開し、推論に戻ってすべての画像を説明し、次のステップでコード実行に戻るなど。

**実装**: `ExecuteCode`ツールと`RunInference`ツールが同じ仮想ファイルシステムにアクセスし、`path`パラメータでファイルを指定できるようにする。

## 出力ツールの使用

著者のエージェント構造の興味深い点は、チャットセッションを表していないこと。最終的にユーザーや外部世界に何かを伝達するが、その間のメッセージは通常公開されない。

### 出力ツールの設計

1つの出力ツールを用意し、エージェントが明示的に人間とコミュニケーションするために使用。プロンプトでいつそのツールを使うべきかを指示。著者の場合、出力ツールはメールを送信する。

### 課題

1. **言葉遣いとトーンの制御が困難**: メインエージェントループのテキスト出力をユーザーとのコミュニケーション手段として使用する場合と比較して、出力ツールの言葉遣いとトーンを制御するのは驚くほど難しい。おそらくモデルの訓練方法に関連している。

2. **サブツールでの調整の失敗**: Gemini 2.5 Flashのような別のLLMでトーンを調整しようとしたが、レイテンシが増加し、出力品質が低下。モデルが正しく言葉を選ばず、サブツールが十分なコンテキストを持たない。メインエージェントコンテキストのより多くのスライスをサブツールに提供すると高コストになり、問題も完全には解決しない。最終出力に、最終結果に至るステップなど、存在させたくない情報が含まれることもある。

3. **ツールが呼ばれない**: 出力ツールが呼ばれないことがある。出力ツールが呼ばれたかを記憶し、ループが出力ツールなしで終了した場合、出力ツールを使用するよう促す強化メッセージを注入している。

## モデル選択

全体的に、モデルの選択は劇的に変わっていない。

### メインループ

- **HaikuとSonnet**: 依然として利用可能な最良のツール呼び出しモデル。エージェントループに優れた選択。RL（強化学習）に関してある程度透明性がある。
- **Geminiモデル**: 明らかな選択肢の1つ。
- **GPTファミリー**: メインループでは大きな成功を見出せていない。

### サブツール

- **Gemini 2.5**: 大きなドキュメントの要約やPDFの処理に適している。画像からの情報抽出にも優れている。特に、Sonnetファミリーモデルが安全性フィルターに引っかかる傾向があるため。

### コスト考慮

トークンコストだけがエージェントのコストを定義するわけではない。より良いツール呼び出しモデルは、より少ないトークンで仕事を完了する。現在Sonnetより安いモデルもあるが、ループ内では必ずしも安くない。

## テストと評価

テストと評価が最も難しい問題。エージェントの性質により、プロンプトよりもさらに困難。

### テストと評価の課題

- プロンプトとは異なり、外部システムで評価を実行できない（フィードする必要がある情報が多すぎる）
- 観測可能性データや実際のテスト実行の計装に基づいて評価を行う必要がある
- 試した解決策のどれも、正しいアプローチを見つけたと確信させるものはない

現時点では満足のいく解決策を見つけられていない。これはエージェント構築のますますフラストレーションのたまる側面になっている。

## コーディングエージェントの更新

コーディングエージェントの経験については、それほど変わっていない。

### Ampの試用

主な新展開は[Amp](https://ampcode.com/)の試用を増やしていること。客観的に優れたエージェントというわけではないが、エージェントについての考え方が気に入っている。

**特徴**:

- Oracleなどの異なるサブエージェントとメインループの相互作用が美しく実装されている
- 他のハーネスでは今日これを行っているものは少ない
- 異なるエージェント設計の動作を検証する良い方法
- Claude Codeと同様に、自分のツールを自分で使う人々によって構築された製品のように感じる

## 読んで価値があると思ったもの

### What if you don't need MCP at all?

Mario Zechnerが、多くのMCPサーバーが過剰設計で、大きなツールセットを含み、多くのコンテキストを消費すると主張。ブラウザエージェントのユースケースでは、Bash経由で実行されるシンプルなCLIツール（start、navigate、evaluate JS、screenshotなど）に依存するミニマリストアプローチを提案。著者は[Claude/Amp Skillとして実装](https://github.com/mitsuhiko/agent-commands/tree/main/skills/web-browser)した。

### The fate of "small" open source

小さな単一目的のオープンソースライブラリの時代が終わりつつある。組み込みプラットフォームAPIとAIツールが、オンデマンドでシンプルなユーティリティを生成できるようになったため。

### Tmux is love

Tmuxは素晴らしい。エージェントが作業すべきインタラクティブシステムのようなものがあれば、[Tmuxスキルを与えるべき](https://github.com/mitsuhiko/agent-commands/tree/main/skills/tmux)。

### LLM APIs are a Synchronization Problem

別の記事として[別途執筆](/2025/11/22/llm-apis/)。

## 結論

エージェント設計は依然として困難で、多くの課題が残っている。SDK抽象化、キャッシング、強化学習、失敗の分離、共有状態管理、出力ツール、モデル選択、テストと評価など、実践的な問題に対する解決策はまだ発展途上。しかし、明示的な管理と制御を重視することで、より予測可能で効果的なエージェントを構築できる可能性がある。
