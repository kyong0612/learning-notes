---
title: "AI時代に成長するサービスを止めないためのDBリファクタリング完全ガイド"
source: "https://soudai.hatenablog.com/entry/database-refactoring-double-write"
author:
  - "[[そーだい (id:Soudai)]]"
published: 2025-10-08
created: 2025-10-10
description: "サービス成長に伴い肥大化したデータベースを安全にリファクタリングするための戦略と実践方法を解説。ダブルライトを中心に、トリガー、生成列、アプリケーション実装、CDC、メッセージキューなど複数のアプローチを紹介し、自動テスト、オブザーバビリティ、データ整合性チェックなど安全な実施のための準備も網羅。"
tags:
  - "database"
  - "refactoring"
  - "database-design"
  - "double-write"
  - "technical-debt"
  - "observability"
---

## 概要

サービスが成長するにつれてデータベースは肥大化し、当初の設計が適さなくなることは避けられない。AI時代の到来により、データベースの成長速度はさらに加速している。本記事では、サービスを止めずに安全にデータベースをリファクタリングするための戦略と実践的な手法を包括的に解説する。

## データベースリファクタリングの基本戦略

データベースリファクタリングは以下の4つのステップで進める：

### 1. あるべき姿を定義する

- リファクタリングの目的と期待する効果を明確化
- システムリプレースのようなビッグバンリリースは避け、小さく優先順位を絞る
- 「腐った牛乳とチーズ」の例：ビジネスに悪影響を与える負債を優先的に対応

### 2. リファクタリングの方針を決める

段階的に進めるためのステップを定義。削除フラグ廃止の例：

1. `deleted_user`と`active_user`テーブルを作成
2. `user`テーブルへのINSERT時に`active_user`にも書き込み
3. 削除フラグをtrueに更新する際、`deleted_user`に書き込み、`active_user`から削除
4. 既存データをコピー
5. ビュー（`view_user`）でUNIONして既存テーブルと同様の構造を提供
6. 参照を切り替え
7. 旧テーブルを削除

重要なポイント：

- 次のステップへの達成条件を明確化
- ロールバック条件を事前に定義
- 各チームへの根回しとリソース確保

### 3. 安全な仕組みを準備する

#### 自動テスト

- サービスの振る舞いが変わらないことを確認するE2Eテストと単体テスト
- AIを活用したテストコード生成も検討
- まずは主要機能の正常系テストから着手

#### オブザーバビリティの強化

- APM（Application Performance Monitoring）ツールの活用
- OpenTelemetryなどの分散トレーシング
- アラート設定とダッシュボード整備
- リファクタリング対象テーブルの利用状況把握

#### データ整合性チェックの自動化

- 新旧テーブル間のデータ整合性を定期的にチェック
- 10分に1回などバッチで実行する仕組み
- 不整合の早期発見により、被害拡大を防止

### 4. リファクタリングを実施する

## ダブルライトの実装アプローチ

### データベース機能を利用した実装

#### トリガーを利用する方法

**メリット：**

- アプリケーション側の変更が不要
- 影響範囲を最小限に抑制

**デメリット：**

- CPUやメモリの負荷増加
- 保守性の低下
- テストが困難

**推奨される使い方：** マルチアプリケーション環境でのつなぎとして期間限定で利用

#### 生成列（Generated Column）

以下のようなケースで有効：

- `full_name`列を`first_name`と`last_name`から自動生成
- `total_price`列を関連テーブルの合計から算出
- `duration`列を開始日と終了日から計算

CASE式での処理を生成列に置き換えることで処理を簡潔化できる。

### アプリケーション実装

#### 関数でラップする方法（推奨）

```php
function SaveUser($user) {
    $db->beginTransaction();
    try {
        $db->insert('user', $user);
        $db->savePoint('after_user_insert');
        $db->insert('active_user', $user);
        $db->commit();
    } catch (Exception $e) {
        $db->rollbackToSavePoint('after_user_insert');
        $db->commit();
        Log::error('Failed to insert active_user');
    }
}
```

**メリット：**

- シンプルでわかりやすい
- テストがしやすい
- ロールバックが容易
- データベースより変化に強い

#### シャドウページング

```php
function GetUser($id) {
    $user = $db->select('user', ['id' => $id]);
    $viewUser = $db->select('view_user', ['id' => $id]);
    if ($user != $viewUser) {
        Log::warn('Data inconsistency detected');
    }
    return $user;
}
```

新旧両方のテーブルを参照し、不整合を早期検知する安全な方法。

#### フレームワークの機能を利用

LaravelのTraitなどを使い、イベントリスナーやミドルウェアで実装。短期決戦のシングルアプリケーションで有効。

### ミドルウェアを活用した方法

#### CDC（Change Data Capture）

**特徴：**

- AWS DMSやDebeziumなどのツールを利用
- データベース間でのデータ伝搬が可能
- リファクタリング前後のDBを分離できる

**注意点：**

- コンポーネントが増え、監視対象も増加
- 単一障害点になりうる
- リファクタリング完了後は必ず廃止すること
- 新たな技術的負債になるリスク

**推奨される使い方：** 大規模リファクタリングや参照・更新を分離したい場合

#### メッセージキューによる非同期書き込み

```php
function SaveUser($user) {
    $db->beginTransaction();
    $db->insert('user', $user);
    $db->commit();
    $mq->publish('insert_active_user', $user);
}
```

**メリット：**

- 書き込みの高速化（ログ先行書き込み）
- 単一障害点になりにくい
- データの前加工が柔軟

**適した環境：**

- CQRSパターンを採用
- 参照整合性が緩い要件

**注意点：**

- データ整合性チェックは必須
- 遅延や失敗時の対応が必要

## 重要な考慮事項

1. **アプリケーション優位の原則：** データベースよりもアプリケーションの方が変化に強いため、リファクタリングロジックはできるだけアプリケーション側で実装

2. **段階的アプローチ：** ビッグバンリリースを避け、小さく段階的に進める

3. **継続的な監視：** リファクタリング中は常にシステムの状態を監視し、問題を早期発見

4. **スケジュール厳守：** 特にCDCなどのミドルウェアを使う場合、新たな負債にならないよう計画通りに完遂

5. **覚悟と実行力：** データベースリファクタリングは影響範囲が広く時間がかかるため、最後までやり切る覚悟が最も重要

## まとめ

AI時代においてデータベースの成長速度は加速しており、継続的なリファクタリングが事業成長の鍵となる。本記事で紹介した戦略と手法を組み合わせることで、サービスを止めずに安全にデータベース負債を解消できる。適切な準備と段階的なアプローチにより、データベースリファクタリングを成功させることが可能である。
