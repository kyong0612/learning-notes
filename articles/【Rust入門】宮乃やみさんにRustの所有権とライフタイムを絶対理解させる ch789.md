---
title: "【Rust入門】宮乃やみさんにRustの所有権とライフタイムを絶対理解させる #ch789"
source: "https://www.youtube.com/watch?v=lG7YbM2AfU8"
author:
  - "[[@余語久史]]"
published: 2024-01-08
created: 2025-12-26
description: |
  Rustの鬼門とされる「所有権」と「ライフタイム」を、メモリの基礎（スタックとヒープ）から徹底的に解説する教育動画。プログラムは「メモリの読み書きとシステムコールの発行」しかできないという根本的な理解から始まり、所有権は「管理責任」、ライフタイムは「スタックの底が長生きで上の方が短命」というルールであることを、ホワイトボードを使った視覚的な説明と実践的なコード例で理解させる。約2時間半から3時間の配信。
tags:
  - "clippings"
  - "Rust"
  - "所有権"
  - "ライフタイム"
  - "メモリ管理"
  - "プログラミング教育"
---

# 【Rust入門】宮乃やみさんにRustの所有権とライフタイムを絶対理解させる #ch789

## 概要

この動画は、Rust初心者である宮乃やみさんをゲストに迎え、Rustの最も難しいとされる「所有権（Ownership）」と「ライフタイム（Lifetime）」の概念を、メモリの基礎から徹底的に理解させることを目的とした教育配信です。約2時間半から3時間にわたる配信で、コードを一文字も書かずにホワイトボードを使った説明から始まり、段階的に理解を深めていく構成になっています。

## 本日のゴール

- 所有権とライフタイムの存在意義と意味を理解する
- 簡単な使い方を理解する
- 公式チュートリアルを読めるようになる

## 1. Rust環境構築（2024年版）

### 3ステップの環境構築

1. **rustupのインストール**: Rust公式サイトからrustupをインストール（2021年から変わっていない）
2. **VS Code + rust-analyzer**: VS Codeにrust-analyzer拡張機能をインストール
3. **Clippyの設定**: VS Codeの設定で`rust-analyzer.check.command`に`clippy`を設定

Clippyは非常に賢いリントツールで、ダサいコードを指摘してくれるため、Rust独学する人は必ず設定すべき。

### Cargoの基本

- `cargo new <プロジェクト名>`: プロジェクトテンプレートを生成（Git初期化も自動）
- `cargo run`: ビルドと実行を一度に行う
- `cargo build`: ビルドのみ

## 2. メモリの基礎理解

### プログラムの本質

**「プログラムはメモリのシンタックスシュガーでしかない」**

プログラムができることは、細かい例外を除くと：

- メモリの読み書き
- システムコールの発行

この2つだけ。

### ハローワールドの裏側

1. **実行前**: バイナリーファイルに「Hello World」が書き込まれている
2. **実行中**: OSがメモリに展開し、メモリ上に存在する
3. **出力**: `write`システムコール（libc経由）で標準出力に出力

### メモリの構造

メモリは巨大な配列で、`0x00`から`0xFF`まで続く。プログラムはこのメモリを自由自在に読み書きして意味のある仕事をする。

### メモリの使い方：2つの領域

#### 1. スタック（Stack）

- **場所**: メモリの下の方
- **用途**: 固定サイズの変数を置く
- **特徴**: 下から積み上げていく（LIFO: Last In First Out）
- **例**: `let x = 1;` はスタックに置かれる

#### 2. ヒープ（Heap）

- **場所**: メモリの上の方
- **用途**: 実行時にサイズが決まるデータを置く
- **特徴**: `malloc`で領域を確保し、`free`で解放する必要がある
- **問題点**:
  - `free`を忘れるとメモリリーク
  - 2回`free`するとダブルフリー（セキュリティ脆弱性）

**なぜヒープが必要か**: スタックは固定サイズしか扱えない。ユーザー入力など、実行時に長さが決まるデータはヒープが必要。

## 3. 所有権（Ownership）の理解

### 所有権の本質

**「所有権」は「権利」ではなく「管理責任」**

所有権とは、変数に「お前が死ぬ時には必ず`free`しろよ」という責任を押し付けること。

### String型の内部構造

`String`は64ビット整数3つ（合計192ビット = 24バイト）の構造体：

1. **ポインター**: ヒープ上のデータを指す（64ビット）
2. **len**: 実際の文字列の長さ（64ビット）
3. **capacity**: 確保した領域の上限（64ビット）

- **スタック**: 管理情報（24バイト）が置かれる
- **ヒープ**: 実際の文字列データが置かれる

### 所有権の移動（Move）

```rust
let s = String::from("Hey");
let t = s;  // 所有権がsからtに移動
// sはもう使えない
```

代入は「管理責任を押し付ける操作」。所有権を移動した変数は使えなくなる（ムーブ）。

### 借用（Borrowing）

所有権を移動せずに、一時的に借りる仕組み。

```rust
fn f(s: &str) {  // &strは借用
    println!("{}", s);
}

let s = String::from("Hey");
f(&s);  // 借用を渡す
f(&s);  // もう一度使える
```

- `&str`（アンパサンドstr）: 借用型
- ポインター（64ビット）+ len（64ビット）の2つだけを持つ
- `capacity`はない（借りた身で拡張できないため）

### 借用のルール

- 借りている間は、元の所有者が書き換えできない
- 複数の不変借用は同時に可能
- 可変借用は1つだけ（排他的）

## 4. ライフタイム（Lifetime）の理解

### ライフタイムの本質

**「スタックの底が長生きで、上の方が短命」というルール**

- メイン関数の変数: プログラム終了まで生きる（長生き）
- 関数内の変数: 関数から抜けると死ぬ（短命）

スタックは関数を呼ぶと上に伸び、関数が終わると上から縮む。これがライフタイムの概念。

### ライフタイムの規則

**「短命なものを長生きするものに貸し出すのは許されない」**

```rust
fn g() -> &str {  // エラー！
    let s = String::from("Hey");
    &s  // sは短命なのに、長生きする戻り値に返そうとしている
}
```

関数内で作った変数の借用を返すと、関数が終わった時点で実体が消えてしまうため、コンパイラがエラーを出す。

### ライフタイムパラメーター

```rust
fn greet_map<'a>(name: &'a str) -> HashMap<i32, &'a str> {
    // nameのライフタイムと戻り値のライフタイムが同じであることを示す
}
```

- `'a`: ライフタイムパラメーター（変数名と同じで何でもいい）
- 基本的には「この2つは同じライフタイムですよ」を示す記号
- シンプルなケースではコンパイラが自動推論する

### staticライフタイム

- プログラム終了まで絶対に死なない
- 文字列リテラル（`"Hello"`）は`&'static str`
- ROデータセクション（読み取り専用データ領域）に置かれる

## 5. 実践的な理解

### Stringと&strの使い分け

- **引数で受け取る**: 原則として`&str`にする（借用）
- **理由**: `String`で受け取ると所有権が移動し、再利用できない
- **例外**: ハッシュマップに直接突っ込むなど、所有権が必要な場合は`String`

### トリム操作の例

```rust
let name = "  Yami  ";
let trimmed = name.trim();  // &strを返す
```

`trim`は実体をコピーせず、ポインターをずらして長さを変えるだけ。これが借用の強力な点。

### メモリ効率の考え方

- ヒープの確保は重い操作
- 借用を使えば、コピーせずに効率的にデータを扱える
- Rustでは、メモリ上にこう配置したら効率的というアイデアを、安全に実装できる

## 6. 練習問題：greet_map関数

IDと名前を受け取り、メッセージを組み立ててハッシュマップに格納して返す関数を実装。

### 学んだポイント

- `HashMap`の使い方（`insert`メソッド）
- `format!`マクロの使い方
- ライフタイムエラーの理解
  - 関数内で作った`String`の借用を返すとエラー
  - 外側から借りてきた`&str`を返すのはOK

## 重要な気づき

1. **「メモリの気持ちが分かれば、所有権とライフタイムは理解できる」**
2. **所有権は「管理責任」、ライフタイムは「スタックの寿命のルール」**
3. **スタックが「見える」ようになると、Rustのコードが理解しやすくなる**
4. **プログラムは結局メモリの読み書きとシステムコールの発行しかできない**

## まとめ

この配信では、Rustの所有権とライフタイムを理解するために、メモリの基礎から徹底的に説明しました。コードを書く前に、メモリの構造と動作を理解することが重要であることが強調されています。所有権は「管理責任」、ライフタイムは「スタックの寿命のルール」という本質的な理解により、Rustのコンパイラエラーも「なぜ怒られているか」が分かるようになります。

## 関連リソース

- Rust公式チュートリアル: [The Rust Programming Language](https://doc.rust-lang.org/book/)
- Rust標準ライブラリリファレンス: [docs.rs](https://docs.rs/)
- Rust開発環境構築動画: <https://youtu.be/677kcyyPwJ4>
