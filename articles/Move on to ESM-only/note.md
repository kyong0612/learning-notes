# Move on to ESM-only

ref: <https://antfu.me/posts/move-on-to-esm-only>

## はじめに

3年前、私は「ESM & CJS を1つのパッケージで提供する」という記事を書き、ユーザーの移行を容易にするためにCJS/ESMの二重形式を推奨し、双方のメリットを活かす方法を模索していました。当時は、低レベルのライブラリ中心の推進であったこともあり、エコシステムが十分に整っていないという理由から、ESMのみを積極的に出荷することには完全には賛同していませんでした。しかし、ツールやエコシステムが進化するにつれ、私自身の見解は徐々にESMのみの採用へとシフトしていきました。

2025年現在、ESMが初めて導入された2015年以来10年が経過しました。最新のツールやライブラリは、主なモジュール形式としてESMをますます採用しています。WOOORMのスクリプトによれば、2021年にnpmでESMを提供しているパッケージは7.8%でしたが、2024年末には25.8%に達しています。依然として多くのパッケージがCJSを使用していますが、この傾向はESMへの明確な移行を示しています。

[画像 0]  
`npm-esm-vs-cjs` スクリプトによって生成された時間経過によるESM採用状況（最終更新: 2024-11-27）

この投稿では、現在のエコシステムの状況と、なぜESMのみへの移行の時期だと考えるのか、私の見解を共有したいと思います。

---

## ツールは整っています

### 最新のツール

人気のある最新のフロントエンドビルドツールである [Vite](https://vite.dev) の台頭により、[Nuxt](https://nuxtjs.org)、[SvelteKit](https://kit.svelte.dev)、[Astro](https://astro.build)、[SolidStart](https://solidstart.dev)、[Remix](https://remix.run)、[Storybook](https://storybook.js.org)、[Redwood](https://redwoodjs.com) など多くのメタフレームワークが現在Vite上に構築され、ESMが一級市民として扱われています。

これを補完する形で、最初からESM向けに設計され、強力なモジュールモッキング機能と効率的な細粒度キャッシュサポートを備えたテストライブラリ [Vitest](https://vitest.dev) も登場しています。

また、[tsx](https://github.com) や [jiti](https://github.com) のようなCLIツールは、追加の設定なしでTypeScriptやESMコードを実行するシームレスな体験を提供します。これにより、開発プロセスが簡素化され、ESMを利用するプロジェクトのセットアップにかかる手間が軽減されます。

その他、例えば [ESLint](https://eslint.org) は、最新のv9.0で新たなフラット設定システムを導入し、CJSプロジェクト内でも `eslint.config.mjs` を用いたネイティブなESMサポートを実現しました。

---

### トップダウンとボトムアップ

2021年、[SINDRESORHUS](https://github.com) が自身の全パッケージ、例えば `find-up` や `execa` をESMのみへ移行し始めたとき、それは非常に大胆な一歩でした。私はこの動きをボトムアップアプローチと捉えています。というのも、これらの低レベルなパッケージや、その依存先がまだESMに対応していなかったからです。依存先が古いバージョンのまま固定され、エコシステムが断片化するのではないかと懸念していました。（しかし今日においては、この動きにより高品質なESMパッケージが数多く登場したことに感謝しています。プロセスは決してスムーズではなかったものの。）

ESMまたはデュアル形式のパッケージがCJSパッケージに依存するのは容易ですが、その逆は困難です。スムーズな採用という点では、トップダウンアプローチがエコシステムの前進により効果的であると考えています。トップレベルのフレームワークやツールの支援により、ESMのみのパッケージを利用することはもはや大きな障壁ではなく、残る課題はパッケージ作者自身がコードをESM形式へ移行・提供する点にあるといえます。

---

### Node.jsでのESM必須化

Node.jsにおいてESMモジュールを `require()` できる機能は、[JOYEECHEUNG](https://github.com) によって開始されたもので、非常に大きなマイルストーンとなります。この機能により、パッケージはESMのみとして公開されながらも、最小限の修正でCJSコードベースから利用可能になります。また、動的な `import()` によって導入される非同期的な問題（別名「Red Functions」）を回避でき、場合によっては移行や適応が非常に困難、あるいは不可能なケースでも対応が容易となります。

この機能は最近フラグ解除され、[Node.js v22](https://github.com) にバックポートされたため、既に多くの開発者が利用できるようになっています。トップダウンやボトムアップの観点に加え、この機能はミドルアウトからのESM移行も可能にしており、`ESM → CJS → ESM → CJS` のようなインポートチェーンをシームレスに動作させることができます。

詳細な進捗や議論については、[こちらのIssue](https://github.com) を参照してください。

---

## 二重形式の問題点

CJS/ESMの二重パッケージは移行のための非常に有用な手段でしたが、その運用には固有の問題も伴います。2種類の形式を別々に維持することは、特に複雑なコードベースでは煩雑でミスが起こりやすいです。以下は、二重形式維持時に発生する主な問題点です。

### 相互運用性の問題

基本的に、CJSとESMは設計思想が異なる別個のモジュールシステムです。Node.jsでは、ESM内でCJSモジュールをインポートしたり、CJS内でESMを動的にインポートしたり、さらにはESMモジュールを `require()` することも可能ですが、それでも相互運用性に関する厄介なケースが多数存在します。

大きな違いの一つは、CJSが通常単一の `module.exports` オブジェクトを使用するのに対し、ESMはデフォルトエクスポートと名前付きエクスポートの両方をサポートしている点です。ESMでコードを記述し、CJSへトランスパイルする際、エクスポートの扱いは特に難しく、エクスポートされる値がオブジェクト以外（例：関数やクラス）の場合、問題が顕著になります。さらに、型定義を正しく行うために `.d.mts` や `.d.cts` の宣言ファイルといった追加の複雑さも生じます。

正直なところ、こうした問題に悩まされる必要がそもそもないと感じます。非常に複雑で苛立たしい問題であり、パッケージの利用者はもちろん、パッケージ作者がまで心配するべきではありません。これこそが、エコシステム全体がESMへ移行すべき理由のひとつであり、この不必要な手間から皆を解放するためでもあります。

---

### 依存関係の解決

パッケージがCJSとESMの両形式を持つ場合、依存関係の解決が非常に複雑になります。例えば、あるパッケージがESMのみを提供する別のパッケージに依存している場合、利用者はESMバージョンが使用されるように注意しなければなりません。これは、特に伝播する依存関係を扱う際に、バージョンの衝突や依存関係解決の問題を引き起こす可能性があります。

さらに、シングルトンパターンで設計されたパッケージの場合、同一パッケージの複数コピーが導入され、予期しない動作を引き起こす可能性もあります。

---

### パッケージサイズ

二重形式での提供は、CJSとESMの両方のバンドルを含める必要があるため、パッケージサイズを事実上倍にしてしまいます。単一パッケージであれば数キロバイトの追加は問題にならなくても、数百の依存関係を持つプロジェクトでは、そのオーバーヘッドが急速に蓄積し、悪名高い `node_modules` の肥大化を招く恐れがあります。したがって、パッケージ作者はパッケージサイズに注意を払うべきです。特にCJSに強い依存がない場合、ESMのみへの移行はパッケージサイズ最適化の一手段となります。

---

## いつESMのみへ移行すべきか？

本投稿は二重形式での提供の価値を否定するものではなく、現状のエコシステムとESMのみへの移行がもたらす利点を評価するための一助となることを目的としています。  
ESMのみへの移行を判断する際、以下の点を考慮する必要があります。

### 新規パッケージ

既存のレガシー依存関係を気にする必要がないため、全ての新規パッケージはESMのみとしてリリースされるべきだと強く推奨します。新たな採用者は既に最新のESM対応スタックを使用している可能性が高く、ESMのみであっても採用に影響はありません。さらに、単一のモジュールシステムの維持は開発を簡素化し、保守の負担を減らし、将来的なエコシステムの進展から恩恵を受けることができます。

---

### ブラウザ向けパッケージ

パッケージが主にブラウザ向けである場合、ESMのみで提供するのは理にかなっています。ほとんどの場合、ブラウザ向けパッケージはバンドラーを通じて処理され、そこでESMは静的解析やツリーシェイキングに大きな利点を発揮します。これにより、より小さく最適化されたバンドルが生成され、読み込み性能の向上やエンドユーザーの帯域幅使用量の削減につながります。

---

### スタンドアロンのCLI

スタンドアロンのCLIツールの場合、利用者にとってESMかCJSかは大きな違いはありません。しかし、ESMを採用することで依存関係もESMとなり、トップダウンアプローチによるエコシステムのESM移行を促進する効果があります。

---

### Node.jsのサポート

パッケージが常に最新のNode.jsバージョンをターゲットにしている場合、特に最近の `require(ESM)` サポートを踏まえると、ESMのみへの移行を検討する絶好のタイミングです。

---

### 利用者を理解する

すでに一定のユーザーが存在するパッケージの場合、依存先の状況や要件を把握することが重要です。たとえば、ESLint v9を必要とするESLintプラグインやユーティリティにおいて、ESLint v9の新しい設定システムはCJSプロジェクト内でもネイティブにESMをサポートしているため、ESMのみであることに対する大きな障壁はありません。

確かに、プロジェクトごとに考慮すべき要因は異なりますが、全体として、エコシステムはより多くのパッケージがESMのみへ移行する準備が整っており、その利点と潜在的な課題を検証するのに良い時期であると私は考えています。

---

## どこまで進んでいるのか？

ESMへの移行は、エコシステム全体の協力と努力を必要とする段階的なプロセスです。私は、私たちはこの移行の道を順調に進んでいると信じています。

ESM採用の透明性と可視性を向上させるため、私は最近、パッケージの依存関係を解析するための視覚化ツール「Node Modules Inspector」を開発しました。これにより、依存関係のESM採用状況を把握し、ESM移行時の潜在的な問題を特定する手助けとなります。

以下は、このツールの印象を伝えるためのスクリーンショットです：

- **[画像 1] Node Modules Inspector - 概要**
- **[画像 2] Node Modules Inspector - 依存関係グラフ**
- **[画像 3] Node Modules Inspector - ESM採用状況や重複パッケージのレポート**

このツールはまだ初期段階にありますが、パッケージ作者やメンテナーが依存関係のESM採用進捗を追跡し、ESMのみへの移行について適切な判断を下すための貴重なリソースになることを期待しています。  
使用方法やプロジェクトの検査方法について詳しくは、[node-modules-inspector のリポジトリ](https://github.com) をご覧ください。

---

## 今後の展望

今後、私がメンテナンスしているパッケージを段階的にESMのみへ移行し、依存しているライブラリについてもより詳しく見直す予定です。また、Node Modules Inspector に関しても、さらに有用な洞察を提供し、最適な道筋を見出すためのエキサイティングなアイデアが多数あります。

より移植性が高く、堅牢で、最適化されたJavaScript/TypeScriptエコシステムの実現を心待ちにしています。

本投稿が、ESMのみへの移行の利点や現状のエコシステムの状況について何かしらの示唆を与えるものであったなら幸いです。ご意見やご質問がありましたら、下記のリンクからお気軽にお寄せください。ご一読、ありがとうございました！
