# ClineでMemory Bankをやめてタスクリストを使うことによってコンテキストを最適化してる

ref: <https://zenn.dev/jtechjapan_pub/articles/a1cace00f7f96f>

## はじめに

この記事では、AIアシスタント「Cline」とLLM「Sonnet 3.7」を使用した開発において、コンテキスト最適化のための新しいアプローチを紹介しています。記事冒頭には、OpenAIの画像生成機能を使って作成された、記事内容を図解したグラレコ風マインドマップが掲載されています。

## Memory Bankの使い分け：大規模コードベースでの考慮点

Memory Bankは状況に応じて選択的に活用すべきツールです。特に大きなコードベースを扱う場合、Memory Bankを使わない方が効果的なケースが多いことが示されています。

### 使い分けの基準

- **大きなコードベースの一部を正確に変更したい場合**：Memory Bankを使わない方が効率的
- **Vive Coding的にLLM主導で新規開発する場合**：Memory Bankを活用する方が良い

Memory Bankはコンテキストを豊富に提供できる強力なツールですが、大量の情報が与えられることでAIの注意が分散し、実際の命令に従う精度が下がることがあります。大規模なコードベースの修正では、LLMに自由度を与えるよりも、範囲を適切に限定した方がより正確な結果を得られることが多いです。

## Memory Bankの代替アプローチ

### 1. clinerules-bankと.clinerules フォルダの活用

- 真に重要な少量のドキュメントを`.clinerules`フォルダに配置（`.gitignore`の対象にするのがおすすめ）
- `clinerules-bank`の中にカテゴリ別の詳細な指示を整理：
  - ドメイン変更時のルール
  - フロントエンド変更時のルール など
- これによりタスクごとに`.clinerules`ファイル内のコンテキスト量を最適化

### 2. VS Codeのルートフォルダを最小化する

- 複数のソリューションを含む大規模リポジトリでは、変更対象外のコードが誤って修正されるリスクがある
- 解決策：リポジトリルート全体ではなく、ソリューション単位やプロジェクト単位でVS Codeを開く
- これによりClineは開いているフォルダ内のコードのみを検索・編集するようになり、スコープが自然と限定される

### 3. tasksフォルダによるタスク管理

- Clineとのチャット履歴だけでなく、タスク情報をローカルに体系的に保存
- 実装方法：
  - プロジェクトルートに`tasks`フォルダを作成
  - `001_task_name.md`のような命名規則でタスクファイルを作成
  - タスクファイルには以下を詳細に記述：
    - 参照すべきファイル
    - 必要な変更内容
    - 使用すべき言語機能やアプローチ
    - 制約条件

## タスク例と実行の流れ

### タスク例

```md
005_improve_event_handling.md
AspireEventSample.ApiService/Grains/EventConsumerGrain.cs
をリファクタリングしたい。
OnNextAsync の中で行っていることを、できれば汎用化して純粋関数化したい。
それによって、同じコードを使い回して、Readmodel Updatorを実行できるようにしたい
今やっている、OrleansのイベントストリーミングでRead Model を作成する方法
かつ、コンソールアプリで最初のイベントから今まで、もしくは過去の何処かから今までと実行できるようにしたい。
それを行うための抽象化を行いたいです。
つまり純粋関数を持つクラスを作り、
AspireEventSample.ApiService/Grains/EventConsumerGrain.cs
から呼び出す機能を作る。
ただ、このタスクでは計画するだけです。
このファイルの下部に計画をよく考えて記入してください。必要なファイルの読み込みなど調査を行い、できるだけ具体的に計画してください。
チャットではなく、このファイル
clinerules_bank/tasks/005_improve_event_handling.md
を編集して、下に現在の設計を書いてください。
+++++++++++以下に計画を書く+++++++++++
```

### タスク実行の流れ

1. **計画フェーズ**：まずタスクファイルに計画を詳細に立てさせる
   - [Task 5 (Planning)](https://github.com/J-Tech-Japan/Sekiban/blob/8c7fcfdb224dc8435e6cb961dbb7d3ea28623dd7/Samples/Tutorials/AspireEventSample/clinerules_bank/tasks/005_improve_event_handling.md)

2. **計画の評価と調整**：計画が意図と異なる場合は、新たなタスクファイルで方向性を調整
   - [Task 6 (Adjustment)](https://github.com/J-Tech-Japan/Sekiban/blob/8c7fcfdb224dc8435e6cb961dbb7d3ea28623dd7/Samples/Tutorials/AspireEventSample/clinerules_bank/tasks/006_more_thinking.md)
   - [Task 7 (Progress)](https://github.com/J-Tech-Japan/Sekiban/blob/8c7fcfdb224dc8435e6cb961dbb7d3ea28623dd7/Samples/Tutorials/AspireEventSample/clinerules_bank/tasks/007_readmodel_handler.md)
   - [Task 8 (Completion)](https://github.com/J-Tech-Japan/Sekiban/blob/8c7fcfdb224dc8435e6cb961dbb7d3ea28623dd7/Samples/Tutorials/AspireEventSample/clinerules_bank/tasks/008_readmodel.md)

3. **実装フェーズ**：満足できる計画ができたら、実際のコード変更を指示

### ポイント

- タスクファイルに指示を書く際は、ファイル名を明示的に指定することが効果的

```md
チャットではなく、このファイル
clinerules_bank/tasks/005_improve_event_handling.md
を編集して、下に現在の設計を書いてください。
+++++++++++以下に計画を書く+++++++++++
```

- 簡単なタスクは直接指示できますが、複雑なタスクは計画→調整→実装の段階的アプローチが有効

## 結論：AIとの効果的な協業のために

これらの新しいアプローチを活用することで、以下のメリットがあります：

- 大規模な誤修正を防ぎ、品質の高いコード生成が可能に
- 「動けば良い」という姿勢ではなく、設計の質を保ちながら開発速度を向上
- コアなドメインやフレームワーク開発では、コードは開発者の意図を正確に反映し、自分で書いた場合と同等以上の品質であるべき

最近のClineとSonnet 3.7を活用した開発では、適切な指示と設計を与えれば、正確なコードを迅速に生成できるようになってきました。そのため、影響範囲の大きいコードに関しては、良い設計を行うことがより一層重要になっています。

AIが一発で正解を出せない場合には、修正方針を示し、正しい方向に導く開発者のスキルがまだ必要です。数年後にはAIの能力がさらに向上することが期待されますが、現段階では「開発者が作れるレベルのプログラムをAIと共同で効率的に開発する」という考え方が現実的です。

この記事で紹介した手法は今後数ヶ月で最適化が進み、さらに良い方法が生まれるでしょうが、現時点での知見として共有されています。

---

この記事は、J-Tech Creations社のVPoEであり、Microsoft MVP（Developer Technologies）である「tomohisa」氏によって書かれています。イベントソーシング・CQRSフレームワーク「Sekiban」の開発を行っているとのことです。

---

I'll conduct a thorough investigation to find supporting data for the effectiveness of task list approaches like those described in the article.

# タスクリストアプローチの有効性に関する調査結果

Clineでのタスクリスト型アプローチとMemory Bankの比較に関する調査を行いました。以下が主な調査結果です。

## 直接的な比較研究の状況

現状では、特にClineのようなAIコーディングアシスタントにおける「タスクリストアプローチ」と「Memory Bank」を直接比較した学術研究は限られています。元記事の主張は主に著者の実務経験に基づいているようです。

## タスク分解の有効性に関する研究

タスク分解アプローチ自体の有効性については、複数の研究結果が支持しています：

1. **「B.R.E.A.K.フレームワーク」** - 複雑な指示をより単純な部分に分解することで、LLMのプロンプト効果を高める方法として紹介されています。
   - "複雑な指示は、より単純な部分に分解されると理解しやすくなります。これにより曖昧さが減少し、LLMがタスクをより理解して実行できるようになります"
   - "LLMは限られたコンテキストウィンドウを持っています。タスクを一度に一部ずつ扱うことで、モデルは関連情報をより効果的に保持し、メモリオーバーロードを回避できます"

2. **「分解プロンプティング（DECOMP）」** - 複雑なタスクをより単純なサブタスクに分解し、それぞれに適切なハンドラーを割り当てる技術として紹介されています。
   - "複雑なタスクを分解することで、より大きなモデルを必要とせずにAIのパフォーマンスを向上させる顕著な成功を示しています"

3. **プログラミングタスクでの検証結果** - コードに関連するタスクでは、特に分解アプローチの効果が確認されています：
   - "複雑なプログラムを分解することで、識別精度と修復されたソリューションの品質が大幅に向上します"

## 大規模コードベースでの注意とコンテキスト管理

研究結果は、大規模コードベースに対処する際のコンテキスト管理の課題を示唆しています：

1. **注意分散の問題** - "現世代のLLMが内部メモリや以前の対話のコンテキストのみに依存して、異なるタスクと目標を同時に管理することには固有の課題がある"という研究結果は、元記事の主張と一致しています。

2. **コンテキストウィンドウの管理** - "コンテキストウィンドウキャッシング"に関する研究では、計算リソースを選択的に割り当てるアプローチが処理効率を向上させることが示されています。これは、幅広いMemory Bankアプローチよりも、焦点を絞ったタスク指向アプローチが特定のシナリオでより効率的である可能性を間接的に支持しています。

## 実務的な証拠

元記事で紹介されている実践例は、タスクリストアプローチの実用的な有効性を示す証拠として価値があります：

1. **Sekibanフレームワークの実装例** - 著者の実際のプロジェクトにおける使用例と、GitHubリンクによる実装の検証可能性
2. **段階的な計画→調整→実装アプローチ** - 複雑なタスクを管理するための実用的なワークフロー

## 結論

タスクリストアプローチがMemory Bankより効果的であるという元記事の主張を直接検証する研究は限られていますが、以下の点から理論的には妥当性があると考えられます：

1. LLMのコンテキスト管理能力には限界があるという研究結果
2. タスク分解による複雑問題解決の効果に関する広範な支持
3. 焦点を絞ったアプローチがコンテキスト窓の限界に対処するのに効果的であるという示唆

ただし、この領域ではまだ直接的な比較研究が不足しており、元記事の主張は主に実践的経験に基づいていることに注意が必要です。今後のAI開発アシスタント研究においては、様々なコンテキスト管理アプローチの効果を直接比較する研究が望まれます。
