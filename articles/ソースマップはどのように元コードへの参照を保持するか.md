---
title: "ソースマップはどのように元コードへの参照を保持するか"
source: "https://www.docswell.com/s/4136989/574PP1-fec_kansai_long"
author:
  - "yuta-ike"
published: 2025-11-30
created: 2025-12-02
description: |
  フロントエンドカンファレンス関西2025での発表資料。TypeScriptやJavaScriptのトランスパイル・ミニファイ後のコードから元のソースコードへの参照を保持するソースマップの仕組みを詳しく解説。シンボル単位のマッピング、差分符号化、Base64 VLQエンコーディングなどの技術的な詳細を説明。
tags:
  - "source-map"
  - "frontend"
  - "typescript"
  - "javascript"
  - "debugging"
  - "ecma-426"
  - "clippings"
---

## 1. ソースマップについて

### ソースマップの重要性

フロントエンド開発では、私たちが書くプログラムと実行されるプログラムが異なることが一般的です。

- **プログラマが書く**: TypeScript、JSXなど
- **ブラウザが実行する**: JavaScript（トランスパイル・ミニファイ後）

この変換により、エラーメッセージが「`index.js`の1234行目の5678文字目でエラー！」のように表示されても、元のTypeScriptファイルのどの位置に対応するのかが分からなくなってしまいます。

ソースマップは、変換前後の対応を保持しておき、ログやスタックトレースで変換前の位置情報を提供する仕組みです。これにより、エラーメッセージが「`App.ts`の5行目の12文字目でエラー！」のように、元のソースコードの位置で表示されるようになります。

フロントエンドでは大なり小なりトランスパイルが当たり前の世界であり、JSファイルの何行目/何文字目が、変換前のファイルのどこに対応するかがわかることは開発生産性に直結します。

### ソースマップの場所

ソースマップは以下の方法で指定できます：

1. **ファイル内にインラインで埋め込む**（vite devモードなど）
   - コメント形式: `//# sourceMappingURL=...`
   - 正規表現: `/^[@#]\s*sourceMappingURL=(\S*?)\s*$/`（`@`は古い書き方）

2. **別ファイルに分割**（本番ビルド時）
   - 例: `hoge.js.map`ファイルとして生成

3. **HTTPヘッダで指定**
   - `SourceMap: <URL>`の形式

## 2. ソースマップの仕組み

### ソースマップの構造

ソースマップはJSON形式で、以下のフィールドを持ちます：

```json
{
  "version": 3,
  "mappings": "AAAA,SAAS,gBAAgB...",
  "names": ["calc", "price", "tax"],
  "sources": ["App.tsx"],
  "sourcesContent": ["import { useState } from \"react\";\n..."]
}
```

- **version**: ソースマップのバージョン（現在はv3）
- **mappings**: 変換前後の位置マッピングを表す文字列（圧縮済み）
- **names**: 変換前の名前（変数名など）の配列
- **sources**: 変換前のファイル名の配列
- **sourcesContent**: 変換前のソースコード本体（オプション、含まれない場合もある）

### mappingsの役割

`mappings`フィールドは、変換前後の位置対応を圧縮して表現した文字列です。この文字列をデコードすることで、元のソースコードの位置情報が取得できます。

## 3. ソースマップの詳細な仕組み

### 基本的な考え方

ソースマップは**シンボル単位**（変数、予約語、記号など）でマッピングを持ちます。

各シンボルに対して、以下の5つの要素でマッピングを表します：

1. **変換前の列位置**（何文字目）
2. **変換前のファイル名**（sources配列のインデックス）
3. **変換後の行番号**（何行目）
4. **変換後の列位置**（何文字目）
5. **変換前の名前**（names配列のインデックス、オプション）

例: `29 "calc.ts" 1 21 "tax"` は、「変換前の29文字目にある`tax`が、変換後の1行目21文字目に対応する」ことを表します。

### 容量削減の工夫

ソースマップの課題は容量の大きさです。効率的なエンコーディングのために、以下の2つの工夫が採用されています。

#### 工夫1: 差分符号化

各フィールドが行数や文字数を表すため、大きなファイルでは値が巨大になります（例: 3000行目の500文字目）。

これを解決するため、**直前のセグメントからの差分**で表現します。隣り合ったシンボルは変換前後でも隣り合う可能性が高いため、差分は小さな値になり、効率的に圧縮できます。

例:

- 前のセグメント: `12 0 1 14 1`
- 現在のセグメント: `29 0 1 21 2`
- 差分: `+17 +0 +0 +7 +1`

#### 工夫2: Base64 VLQ（Variable-Length Quantity）

VLQは可変長な数量を表すエンコーディング方式です。小さい整数はアルファベット1文字で、大きな整数は複数文字で表現します。これにより、最大の整数に合わせて桁数を決定するよりも効率的に圧縮できます。

**小さい整数の場合**:

- `+0` → 2進表現 `00000` → Base64文字 `A`
- `+1` → 2進表現 `00010` → Base64文字 `C`

**大きい整数の場合**:

- `+29` → 2進表現 `000011101` → 分割して `6B`（2文字）

各文字には継続ビットが含まれ、複数文字に分割されていることを示します。

### 変換の流れ

1. 各シンボルに対して5つの要素（変換前の列、ファイル名インデックス、変換後の行、変換後の列、名前インデックス）を取得
2. 文字列（ファイル名、名前）を配列のインデックスに変換して重複を排除
3. 直前のセグメントからの差分を計算
4. 各差分値をBase64 VLQでエンコード
5. エンコードされた文字列を結合して`mappings`フィールドに格納

## さいごに

### 仕様について

ソースマップの仕様は**ECMA International**によって定められています（ECMA-426）。

- 歴史的にはv1, v2があり、現在はv3
- v2からv3になったことで圧縮効率が良くなっている
- JavaScriptがメインのユースケースだが、CSSやWebAssemblyでのコメントの書き方も定義されている

### Tips

1. **Chromeの手動アップロード機能**
   - Chromeは手動でソースマップをアップロードする機能を提供
   - 本番環境などソースマップを配布できない環境で、外部ツールに頼らずデバッグが可能

2. **Visualization Tools**
   - ソースマップつきのビルド済みファイルをアップロードすると可視化してくれるツール
   - <https://sokra.github.io/source-map-visualization/#custom>

3. **debuggerとの関係**
   - ソースマップは単に行数を変換するだけでなく、debuggerにも関連
   - TypeScriptファイル上でdebuggerを設定できるのはソースマップがあるから

### 現在のソースマップの改善点

現在のソースマップでは、minifyやoptimizerによって削除/インライン化された関数や変数の扱いが難しいという課題があります。

これを解決するために、**scope**という概念を追加することが議論されています。

例:

```javascript
// ビルド前
const getName = (name) => `${name}さん`
console.log(getName("Yuta"))

// ビルド後
console.log("Yutaさん")
```

この場合、`getName`関数がインライン化されて消えてしまうため、デバッグ時に元の関数名を追跡することが困難になります。

## 参考リンク

- Source map format specification: <https://tc39.es/ecma426>
- tc39/ecma426: <https://github.com/tc39/ecma426>
- Proposal for adding information about scopes: <https://github.com/tc39/ecma426/blob/main/proposals/scopes.md>
- source-map-visualization: <https://sokra.github.io/source-map-visualization/#custom>
- Source map - Glossary | MDN: <https://developer.mozilla.org/en-US/docs/Glossary/Source_map>
- JavaScript ソースマップの概要 | Chrome for Developers: <https://developer.chrome.com/blog/sourcemaps>
- Build Options | Vite: <https://vite.dev/config/build-options#build-sourcemap>
- デベロッパー リソース: ソースマップの表示と手動読み込み | Chrome DevTools: <https://developer.chrome.com/docs/devtools/developer-resources>
- Source Mapの仕組み: <https://keichi.dev/post/decoding-source-maps/>
- What are source maps? | web.dev: <https://web.dev/articles/source-maps>
- Variable-length quantity - Wikipedia: <https://en.wikipedia.org/wiki/Variable-length_quantity>
- ソースマップのことを何もわかっていなかったので調べた: <https://www.nabeliwo.blue/blog/2022/09/source-map>
- Base64 VLQ 概要: <https://speakerdeck.com/rchaser53/base64-vlqgai-yao>
