---
title: "制御の逆転 - Martin Fowler's Bliki (ja)"
source: "https://bliki-ja.github.io/InversionOfControl"
author:
  - Martin Fowler
published: 2005-06-26
created: 2025-10-20
description: "制御の逆転（IoC: Inversion of Control）は、フレームワークをフレームワークたらしめる本質的な特徴です。従来のライブラリがユーザーコードから呼び出されるのに対し、フレームワークはユーザーコードを呼び出す「ハリウッド原則（我々を呼ぶな。我々が呼ぶから）」を体現しています。"
tags:
  - application-architecture
  - API-design
  - object-collaboration-design
  - framework
  - inversion-of-control
---

## 制御の逆転とは

制御の逆転（Inversion of Control）は、フレームワークを使う際に現れる重要な現象で、フレームワークをフレームワークたらしめる本質的な特徴です。

## コマンドライン版とウィンドウシステム版の比較

### コマンドライン版の制御フロー

ユーザーに情報を入力させる単純なプログラムの例：

```ruby
puts 'What is your name?'
name = gets
process_name(name)
puts 'What is your quest?'
quest = gets
process_quest(quest)
```

このコードでは、**書いたコードがプログラムの制御を握っています**。質問の表示、入力の取得、結果の処理を行うタイミングは、すべてこのコードが決定しています。

### ウィンドウシステム版の制御フロー

同じ機能をウィンドウシステムで実装した場合：

```ruby
require 'tk'
root = TkRoot.new()
name_label = TkLabel.new() {text "What is Your Name?"}
name_label.pack
name = TkEntry.new(root).pack
name.bind("FocusOut") {process_name(name)}
quest_label = TkLabel.new() {text "What is Your Quest?"}
quest_label.pack
quest = TkEntry.new(root).pack
quest.bind("FocusOut") {process_quest(quest)}
Tk.mainloop()
```

ウィンドウ版では、`process_name`や`process_quest`メソッドの呼び出しタイミングが大きく異なります。**メソッドを呼び出すタイミングの決定はウィンドウシステムに委ねられており**、`Tk.mainloop`コマンドによってフレームワークが制御を握ります。

フレームワークは、フォーム作成時のバインド設定に従って、コードを呼び出すタイミングを決定します。つまり、**制御が逆転している**のです。フレームワークを呼び出すのではなく、**フレームワークに呼び出される**のです。

### ハリウッド原則

この現象は「**ハリウッド原則**」とも呼ばれます：「**我々を呼ぶな。我々が呼ぶから（Don't call us, we'll call you）**」

## フレームワークの定義

Ralph JohnsonとBrian Footeによる定義：

> フレームワークの第一の重要な特徴は、フレームワークに合わせて利用者が定義したメソッドが、アプリケーションコードからはあまり呼ばれず、フレームワーク自身からよく呼び出されるという点だ。フレームワークは、アプリケーションの動作を調整したり、動作の順番を制御したりするためのメインプログラムとしての役割を果たす。制御の逆転によって、フレームワークを拡張可能なスケルトンとして動作することができる。フレームワークが定義した汎用アルゴリズムにあわせて、利用者はメソッドを作成し、個別のアプリケーションをつくりあげる。

## フレームワークとライブラリの違い

**制御の逆転の存在が、フレームワークとライブラリを決定的に違うものにしています。**

### ライブラリ

- 基本的に呼び出し可能な関数（最近ではクラス）の集まり
- 関数を呼び出すと、何らかの作業を行い、クライアントに制御を返す
- **ユーザーコードがライブラリを呼び出す**

### フレームワーク

- 抽象的な設計を含み、より多くの振る舞いが組み込まれている
- 作成したクラスをサブクラス化やプラグインによってフレームワークに組み込む
- **フレームワークのコードがユーザーコードを呼び出す**

## コードをフレームワークに組み込む方法

### 1. クロージャを使った方法

Rubyの例では、イベント名とクロージャを引数にして、テキスト入力フィールドの`bind`メソッドを呼び出しています。テキストボックスがイベントを検知すると、クロージャのコードを呼び出します。

**利点**: 大変便利
**制限**: サポートしている実装言語は多くない

### 2. イベントとデリゲート

フレームワークにイベントを定義させ、クライアントコードからそのイベントをサブスクライブする方法です。

**.NETの例**: ウィジットにイベントを定義できる言語特性を持ち、delegateを使ってメソッドをイベントにバインドできます。

### 3. インターフェースの実装

複数の必要なメソッド呼び出しをひとつの拡張にまとめたい場合、フレームワークにインターフェースを定義し、クライアントコードが関連する呼び出しを実装します。

**EJBの例**: Session Beanを開発する際、EJBコンテナから様々なポイントで呼び出されるメソッドを実装します：

- `ejbRemove`
- `ejbPassive`（補助ストレージへの永続化）
- `ejbActivate`（パッシブ状態からのリストア）

これらのメソッドの呼び出しを制御することはできず、どう動作するかを定義するだけです。**コンテナが我々を呼び出し、我々はコンテナを呼び出さない**のです。

### 4. テンプレートメソッドパターン

より簡単な制御の逆転の例：

- スーパークラスが制御の流れを定義
- サブクラスがメソッドや抽象メソッドをオーバーライドして拡張

**JUnitの例**: フレームワークのコードが`setUp`と`tearDown`メソッドを呼び出し、テスト本文部分の準備と掃除を行います。フレームワークが呼び出しを行い、それにユーザーのコードが反応する——再び制御が反転しています。

## IoCコンテナとの混同

最近、IoCコンテナの盛り上がりにより、制御の逆転の意味をめぐって混乱が生じています。

一般的な原則としての「制御の逆転」を、**依存性注入（Dependency Injection）**のような特化したスタイルの制御の逆転と混同している人がいます。

**重要な点**: IoCコンテナがEJBの競合と見なされるため、その名前が紛らわしいのですが、**EJBも制御の逆転をIoCコンテナ以上に使っている**のです。

## 語源と歴史

### 「制御の逆転」の初出

**1988年**: JohnsonとFooteの論文『[Designing Reusable Classes](http://www.laputan.org/drc/drc.html)』（Object-Oriented Programming誌掲載）に最初に登場。15年以上経った今でも十分に読む価値があります。

### 「ハリウッド原則」の初出

**1983年**: Richard SweetのMesaについての論文が初出のようです。Design Goalsの章で以下のように記述：

> 我々を呼ぶな。我々が呼ぶ。（ハリウッド規則）：ツールは、「ユーザーにコマンドや実行を尋ねる」モデルを採用するのではなく、Tajo（訳注：Mesaプロジェクトにおけるユーザーインターフェース部品）をあらかじめ準備して、利用者がツールにイベント知らせたいと思ったときに通知できるようにすべきだ。

John Vlissidesは[C++レポートというコラム](http://www.research.ibm.com/designpatterns/pubs/ph-feb96.txt)の中で、「ハリウッド原則」の概念についてうまく説明しています。

### その後の展開

この言葉はオブジェクト指向コミュニティに取り込まれ、GoF本（Gang of Four - デザインパターン）にも登場しました。

## まとめ

制御の逆転は、フレームワークアーキテクチャの根幹をなす概念です：

1. **従来のライブラリ**: ユーザーコード → ライブラリ（呼び出す）
2. **フレームワーク**: フレームワーク → ユーザーコード（呼び出される）

この原則により、フレームワークは拡張可能なスケルトンとして機能し、利用者は特定のメソッドを実装することで個別のアプリケーションを構築できます。制御の流れが逆転することで、フレームワークが全体の制御フローを管理し、適切なタイミングでユーザーコードを呼び出す仕組みが実現されています。
