---
title: "JavaScript 実行モデル - JavaScript | MDN"
source: "https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Execution_model"
author:
  - "[[MDN contributors]]"
published: 2025-04-16
created: 2025-06-23
description: |
  このページでは、JavaScript ランタイム環境の基本的なインフラストラクチャを紹介します。このモデルは大部分が理論的かつ抽象的であり、プラットフォーム固有または実装固有の詳細は含まれていません。現代の JavaScript エンジンは、記述されたセマンティクスを大幅に最適化しています。
tags:
  - "JavaScript"
  - "Execution Model"
  - "Event Loop"
  - "Call Stack"
  - "Concurrency"
---

このページでは、JavaScript ランタイム環境の基本的なインフラストラクチャを紹介します。このモデルは大部分が理論的かつ抽象的であり、プラットフォーム固有または実装固有の詳細は含まれていません。現代の JavaScript エンジンは、記述されたセマンティクスを大幅に最適化しています。

## エンジンとホスト

JavaScript の実行には、**JavaScript エンジン**と**ホスト環境**という 2 つのソフトウェアの協力が必要です。

JavaScript エンジンは ECMAScript (JavaScript) 言語を実装し、コア機能を提供します。ソースコードを受け取り、それを解析して実行します。しかし、意味のある出力を生成したり、外部リソースとインターフェースしたり、セキュリティやパフォーマンス関連のメカニズムを実装するなど、外の世界と対話するためには、ホスト環境によって提供される追加の環境固有のメカニズムが必要です。たとえば、Web ブラウザで JavaScript を実行する場合、HTML DOM がホスト環境です。Node.js は、JavaScript をサーバーサイドで実行できる別のホスト環境です。

このリファレンスでは主に ECMAScript で定義されたメカニズムに焦点を当てますが、Node.js や Deno のような他のホスト環境でしばしば模倣される HTML 仕様で定義されたメカニズムについても時折触れます。これにより、Web やそれ以降で使用される JavaScript 実行モデルの首尾一貫した全体像を提供できます。

## エージェント実行モデル

JavaScript の仕様では、JavaScript の各自律的な実行者を**エージェント**と呼びます。エージェントはコード実行のための以下の機能を維持します。

* **ヒープ** (オブジェクトの): これは、大部分が非構造化された広大なメモリ領域を示すための名前にすぎません。プログラムでオブジェクトが作成されると、この領域が使用されます。共有メモリの場合、各エージェントは独自のヒープと独自の [`SharedArrayBuffer`](https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/SharedArrayBuffer) オブジェクトのバージョンを持ちますが、バッファによって表される基になるメモリは共有されることに注意してください。
* **キュー** (ジョブの): これは HTML では（そして一般的に）*イベントループ*として知られており、シングルスレッドでありながら JavaScript での非同期プログラミングを可能にします。一般的に先入れ先出しであるためキューと呼ばれます。つまり、先のジョブが後のジョブより先に実行されます。
* **スタック** (実行コンテキストの): これは*コールスタック*として知られており、関数などの実行コンテキストに出入りすることで制御フローを転送できます。後入れ先出しであるためスタックと呼ばれます。すべてのジョブは、（空の）スタックに新しいフレームをプッシュすることで開始し、スタックを空にすることで終了します。

これらは、異なるデータを追跡する 3 つの異なるデータ構造です。次のセクションでキューとスタックについて詳しく説明します。ヒープメモリの割り当てと解放の方法については、[メモリ管理](https://developer.mozilla.org/ja/docs/Web/JavaScript/Guide/Memory_management)を参照してください。

各エージェントはスレッドに類似しています（基になる実装が実際のオペレーティングシステムのスレッドである場合とそうでない場合があります）。各エージェントは、互いに同期的にアクセスできる複数の[レルム](#レルム)（グローバルオブジェクトと 1 対 1 で対応）を所有できるため、単一の実行スレッドで実行する必要があります。エージェントには、リトルエンディアンであるか、[同期的にブロック](#並行性と進行の確保)できるか、アトミック操作が[ロックフリー](https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Atomics/isLockFree)であるかなどを示す単一のメモリモデルもあります。

Web 上のエージェントは、次のいずれかになります。

* *類似オリジンウィンドウエージェント*: 直接または [`document.domain`](https://developer.mozilla.org/ja/docs/Web/API/Document/domain) を使用して互いに到達できる可能性のあるさまざまな [`Window`](https://developer.mozilla.org/ja/docs/Web/API/Window) オブジェクトが含まれます。ウィンドウが[オリジンキー付き](https://developer.mozilla.org/ja/docs/Web/API/Window/originAgentCluster)の場合、同一オリジンのウィンドウのみが互いに到達できます。
* 単一の [`DedicatedWorkerGlobalScope`](https://developer.mozilla.org/ja/docs/Web/API/DedicatedWorkerGlobalScope) を含む*専用ワーカーエージェント*。
* 単一の [`SharedWorkerGlobalScope`](https://developer.mozilla.org/ja/docs/Web/API/SharedWorkerGlobalScope) を含む*共有ワーカーエージェント*。
* 単一の [`ServiceWorkerGlobalScope`](https://developer.mozilla.org/ja/docs/Web/API/ServiceWorkerGlobalScope) を含む*サービスワーカーエージェント*。
* 単一の [`WorkletGlobalScope`](https://developer.mozilla.org/ja/docs/Web/API/WorkletGlobalScope) を含む*ワークレットエージェント*。

言い換えれば、各ワーカーは独自のエージェントを作成しますが、1 つ以上のウィンドウが同じエージェント内に存在する場合があります。通常はメインドキュメントとその類似オリジンの iframe です。Node.js では、[ワーカースレッド](https://nodejs.org/api/worker_threads.html)と呼ばれる同様の概念が利用できます。

以下の図は、エージェントの実行モデルを示しています。

![2つのエージェント（HTMLページとワーカー）からなる図。それぞれが実行コンテキストを含むスタック、オブジェクトを含むヒープ、ジョブを含むキューを持っています。](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Execution_model/runtime-environment-diagram.svg)

## レルム

各エージェントは 1 つ以上の**レルム**を所有します。JavaScript コードの各部分は、ロードされるときにレルムに関連付けられ、別のレルムから呼び出されても同じままです。レルムは以下の情報で構成されます。

* `Array`、`Array.prototype`などの組み込みオブジェクトのリスト
* グローバルに宣言された変数、[`globalThis`](https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/globalThis) の値、およびグローバルオブジェクト
* 同じタグ付きテンプレートリテラル式の評価は常にタグが同じ配列オブジェクトを受け取る原因となるため、[テンプレートリテラル配列](https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Template_literals#tagged_templates)のキャッシュ

Web では、レルムとグローバルオブジェクトは 1 対 1 で対応しています。グローバルオブジェクトは [`Window`](https://developer.mozilla.org/ja/docs/Web/API/Window)、[`WorkerGlobalScope`](https://developer.mozilla.org/ja/docs/Web/API/WorkerGlobalScope)、または [`WorkletGlobalScope`](https://developer.mozilla.org/ja/docs/Web/API/WorkletGlobalScope) のいずれかです。したがって、たとえば、すべての `iframe` は異なるレルムで実行されますが、親ウィンドウと同じエージェントにある場合があります。

レルムは通常、グローバルオブジェクトのアイデンティティについて話すときに言及されます。たとえば、別のレルムで構築された配列は現在のレルムの `Array.prototype` オブジェクトとは異なるプロトタイプオブジェクトを持つため、`instanceof Array` は誤って `false` を返すため、[`Array.isArray()`](https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Array/isArray) や `Error.isError()` などのメソッドが必要です。

## スタックと実行コンテキスト

まず、同期コードの実行について考えます。各[ジョブ](#ジョブキューとイベントループ)は、関連するコールバックを呼び出すことによって開始されます。このコールバック内のコードは、変数を作成したり、関数を呼び出したり、終了したりする場合があります。各関数は、独自の変数環境とどこに戻るかを追跡する必要があります。これを処理するために、エージェントは実行コンテキストを追跡するためのスタックを必要とします。一般に*スタックフレーム*として知られている**実行コンテキスト**は、実行の最小単位です。次の情報を追跡します。

* コード評価状態
* このコードを含むモジュールまたはスクリプト、関数（該当する場合）、および現在実行中の[ジェネレーター](https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Generator)
* 現在の[レルム](#レルム)
* 以下を含む[バインディング](https://developer.mozilla.org/ja/docs/Glossary/Binding)：
  * `var`、`let`、`const`、`function`、`class`などで定義された変数
  * 現在のコンテキストでのみ有効な `#foo` のようなプライベート識別子
  * `this` 参照

### ジェネレーターと再入

フレームがポップされても、必ずしも永久に消えるわけではありません。なぜなら、時にはそこに戻る必要があるからです。たとえば、ジェネレーター関数を考えてみましょう。
`g.next()` が呼び出されると、`gen` の実行コンテキストがスタックにプッシュされ、`gen` 内のコードが `yield` 式まで実行されます。その後、ジェネレーターの実行コンテキストは中断され、スタックから削除され、制御がエントリポイントに戻ります。`g.next()` が再度呼び出されると、ジェネレーターの実行コンテキストがスタックにプッシュバックされ、`gen` 内のコードは中断したところから再開します。

### 末尾呼び出し

仕様で定義されているメカニズムの 1 つに、*適切な末尾呼び出し* (PTC) があります。関数呼び出しが末尾呼び出しであるのは、呼び出し元が呼び出し後に値を返す以外に何もしない場合です。
関数呼び出しが末尾位置にある場合、エンジンは現在の実行コンテキストを破棄し、`g()` 呼び出し用の新しいフレームをプッシュする代わりに、末尾呼び出しのコンテキストに置き換える必要があります。これは、末尾再帰がスタックサイズの制限を受けないことを意味します。

### クロージャー

変数スコープと関数呼び出しに関連するもう 1 つの興味深い現象は、[クロージャー](https://developer.mozilla.org/ja/docs/Web/JavaScript/Guide/Closures)です。関数が作成されるたびに、現在の実行中の実行コンテキストの変数バインディングも内部的に記憶します。その後、これらの変数バインディングは実行コンテキストよりも長く存続できます。

## ジョブキューとイベントループ

エージェントはスレッドであり、これはインタープリターが一度に 1 つのステートメントしか処理できないことを意味します。コードがすべて同期している場合は、常に進行できるため問題ありません。しかし、コードが非同期アクションを実行する必要がある場合、そのアクションが完了するまで進行できません。ただし、プログラム全体が停止してしまうとユーザーエクスペリエンスに悪影響を及ぼします。Web スクリプト言語としての JavaScript の性質上、[決してブロックしない](#決してブロックしない)必要があります。したがって、その非同期アクションの完了を処理するコードはコールバックとして定義されます。このコールバックは**ジョブ**を定義し、アクションが完了すると**ジョブキュー**（または HTML 用語ではイベントループ）に配置されます。

毎回、エージェントはキューからジョブを取り出して実行します。ジョブが実行されると、さらに多くのジョブが作成され、キューの最後に追加される場合があります。ジョブは、タイマー、I/O、イベントなどの非同期プラットフォームメカニズムの完了によっても追加できます。ジョブは[スタック](#スタックと実行コンテキスト)が空になると完了したと見なされ、次にキューから次のジョブが取り出されます。ジョブは均一な優先度で取り出されるとは限りません。たとえば、HTML イベントループはジョブを*タスク*と*マイクロタスク*の 2 つのカテゴリに分割します。マイクロタスクは優先度が高く、タスクキューが取り出される前にマイクロタスクキューが最初に空にされます。詳細については、[HTML マイクロタスクガイド](https://developer.mozilla.org/ja/docs/Web/API/HTML_DOM_API/Microtask_guide)を確認してください。ジョブキューが空の場合、エージェントはさらにジョブが追加されるのを待ちます。

### 「実行から完了まで」

各ジョブは、他のジョブが処理される前に完全に処理されます。これは、プログラムについて推論する際にいくつかの優れたプロパティを提供します。これには、関数が実行されるときはいつでも、プリエンプトされることなく、他のコードが実行される前に（そして関数が操作するデータを変更できる）完全に実行されるという事実が含まれます。これは、たとえば C とは異なります。C では、関数がスレッドで実行される場合、ランタイムシステムによっていつでも停止されて、別のスレッドで別のコードを実行する可能性があります。

このモデルの欠点は、ジョブの完了に時間がかかりすぎると、Web アプリケーションがクリックやスクロールなどのユーザーインタラクションを処理できなくなることです。ブラウザはこれを「スクリプトの実行に時間がかかりすぎています」というダイアログで軽減します。従うべき良い習慣は、ジョブ処理を短くし、可能であれば 1 つのジョブをいくつかのジョブに分割することです。

### 決してブロックしない

イベントループモデルによって提供されるもう 1 つの重要な保証は、JavaScript の実行が決してブロックされないことです。[IndexedDB](https://developer.mozilla.org/ja/docs/Web/API/IndexedDB_API) クエリの返却や [`fetch()`](https://developer.mozilla.org/ja/docs/Web/API/Window/fetch) リクエストの返却を待っている間でも、ユーザー入力などの他の処理を実行できます。非同期アクションの完了後に実行されるコードは、常にコールバック関数として提供されます（たとえば、Promise の [`then()`](https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Promise/then) ハンドラー、`setTimeout()` のコールバック関数、またはイベントハンドラー）。これにより、アクションが完了するとジョブキューに追加されるジョブが定義されます。

もちろん、「決してブロックしない」という保証には、プラットフォーム API が本質的に非同期であることが必要ですが、`alert()` や同期 XHR のようないくつかのレガシーな例外が存在します。アプリケーションの応答性を確保するために、これらを避けるのが良い習慣と考えられています。

## エージェントクラスターとメモリ共有

複数のエージェントは、メモリ共有を介して通信し、**エージェントクラスター**を形成できます。エージェントは、メモリを共有できる場合にのみ同じクラスター内にあります。2 つのエージェントクラスターが情報を交換するための組み込みメカニズムはないため、完全に分離された実行モデルと見なすことができます。

エージェントを作成する場合（ワーカーを生成するなど）、現在のエージェントと同じクラスターにあるか、新しいクラスターが作成されるかについていくつかの基準があります。

### エージェント間の通信とメモリモデル

前述のように、エージェントはメモリ共有を介して通信します。Web では、メモリは [`postMessage()`](https://developer.mozilla.org/ja/docs/Web/API/Window/postMessage) メソッドを介して共有されます。通常、データは値渡しのみで行われ（[構造化クローン](https://developer.mozilla.org/ja/docs/Web/API/Web_Workers_API/Structured_clone_algorithm)経由）、したがって並行性の問題は発生しません。メモリを共有するには、[`SharedArrayBuffer`](https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/SharedArrayBuffer) オブジェクトをポストする必要があります。これは複数のエージェントから同時にアクセスできます。2 つのエージェントが `SharedArrayBuffer` を介して同じメモリへのアクセスを共有すると、[`Atomics`](https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Atomics) オブジェクトを介して実行を同期できます。

共有メモリにアクセスするには、通常のメモリアクセス（アトミックではない）とアトミックメモリアクセスの 2 つの方法があります。後者は[逐次一貫性](https://ja.wikipedia.org/wiki/逐次一貫性)があります（つまり、クラスター内のすべてのエージェントによって合意されたイベントの厳密な全順序が存在します）。一方、前者は順序付けられていません（つまり、順序付けは存在しません）。JavaScript は他の順序付け保証を持つ操作を提供しません。

### 並行性と進行の確保

複数のエージェントが連携する場合、[決してブロックしない](#決してブロックしない)という保証は必ずしも成り立ちません。エージェントは、別のアージェントが何らかのアクションを実行するのを待っている間、*ブロック*されたり、一時停止したりすることがあります。これは、同じエージェントで Promise を待つのとは異なります。なぜなら、エージェント全体を停止させ、その間に他のコードの実行を許可しないからです。つまり、*進行*できません。

デッドロックを防ぐために、いつ、どのアージェントがブロックできるかについて、いくつかの厳しい制限があります。

* 専用の実行スレッドを持つすべてのブロックされていないエージェントは、最終的に進行します。
* 実行スレッドを共有するエージェントのセットでは、最終的に 1 つのエージェントが進行します。
* エージェントは、ブロッキングを提供する明示的な API を介して以外に、別のアージェントをブロックさせることはありません。
* 特定のエージェントのみがブロックできます。Web では、これには専用ワーカーと共有ワーカーが含まれますが、類似オリジンのウィンドウやサービスワーカーは含まれません。

エージェントクラスターは、外部の一時停止や終了の場合に、そのエージェントの活動性に対してある程度の完全性を保証します。
