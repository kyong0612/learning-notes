# Reactコンポーネントが「純粋である」とはどういうことか？　丁寧な解説

ref: <https://zenn.dev/uhyo/articles/react-pure-components>

## Reactコンポーネントの純粋性とは？

Reactにおいてコンポーネントが「純粋」であるべきとされる理由と、その具体的な意味について解説する記事の要約です。

### なぜ純粋であるべきか？

- **予測可能性の向上:** 純粋なコンポーネントは、同じ入力に対して常に同じ出力を返すため、動作が予測しやすくなります。
- **最適化の恩恵:** React Compilerなどの最適化は、コンポーネントが純粋であることを前提としています。純粋でない場合、意図しない挙動やバグの原因となります。
- **互換性と保守性:** Reactの新機能との互換性が保たれ、アップデートによる破壊的変更の影響を受けにくくなります。また、コードの可読性や保守性も向上します。

### 純粋性の定義

コンピュータサイエンス、特に関数型プログラミングにおける「純関数」の概念に基づいています。

1. **自分の仕事に集中する:** 呼び出される前に存在していたオブジェクトや変数を変更しません。
2. **同じ入力には同じ出力:** 同じ入力を与えると、純関数は常に同じ結果（JSX）を返します。

Reactのレンダリングプロセス自体も純粋である必要があり、コンポーネントはJSXを返すだけで、既存のオブジェクトや変数を変更してはいけません。

### 「純粋性」の解釈の柔軟性

- 一般的な純粋関数の定義（副作用を含まない、参照透過性を持つ）を基本としつつも、Reactの文脈でその定義を調整することの重要性が指摘されています。
- Reactコンポーネントが純粋であることのメリット（Suspense、Concurrent Rendering、React Compilerによる最適化など）を享受するために必要な条件を満たすように定義を考えるべきです。

### 副作用の例（避けるべきパターン）

副作用とは、関数の外部に対して影響を与えることです。Reactコンポーネントのレンダリング処理中に以下のような副作用を含んではいけません。

1. **コンポーネント外部の変数への書き込み:**

    ```javascript
    let renderCount = 0;
    const Counter = () => {
      renderCount++; // NG: 外部変数を変更
      return <div>{renderCount}</div>;
    };
    ```

2. **コンポーネント外部からのデータの読み取り（localStorageなど）:**

    ```javascript
    const UserInfo = () => {
      const userId = localStorage.getItem("userId"); // NG: 外部の状態に依存
      return <p>ユーザーID: {userId}</p>;
    };
    ```

3. **同じ入力でも結果が変わる処理（`Math.random()`など）:**

    ```javascript
    const Lottery = () => {
      if (Math.random() < 0.1) { // NG: 実行ごとに結果が変わる可能性
        return <p>当たり！</p>;
      } else {
        return <p>外れ</p>;
      }
    };
    ```

4. **ログ出力（`console.log`など）:** デバッグ目的以外では避けるべきです。
5. **ネットワークリクエスト:** レンダリング中に直接実行するべきではありません。

### 「同じ」とはどういうことか？

- Reactコンポーネントが返すJSXはオブジェクトであるため、`===`演算子での比較は意味を持ちません。
- ここでいう「同じ」とは、「**意味が同じ**」ということです。JSXはReactランタイムへの指示書であり、同じ指示を出すJSXを返せば純粋とみなされます。

### 副作用を書いても良い場所

- **イベントハンドラ:** ボタンクリック時などに実行される関数です。これらはレンダリング中に実行されるわけではないため、純粋である必要はなく、副作用（API呼び出しなど）を含んでも問題ありません。
  - イベントハンドラ自体が毎回新しい関数オブジェクトとして生成されても、その「意味」が同じであればコンポーネントの純粋性は保たれます。
- **`useEffect`フック:** コンポーネントのマウント後や更新後に副作用を実行するために使われます。`useEffect`のコールバック関数内のコードは、レンダリング処理の直接的な一部ではないため、副作用を含めることができます。

### 最適化のための「本当に同じ」

- `useMemo`や`useCallback`は、オブジェクトや関数を「本当に同じ」（`===`で比較してtrueになる）にするために使われます。これはReactのルールを守るためではなく、パフォーマンス最適化のためです。
- React Compilerは、これらのフックを自動的に適用し、最適化を行なってくれることが期待されています。

### 例外の扱い

- Reactコンポーネントがレンダリング中に例外を発生させることは許容されています。これは「レンダリングの失敗」として扱われ、Error Boundaryなどで捕捉できます。
- 例外が発生するとコンポーネントの出力が得られないため、その時点で純粋性を議論する意味は薄れます。

### 純粋性とフック

- **フックの返り値は入力として扱う:** `useState`などのフックの呼び出し自体は、関数型プログラミングの観点からは副作用に見えるかもしれませんが、Reactの文脈では純粋性を損なうものではありません。フックの返り値は、コンポーネントへの「入力」の一部として扱われます。

    ```javascript
    const Counter = ({ unit }) => { // unit は props (入力)
      const [count, setCount] = useState(0); // count, setCount も入力として扱う
      return (
        <div>
          <p>カウント: {count} {unit}</p>
          <button type="button" onClick={() => setCount(count + 1)}>
            インクリメント
          </button>
        </div>
      );
    };
    ```

- **フックの本質:** コンポーネントに記憶領域を提供することです。入力とは、propsおよび「コンポーネントの記憶領域のある時点でのスナップショット」と言えます。
- **フック内の副作用:**
  - `useMemo`のコールバック関数: レンダリング計算の一部なので副作用はNG。
  - `useEffect`のコールバック関数: レンダリング計算後なので副作用はOK（ただし、正しい使い方をすることが重要）。

### まとめ

- Reactコンポーネントは、**同じ入力（props + フックの返り値）に対して、常に意味が同じ出力（JSX）を返す**必要があります。
- これは、コンポーネントの**レンダリング計算**に副作用が含まれないことを意味します。
- イベントハンドラや`useEffect`など、レンダリング計算の外部では副作用を記述できます。

この記事は、Reactコンポーネントの純粋性について、様々な角度から丁寧に解説し、読者の理解を深めることを目指しています。
