---
title: "タイミーの1,200万超ユーザーを支える認証基盤を Go と Ory Hydra で作っている話"
source: "https://zenn.dev/7riatsu/articles/e2fbba2c65904d"
author:
  - "Atsuki Narita"
published: 2025-12-21
created: 2025-12-24
description: |
  タイミーCTO室が開発するWorker IdP（Identity Provider）について、Ory Hydraを採用した理由、GoとReact Router v7による実装、1,200万人規模のデータ移行における品質保証の仕組みを紹介。OAuth2/OIDC準拠の認証基盤をゼロから構築し、既存システムからの段階的移行を安全に進めるための設計判断と実装詳細を解説。
tags:
  - "Go"
  - "アーキテクチャ"
  - "認証"
  - "OAuth 2"
  - "OIDC"
  - "Ory Hydra"
  - "React Router"
  - "認証基盤"
---

## はじめに

タイミーは1,200万人以上のワーカーに利用されているサービスです。現在、CTO室ではWorker IdP（Identity Provider）という認証基盤をゼロから作り直しています。

Worker IdPは、タイミーで働くワーカー（エンドユーザー）向けの認証基盤で、セキュリティ強化や今後の事業展開を見据えた認証基盤を構築することを目的としています。既存システムから認証・ID管理を独立した基盤として切り出し、OAuth2/OpenID Connectに準拠した設計とすることで、将来の拡張性も確保しています。

## システム概要

Worker IdPは、タイミーのRP（Relying Party）に対してOAuth2/OIDCによる認証機能を提供します。

OAuth2/OIDCのフローでは、Timee AppがAuthorization RequestをWorker IdPに送信し、Timee BackendがToken Requestを通じてID Tokenを取得します。

システム構成としては、「Worker IdP（認証基盤本体）」と「データ整合性チェッカー」の2つで構成されています。

### Worker IdP（認証基盤本体）

Worker IdPは、Ory Hydra・idm-backend・idm-frontendの3つのコンポーネントをモノレポで管理しています。

- **Ory Hydra**: OAuth2/OIDC認可サーバー。トークンの発行・管理を担当
- **idm-backend（Go）**: 認証ロジック・ユーザー管理を担当
- **idm-frontend（React Router v7）**: ログイン画面の提供とBFF（Backend For Frontend）層を担当

Hydraは認可サーバーに特化しており、認証処理はidm-backendに委譲する設計としています。これにより、認証ロジックは自由に実装しつつ、OAuth2/OIDCの複雑なプロトコル実装はHydraに任せられます。

### データ整合性チェッカー

既存システムからの段階的移行を安全に進めるため、データ整合性チェッカーを独立したシステムとして構築しています。

## Ory Hydra の採用

### なぜ Ory Hydra を選んだか

Ory Hydraは、OAuth2およびOpenID Connectに準拠したOSSの認可サーバーです。UIや認証ロジックを提供せず、それらは別アプリケーションとして実装する設計思想を持ちます。

Hydra採用の決め手は以下の3点です。

### 1. プロトコル準拠の担保

OAuth2/OIDCの仕様は複雑で、セキュリティ上のエッジケースも多く存在します。自前実装ではRFCへの準拠やセキュリティ対応の継続的な追従が大きな負担となります。HydraはOpenID Connect Certificationを取得しており、プロトコル準拠の品質が担保されています。

### 2. 認証ロジックの自由度

認証・認可・ユーザー管理などを一括提供するフルスタックなソリューションは多機能ですが、認証ロジックを製品の枠組み内で実装する必要があります。Hydraは認可機能のみに特化し、認証ロジックは完全に外部化されているため、SMS認証やパスキーなど、要件に応じた認証方式を自由に実装できます。

### 3. 運用の独立性

Oryが提供する各種OSS（Hydra, Kratos, Ketoなど）は独立しており、必要な機能だけを選んで組み合わせられます。認証機能は自前実装したかったため、認可サーバー単体で利用できるHydraは我々のニーズに合致しました。

### 技術選定時の懸念事項

Hydra採用にあたり、以下の点も検討しました。

#### 拡張仕様のサポート状況

FAPI（Financial-grade API）やOAuth2.1で求められる拡張仕様のうち、以下は技術選定時点ではHydraでサポートされていませんでした。

- **DPoP**（Demonstrating Proof of Possession）: トークンの所有証明
- **PAR**（Pushed Authorization Requests）: 認可リクエストの事前送信
- **RAR**（Rich Authorization Requests）: 詳細な認可要求の記述
- **CIBA**（Client Initiated Backchannel Authentication）: バックチャネル認証

ただし、サービス特性を踏まえた上で、現時点の要件では必須ではないと判断しました。HydraはPKCEなどのセキュリティ上重要な仕様を十分にサポートしており、我々のユースケースには必要十分な機能が揃っています。

#### カスタマイズの限界

Authorization EndpointやToken EndpointのコアロジックはHydra自身が処理するため、書き換えはできません。認可リクエストへの独自パラメータの追加やID Tokenへの独自Claimsの埋め込みは可能ですが、標準仕様から外れるカスタマイズには限界があります。

我々のユースケースでは、Confidential ClientによるAuthorization Code Flow with PKCEで十分対応できるため、これらの制約は許容範囲と判断しました。

### 認証フローの詳細

Hydraを活用した認証フローを示します。タイミーアプリは1st partyアプリケーションのため、現時点ではユーザー同意画面（Consent）はスキップしています。

認証フローの要点：

1. **認可リクエストとLogin Challenge**: クライアントがHydraに認可リクエストを送信すると、HydraはセッションCookieを確認します。未ログイン（または再認証が必要）の場合、`login_challenge`パラメータ付きでidm-frontendにリダイレクトします。
2. **認証処理**: idm-backendではSMS PIN認証を実装しています。ユーザーは電話番号を入力し、送信されたPINコードを入力して認証を完了します。
3. **Accept Login Request**: 認証成功後、idm-backendはHydra Admin APIを呼び出して認証結果を通知します。
4. **トークン発行**: 認証完了後、HydraはAuthorization Codeを発行します。クライアントはPKCEの`code_verifier`とともにToken EndpointにCodeを送信し、ID Tokenを取得します。

## バックエンド構成（idm-backend）

idm-backendはGoで実装されており、以下の2つの役割を担っています。

1. **idm-frontend向けAPI**: 認証フローを支える内部APIを提供
2. **RP（Relying Party）向けUser API**: Resource Serverとして、ユーザー情報を提供する

### レイヤードアーキテクチャ

idm-backendはレイヤードアーキテクチャを採用しています。

各層の責務：

- **Handler**: HTTPリクエストの受付・レスポンス生成。OpenAPIから自動生成されたインターフェースの実装
- **Usecase**: ユースケース単位のビジネスロジック。トランザクション管理、Domainサービスのオーケストレーション
- **Domain**: ドメインモデルとビジネスルール。Entity、Value Object、Repositoryインターフェース
- **Infrastructure**: 技術的詳細の実装。MySQLアクセス、Hydra API呼び出し、SMS送信

### スキーマ駆動開発

API仕様はOpenAPIで定義し、そこからバックエンド・フロントエンド双方のコードを自動生成しています。

- **バックエンド**: ogenでGoのハンドラーインターフェースとリクエスト/レスポンス型を生成
- **フロントエンド**: TypeScriptのAPIクライアントと型定義を生成
- **DBアクセス**: BobでMySQLスキーマから型安全なクエリビルダーを生成

この開発フローにより、API仕様の変更がコンパイルエラーとして即座に検出され、ドキュメントとコードの乖離を防げます。E2Eテストにはrunnを採用し、yamlでシナリオを記述しています。DBマイグレーションにはgolang-migrate/migrateを使用しています。

## フロントエンド構成（idm-frontend）

### React Router v7 の採用理由

idm-frontendはReact Router v7で構築したSSRアプリケーションです。

SPAではなくSSRを選択した理由：

1. **API・トークンの隠蔽**: idm-backendとのAPI通信やトークン管理をブラウザに露出させず、サーバーサイドに隠蔽したい
2. **APIのゲートウェイ化**: SPAから直接idm-backendを呼び出すとPublic APIとして公開する必要があり、本質的でないセキュリティ対策が増える。BFFを前段のゲートウェイとして機能させることで、これを回避したい
3. **OP画面専用のセッション管理**: OIDCのSession Managementとは別に、OP（OpenID Provider）画面でのセッション管理が必要

フレームワーク選定ではNext.jsも検討しましたが、App Routerの複雑さや、認証画面という限定的な用途には機能過多であると判断しました。React Router v7はLoader/Actionによる明快なデータフローを持ち、SSRに必要な機能が過不足なく揃っています。

### ECS へのデプロイ

VercelではなくECSを選択した理由は2つあります。

#### 同一オリジン制約

OAuth2/OIDCフローにおいて、Hydraとidm-frontendは密に連携しますが、これらを別ドメイン（VercelとECSなど）に分散させると、ブラウザのSameSite制約等によりCookieの挙動が不透明になり、認可エラーの調査やデバッグが極めて困難になります。

そのため、「認証・認可基盤としての整合性を担保し、外部からは単一のシステムとして隠蔽する」というポリシーに基づき、同一ドメインでの運用を選択しました。ALBのパスベースルーティングを用いて同一オリジンに集約することで、将来的にHydra側のエンドポイントでIdM側のCookieを参照・活用する（あるいはその逆）といった要件にも柔軟に対応できる構成としています。

#### インフラの一元管理

認証基盤という重要なシステムを外部のマネージドサービスに預けると、システム連携が複雑化し、障害時の切り分けも難しくなります。Hydra・idm-backend・idm-frontendを同一のECSクラスタに配置することで、インフラ構成をシンプルに保ち、運用負荷を抑えています。

### アーキテクチャ

フロントエンドもレイヤードアーキテクチャを採用し、Controller層（routes）、Usecase層、Domain層、Client層の4層構造としています。バックエンドと同じOpenAPI定義から型を生成し、型安全なAPI通信を実現しています。

主要な技術スタック：

- **フレームワーク**: React 19 + React Router v7 + TypeScript
- **スタイリング**: Tailwind CSS
- **フォーム**: Conform + Zod
- **エラーハンドリング**: neverthrow（Result型）
- **セッション管理**: DynamoDB + HTTPOnly Cookie

## データ整合性チェッカーの詳細

### データ整合性チェッカーの必要性

Worker IdPへの移行は、以下のフェーズで段階的に進めています。

1. **ダブル Write**: 既存システムからの書き込みをTimee DBとIdP DBの両方に反映
2. **Read切り替え**: 読み取り先をIdP DBに段階的に移行
3. **Write切り替え**: 書き込み元をWorker IdPに完全移行
4. **疎結合化**: 既存システムとWorker IdPの依存関係を解消

現在はダブル Writeフェーズにあり、既存のTimee DBと新規のIdP DBが並行稼働しています。ダブル Writeの同期方式として、トランザクションの完全性を保証する方式ではなく、結果整合性を許容する方式を採用しました。これはシステムの複雑性やパフォーマンスへの影響を考慮した判断ですが、同期のタイムラグや障害時にデータ不整合が発生するリスクがあります。

1,200万人を超えるユーザーデータを扱うシステムで、移行期間中にデータ不整合が発生すると、認証エラーやアカウント情報の不一致など、ユーザー体験に深刻な影響を与える可能性があります。

タイミー特有の事情として以下の課題がありました：

- **既存DBの制約が不十分**: 一部のテーブルでリレーションや制約が適切に設定されておらず、データ品質にばらつきがあった
- **スキーマの再設計**: 上記の問題を解消するため、IdP DBでは既存DBとは異なるテーブル設計を採用
- **単純移行が不可能**: DB間でスキーマが異なるため、単純なデータコピーでは移行できず、アプリケーションロジック上の整合性を保証する仕組みが必要

そのため、両データベース間の整合性を継続的に監視・検証するツールを構築しました。

### データ整合性を担保する 2 つのツール

データ整合性チェッカーは、以下の2つのツールで構成されています。

#### 1. checker（データ比較ツール）

両データベースのユーザーデータを比較し、差分を検出・通知します。

- **定期実行モード**: 直近更新されたユーザーを対象に、許容誤差を設けて比較
- **全件チェックモード**: 全ユーザーを対象に、厳密な一致確認

タイムスタンプ比較では、データ移行やレプリケーション遅延を考慮した許容誤差の設定が可能です。

#### 2. imported_data_validator（データ検証ツール）

移行後のIdP DBデータが、アプリケーションのビジネスルール（電話番号の形式、必須フィールドの存在など）を満たしているかを検証します。

### 共通ドメインモデルによる比較

Timee DBとIdP DBはスキーマが異なるため、中立的な共通ドメインモデルを定義し、各データベースから取得したデータをこのモデルに変換してから比較します。

この設計により、比較ロジックがデータベース固有の詳細から分離され、新しい比較ルールの追加やスキーマ変更への対応が容易になります。

### モニタリング

差分検出時はSentryにIssueとして通知され、フィールドやエラータイプでの検索・集計が可能です。実行ログはDatadog Logsに集約し、処理進捗やパフォーマンスを可視化しています。

## まとめ

本記事では、Worker IdPの技術選定とアーキテクチャを紹介しました。

- **Ory Hydra**を採用し、プロトコル準拠と認証ロジックの自由度を両立
- **idm-backend（Go）**でレイヤードアーキテクチャとスキーマ駆動開発を実践
- **idm-frontend（React Router v7）**をECSにデプロイし、SSRと同一オリジン制約に対応
- **データ整合性チェッカー**で移行期間中のデータ品質を担保

今後はカナリアリリースを通じて段階的に移行を進め、セキュリティ基盤の強化と将来の事業拡張に備えていく予定です。また、パスキー対応などの認証体験の向上も検討しています。

---

**注意**: 本記事の内容は開発段階のものであり、リリース時には変更される可能性があります。
