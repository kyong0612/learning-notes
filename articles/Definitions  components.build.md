---
title: "Definitions | components.build"
source: "https://www.components.build/definitions"
author:
  - "[[@vercel]]"
published:
created: 2025-10-18
description: "UIコンポーネント構築のための包括的な用語集。Primitive、Component、Block、Template、Patternなどのアーティファクト分類、APIとコンポジション、スタイリング、アクセシビリティ、配布方法に関する正確な定義を提供します。フレームワークに依存しない用語定義ですが、例はReactで示されています。"
tags:
  - "ui-components"
  - "design-system"
  - "accessibility"
  - "web-development"
  - "component-architecture"
  - "primitives"
---

## 概要

components.buildは、モダンで構成可能かつアクセシブルなUIコンポーネントを構築するためのオープンソース標準です。このページでは、仕様全体で使用される正確な用語を確立します。

## 1. アーティファクト分類

### 1.1 Primitive（プリミティブ）

**最低レベルの構成要素**で、スタイリングなしで動作とアクセシビリティを提供します。

**特徴:**

- 完全にヘッドレス（スタイルなし）
- セマンティクス、フォーカス管理、キーボード操作、レイヤリング、ARIA配線などをカプセル化
- 動作の基盤を提供するが、完成したUIにはスタイリングが必要

**例:**

- Radix UI Primitives（Dialog、Popover、Tooltipなど）
- React Aria Components
- Base UI
- Headless UI

**期待事項:**

- 完全にスタイルなし
- 単一責任の原則、スタイル付きコンポーネントに組み込み可能
- ロールに対する包括的なa11y動作を提供
- 安定性を優先したバージョニング

### 1.2 Component（コンポーネント）

**スタイル付きの再利用可能なUIユニット**で、プリミティブに視覚的デザインを追加するか、複数の要素を組み合わせて完全で機能的なインターフェース要素を作成します。

**特徴:**

- 比較的低レベルだがスタイリングを含む
- アプリケーションですぐに使用可能
- カスタマイズ可能

**例:**

- shadcn/ui components（Radixプリミティブのスタイル付きラッパー）
- Material UI components
- Ant Design components

**期待事項:**

- 明確なProps API、制御・非制御の使用をサポート
- デフォルトスタイリングを含むがオーバーライド可能
- 完全なキーボードアクセシビリティとスクリーンリーダー対応
- 組み合わせ可能（children/slots、render props、compound subcomponents）

### 1.3 Pattern（パターン）

特定のUI/UX問題を解決するための、**プリミティブまたはコンポーネントの特定の組み合わせ**です。

**例:**

- インラインエラー付きフォームバリデーション
- 破壊的アクションの確認
- 先行入力検索
- オプティミスティックUI

**期待事項:**

- 動作、a11y、キーボードマップ、失敗モードを記述
- 複数のフレームワークでの参照実装を含む可能性

### 1.4 Block（ブロック）

**コンテンツの足場を持つ、具体的なインターフェースユースケースを解決する、本番環境対応の意見の強いコンポーネント構成**です。汎用性よりも採用速度を優先します。

**例:**

- 価格表
- 認証画面
- オンボーディングステッパー
- AIチャットパネル
- 請求設定フォーム

**期待事項:**

- 強力なデフォルト、コピー＆ペーストに適している
- レイアウトとオーケストレーション以外の最小限のロジック
- Propsを介してデータを受け入れる

> ブロックは通常、コンポーネントのように再利用可能ではありません。インポートするのではなく、コンポーネントやプリミティブをインポートします。これにより、レジストリ配布方法の良い候補となります。

### 1.5 Page（ページ）

**特定のユーザー向け目的を果たすために配置された複数のブロックで構成される、完全な単一ルートビュー**です。

**例:**

- ランディングページ（ヒーローブロック + 機能ブロック + 価格ブロック + フッターブロック）
- 製品詳細ページ（画像ギャラリーブロック + 製品情報ブロック + レビューブロック）
- ダッシュボードページ（統計ブロック + チャートブロック + アクティビティフィードブロック）

**期待事項:**

- 単一ルートの統一されたレイアウトに複数のブロックを組み合わせる
- コンポーネントレベルの詳細ではなく、レイアウトとブロックオーケストレーションに焦点
- ブロック間のデータ調整のためのページ固有のロジックを含む可能性

### 1.6 Template（テンプレート）

**ページ、ルーティング設定、共有レイアウト、グローバルプロバイダー、プロジェクト構造をバンドルした、複数ページのコレクションまたは完全なサイトの足場**です。

**例:**

- TailwindCSS Templates
- shadcnblocks Templates
- "SaaSスターター"（認証ページ + ダッシュボードページ + 設定ページ + マーケティングページ）
- "Eコマーステンプレート"

**期待事項:**

- ルーティング/ナビゲーション構造を持つ複数のページを含む
- グローバル設定を提供
- 明確な規約を持つ意見の強いプロジェクト構造
- 包括的な出発点として設計

### 1.7 Utility（ユーティリティ - 非視覚的）

開発者の人間工学または構成のためにエクスポートされる**ヘルパー**で、レンダリングされるUIではありません。

**例:**

- Reactフック（useControllableState、useId）
- クラスユーティリティ
- キーバインディングヘルパー
- フォーカススコープ

**期待事項:**

- 副作用なし（明示的に文書化されている場合を除く）
- 独立してテスト可能、ツリーシェイキングをサポート

## 2. APIとコンポジションの語彙

### 2.1 Props API

コンポーネントの**公開設定サーフェス**です。Propsは安定しており、型付けされ、デフォルトとa11yへの影響とともに文書化されています。

### 2.2 Children / Slots（子要素/スロット）

呼び出し元が提供する構造またはコンテンツのプレースホルダーです。

- **Children（暗黙的スロット）**: 開始タグと終了タグの間のJSX
- **Named slots（名前付きスロット）**: `icon`、`footer`などのProps、または`<Component.Slot>`サブコンポーネント
- **Slot forwarding（スロット転送）**: 基礎となる要素にDOM属性/className/refsを渡す

### 2.3 Render Prop（関数としての子）

親が状態/データを提供しながら、レンダリングを委譲するために使用される関数子です。

```jsx
<ParentComponent data={data}>
  {(item) => (
    <ChildComponent key={item.id} {...item} />
  )}
</ParentComponent>
```

親がデータ/動作を所有する必要があるが、消費者がマークアップを完全に制御する必要がある場合に使用します。

### 2.4 Controlled vs. Uncontrolled（制御 vs. 非制御）

**Controlled**コンポーネントは、Propsによって値が駆動され、通常`onChange`イベントを発行します（真実の源は親）。**Uncontrolled**コンポーネントは内部状態を保持し、`defaultValue`と命令的なリセットを公開する場合があります。

多くの入力は両方をサポートする必要があります。

### 2.5 Provider / Context（プロバイダー/コンテキスト）

サブツリーに共有状態/設定を提供する**トップレベルコンポーネント**（例：テーマ、ロケール、アクティブなタブID）です。

### 2.6 Portal

レイヤリング/スタッキングコンテキストを管理するために、DOM階層外にUIをレンダリングします（例：モーダル、ポップオーバー、トースト）が、a11yを維持します。

## 3. スタイリングとテーマの語彙

### 3.1 Headless（ヘッドレス）

外観を規定せずに動作とアクセシビリティを実装します。消費者がスタイリングを提供する必要があります。

### 3.2 Styled（スタイル付き）

デフォルトの視覚デザイン（CSSクラス、インラインスタイル、またはトークン）を提供しますが、オーバーライド可能です。

### 3.3 Variants（バリアント）

Propsを介して公開される、個別の文書化されたスタイルまたは動作の変化（例：`size="sm|md|lg"`、`tone="neutral|destructive"`）です。

### 3.4 Design Tokens（デザイントークン）

視覚デザインをパラメータ化し、テーマをサポートする、**名前付きのプラットフォームに依存しない値**（例：`--color-bg`、`--radius-md`、`--space-2`）です。

## 4. アクセシビリティの語彙

### 4.1 Role / State / Property（ロール/状態/プロパティ）

セマンティクス（`role="menu"`）、状態（`aria-checked`）、関係（`aria-controls`、`aria-labelledby`）を伝えるWAI-ARIA属性です。

### 4.2 Keyboard Map（キーボードマップ）

ウィジェットのキーボード操作の文書化されたセット（例：`Tab`、`矢印キー`、`Home/End`、`Escape`）です。すべてのインタラクティブコンポーネントはキーボードマップを宣言し実装します。

### 4.3 Focus Management（フォーカス管理）

初期フォーカス、ローミングフォーカス、フォーカストラップ、破棄時のフォーカス復帰のルールです。

## 5. 配布の語彙

### 5.1 Package（パッケージ - レジストリ配布）

コンポーネント/ライブラリがパッケージレジストリ（例：`npm`）に公開され、バンドラーを介してインポートされます。バージョン管理された更新と依存関係管理を優先します。

### 5.2 Copy-and-Paste（コピー＆ペースト - ソース配布）

ソースコードが消費者のリポジトリに直接統合されます（多くの場合CLIを介して）。所有権、カスタマイズ、ゼロの余分なランタイムを優先します。

### 5.3 Registry（レジストリ - カタログ）

メタデータ、プレビュー、インストール/コピー手順を持つ、アーティファクト（プリミティブ、コンポーネント、ブロック、テンプレート）の**キュレートされたインデックス**です。

## 6. 分類ヒューリスティック

アーティファクトの命名と配置には、次の決定フローを使用します:

1. スタイリングなしで単一の動作またはa11yの懸念をカプセル化していますか？ → **Primitive**
2. プリミティブに視覚デザインを追加するか、複数の要素を組み合わせたスタイル付きの再利用可能なUI要素ですか？ → **Component**
3. 意見の強い構成とコピーを持つ具体的な製品ユースケースを解決していますか？ → **Block**
4. ルーティング/プロバイダーと交換可能な領域を持つページ/フローを足場していますか？ → **Template**
5. 実装に依存しない、繰り返し発生するソリューションの文書ですか？ → **Pattern**
6. 人間工学/構成のための非視覚的ロジックですか？ → **Utility**

## 7. 非目標と明確化

- **Web Components vs. "Components"**: この仕様では、「コンポーネント」は再利用可能なUIユニット（Reactの例）を指します。明示的に述べられていない限り、HTML Custom Elements標準を意味しません。
- **Widgets**: 「widget」という用語は曖昧さのため避けられています。component（一般）またはpattern（文書のみのソリューション）を使用してください。
- **Themes vs. Styles**: テーマはスタイルのパラメータ化（トークンを介して）です。スタイルは具体的なプレゼンテーションです。コンポーネントはテーマをサポートする必要があり、ブロック/テンプレートは意見の強いスタイルとテーマフックを提供する場合があります。

## 重要なポイント

1. **階層的な分類**: Primitive → Component → Block → Page → Templateという明確な階層があり、それぞれが異なるレベルの抽象化と再利用性を持ちます。

2. **アクセシビリティファースト**: すべてのレベルでアクセシビリティが重視され、特にPrimitiveレベルで包括的なa11y動作が提供されます。

3. **柔軟性と制御**: ヘッドレス（Primitive）からスタイル付き（Component）まで、開発者に必要な制御レベルを選択できます。

4. **配布の選択肢**: npm経由のパッケージ配布とコピー＆ペーストのソース配布の両方をサポートし、異なるニーズに対応します。

5. **フレームワーク非依存**: 用語はフレームワークに依存しませんが、実用性のためReactで例示されています。
