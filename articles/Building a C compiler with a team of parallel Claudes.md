---
title: "Building a C compiler with a team of parallel Claudes"
source: "https://www.anthropic.com/engineering/building-c-compiler"
author:
  - "[[Nicholas Carlini]]"
published: 2026-02-05
created: 2026-02-07
description: "Anthropicの研究者が16の並列Claudeエージェントチームを使い、約2,000セッション・$20,000のコストで10万行のRust製Cコンパイラを自律的に構築。Linux 6.9のコンパイルに成功した実験から得られた、自律型エージェントチーム設計の知見と課題をまとめた技術レポート。"
tags:
  - "clippings"
  - "AI"
  - "LLM"
  - "Claude"
  - "Compiler"
  - "Autonomous-Agent"
  - "Rust"
  - "Parallel-Processing"
---

## 概要

Anthropicの研究者Nicholas Carliniが、「エージェントチーム」という新しいアプローチを用いて、16の並列Claudeインスタンス（Opus 4.6）にRust製Cコンパイラをゼロから構築させた実験レポート。約2,000のClaude Codeセッション、$20,000のAPIコストを費やし、10万行のコンパイラが完成。このコンパイラはLinux 6.9をx86、ARM、RISC-Vでコンパイル可能であり、GCC torture test suiteで99%のパス率を達成した。

記事の焦点は、コンパイラそのものよりも、**長時間自律的に動作するエージェントチームを設計するためのハーネス（テスト環境・制御構造）の知見**にある。

## 主要なトピック

### 長時間実行のClaude（Long-running Claudes）

既存のエージェント（Claude Code）は人間のオペレーターがオンラインで常に対応する必要がある。自律的な継続作業を実現するため、Claudeを**無限ループで実行するシンプルなハーネス**を構築した。

```bash
#!/bin/bash
while true; do
  COMMIT=$(git rev-parse --short=6 HEAD)
  LOGFILE="agent_logs/agent_${COMMIT}.log"
  claude --dangerously-skip-permissions \
    -p "$(cat AGENT_PROMPT.md)" \
    --model claude-opus-X-Y &&>> "$LOGFILE"
done
```

- タスク完了後、即座に次のタスクに取りかかる
- エージェントプロンプトで「問題を小さく分割し、進捗を追跡し、完璧になるまで続ける」よう指示
- コンテナ内で実行することを推奨（安全性のため）
- 注意点：ある時、Claudeが誤って `pkill -9 bash` を実行し、自らループを終了させてしまったケースも発生

### 並列実行（Running Claude in Parallel）

単一エージェントの2つの弱点を解決するために並列実行を導入：

1. **1セッション = 1タスク**の制約：プロジェクト規模が大きくなると非効率
2. **専門化の活用**：メイン課題以外に、ドキュメント維持・コード品質監視・サブタスクなどを担当するエージェントを配置可能

**実装方式（ベアボーン）：**
- ベアgitリポジトリを作成
- 各エージェントごとにDockerコンテナを起動、リポジトリを `/upstream` にマウント
- 各エージェントは `/workspace` にローカルクローンし、作業後にpush

**同期アルゴリズム：**
1. `current_tasks/` ディレクトリにテキストファイルを書くことでタスクの「ロック」を取得（例：`current_tasks/parse_if_statement.txt`）
2. gitの同期機能により、同じタスクへの重複割当を防止
3. 作業完了後、upstream からpull → マージ → push → ロック解除
4. マージコンフリクトは頻繁に発生するが、Claudeは自力で解決

**現時点の制約：**
- エージェント間の通信手段は未実装
- 高レベル目標の管理プロセスなし
- オーケストレーションエージェントなし
- 各Claudeが自律的に「次に最も明白な問題」を選択

### エージェントチームからの教訓

#### 1. 極めて高品質なテストを書く

- Claudeは与えられた問題を自律的に解くため、**タスク検証器（テスト）がほぼ完璧**である必要がある
- 高品質なコンパイラテストスイートの選定、オープンソースソフトウェアのビルドスクリプト作成
- Claudeの失敗パターンを観察し、新しいテストを設計
- 後半では新機能が既存機能を壊す問題が頻発 → **CIパイプラインを構築**し、既存コードの破壊を防止

#### 2. Claudeの立場で考える（Put yourself in Claude's shoes）

テストハーネスは人間ではなくClaudeのために設計する必要がある：

- **コンテキストウィンドウの汚染防止**：テストハーネスは数千バイトの無駄な出力を避け、数行のみ表示。重要情報はログファイルに記録。エラーは `ERROR` + 理由を同一行に出力し `grep` で発見可能に。集計統計を事前計算
- **時間感覚の欠如**：Claudeは時間を把握できないため、放置するとテスト実行に何時間も費やす。インクリメンタルな進捗を低頻度で表示し、`--fast` オプションで1%〜10%のランダムサンプルを実行。サンプルはエージェントごとに決定的だがVM間でランダムとし、カバレッジを維持しつつ回帰テストを効率化
- **オリエンテーション支援**：各エージェントはコンテキストなしで新コンテナに投入されるため、詳細なREADMEと進捗ファイルの頻繁な更新を指示

#### 3. 並列化を容易にする

- 独立した失敗テストが多い場合、並列化は自明（各エージェントが異なるテストを担当）
- テストスイートが99%通過後は、各エージェントが異なるオープンソースプロジェクト（SQLite、Redis、libjpeg、QuickJS、Luaなど）のコンパイルを担当
- **Linuxカーネルコンパイルでの課題**：1つの巨大タスクのため、全エージェントが同じバグにぶつかり互いの変更を上書き → 16エージェントが無意味に
- **解決策**：GCCを「既知の正しいコンパイラオラクル」として使用。ランダムにほとんどのファイルをGCCでコンパイルし、残りをClaudeのコンパイラで処理。失敗時はGCCでの再コンパイルで問題ファイルを特定 → 各エージェントが異なるファイルの異なるバグを並列修正
- さらにデルタデバッギング手法で、個別には動作するが組み合わせると失敗するファイルペアを発見

#### 4. 複数のエージェントロール

専門化されたエージェントの配置例：
- **重複コード統合**エージェント：LLMが既存機能を再実装しがちな問題に対処
- **パフォーマンス改善**エージェント：コンパイラ自体の実行速度向上
- **出力コード効率化**エージェント：生成されるコンパイル済みコードの最適化
- **Rust設計批評**エージェント：Rust開発者の視点でプロジェクト構造を改善
- **ドキュメント**エージェント

## 重要な事実・データ

- **エージェント数**: 16の並列Claudeインスタンス
- **セッション数**: 約2,000のClaude Codeセッション
- **開発期間**: 約2週間
- **総コスト**: 約$20,000（入力トークン20億、出力トークン1.4億）
- **コード規模**: 10万行のRustコード
- **依存関係**: Rust標準ライブラリのみ（クリーンルーム実装、インターネットアクセスなし）
- **対応アーキテクチャ**: x86、ARM、RISC-V
- **コンパイル可能なプロジェクト**: Linux 6.9、QEMU、FFmpeg、SQLite、PostgreSQL、Redis、Doom
- **テストパス率**: GCC torture test suiteを含む主要テストスイートで99%
- **モデル**: Claude Opus 4シリーズ（Opus 4.5で初めて機能的なコンパイラが実現、Opus 4.6で大規模プロジェクトのコンパイルが可能に）

## 結論・示唆

### 著者の結論

エージェントチームは、複雑なプロジェクト全体の自律的実装の可能性を示した。言語モデルの各世代が新しい作業方法を開拓してきた歴史（タブ補完 → 関数本体生成 → ペアプログラミング → エージェントチーム）の延長線上にある。

### 実践的な示唆

- **テスト設計が最重要**: 自律エージェントの品質はテストハーネスの品質に直結する
- **LMの特性に合わせた環境設計**: コンテキストウィンドウの汚染防止、時間感覚の欠如への対処が不可欠
- **タスク分解と同期**: シンプルなファイルベースのロック機構でも並列化は機能する
- **専門化による効率化**: 異なるロールを持つエージェントの配置が有効
- **オラクル手法**: 既知の正しいツールとの比較で問題を分割・特定する手法が効果的

### リスクと懸念

著者は興奮と同時に不安も表明。主な懸念：
- 人間がリアルタイムで品質を確認できない場合、テスト通過が品質保証を意味しない
- プログラマーが個人的に検証していないソフトウェアをデプロイするリスク
- 2026年初頭でこの水準が達成可能であることへの驚き
- 大量の新しいコードが生成される世界を安全にナビゲートするための新戦略が必要

## 制限事項・注意点

- **16ビットx86コンパイラ未実装**: Linux起動時のリアルモードに必要な16ビットコード生成ができず、GCCに委譲（ARM・RISC-Vでは完全自律）
- **アセンブラ・リンカ未完成**: 自動化を開始したがまだバグが多く、デモはGCCのアセンブラ・リンカを使用
- **すべてのプロジェクトをコンパイルできるわけではない**: 汎用コンパイラの完全な代替にはなっていない
- **生成コードの非効率性**: すべての最適化を有効にしても、GCCの最適化無効時より非効率
- **Rustコード品質**: 合理的だが、エキスパートRustプログラマーの品質には及ばない
- **新機能追加が既存機能を頻繁に壊す**: Opusの能力の限界に近づいている

---

*Source: [Building a C compiler with a team of parallel Claudes](https://www.anthropic.com/engineering/building-c-compiler)*
