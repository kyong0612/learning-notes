---
title: "Using PLANS.md for multi-hour problem solving | OpenAI Cookbook"
source: "https://cookbook.openai.com/articles/codex_exec_plans"
author:
  - "Aaron Friel"
published: "2025-10-07"
created: 2025-11-22
description: "Codexやgpt-5-codexモデルを使用して、研究、設計、実装に長時間を要する複雑なタスクを実装する方法。PLANS.mdという実行計画（ExecPlan）フォーマットを使用することで、エージェントが7時間以上にわたる作業を単一のプロンプトから実行できるようになる。この記事では、AGENTS.mdとPLANS.mdの構造、要件、フォーマット、ガイドラインについて詳細に説明している。"
tags:
  - "clippings"
  - "codex"
  - "gpt-5-codex"
  - "execution-plans"
  - "agents"
  - "planning"
  - "openai-cookbook"
---

# Using PLANS.md for multi-hour problem solving

Codexや`gpt-5-codex`モデルは、研究、設計、実装に長時間を要する複雑なタスクを実装するために使用できます。この記事で説明するアプローチは、モデルにこれらのタスクを実装するようプロンプトし、プロジェクトの成功に向けて導く一つの方法です。

これらの計画は徹底的な設計文書であり、「生きている文書（living documents）」です。Codexのユーザーとして、これらの文書を使用して、Codexが長時間の実装プロセスを開始する前に、Codexが取るアプローチを検証できます。以下に含まれる特定の`PLANS.md`は、Codexが単一のプロンプトから7時間以上作業できるようにしたものと非常に類似しています。

Codexがこれらの文書を使用できるようにするには、まず`AGENTS.md`を更新して`PLANS.md`を使用するタイミングを説明し、次にリポジトリに`PLANS.md`ファイルを追加します。

## AGENTS.md

`AGENTS.md`は、Codexなどのコーディングエージェントを導くためのシンプルなフォーマットです。ユーザーが簡略表現として使用できる用語と、計画文書を使用するタイミングのシンプルなルールを説明します。ここでは「ExecPlan」と呼びます。これは任意の用語であり、Codexはこれについて訓練されていません。この簡略表現は、Codexを特定の計画定義に導くためにプロンプトする際に使用できます。

エージェントに計画を使用するタイミングを指示する`AGENTS.md`セクションの例：

```markdown
# ExecPlans

When writing complex features or significant refactors, use an ExecPlan (as described in .agent/PLANS.md) from design to implementation.
```

## PLANS.md

以下は完全な文書です。この文書内のプロンプトは、ユーザーに大量のフィードバックを提供し、モデルを計画で指定された内容を正確に実装するよう導くために慎重に選択されました。ユーザーは、ニーズに合わせてファイルをカスタマイズしたり、必要なセクションを追加または削除したりすることで利益を得られる可能性があります。

### ExecPlanの概要

実行計画（ExecPlan）は、コーディングエージェントが動作する機能やシステム変更を提供するために従うことができる設計文書です。読者をこのリポジトリの完全な初心者として扱います：彼らは現在の作業ツリーと提供する単一のExecPlanファイルのみを持っています。以前の計画の記憶はなく、外部コンテキストもありません。

### ExecPlanとPLANS.mdの使用方法

実行可能な仕様（ExecPlan）を作成する際は、`PLANS.md`を**文字通り**に従ってください。コンテキストにない場合は、`PLANS.md`ファイル全体を読んで記憶をリフレッシュしてください。正確な仕様を作成するために、ソース資料を徹底的に読む（そして再読する）ことが重要です。仕様を作成する際は、スケルトンから始めて、調査を行いながら肉付けしてください。

実行可能な仕様（ExecPlan）を実装する際は、「次のステップ」についてユーザーにプロンプトしないでください。単に次のマイルストーンに進んでください。すべてのセクションを最新の状態に保ち、停止ポイントごとにリストのエントリを追加または分割して、達成された進捗と次のステップを明確に述べてください。曖昧さを自律的に解決し、頻繁にコミットしてください。

実行可能な仕様（ExecPlan）について議論する際は、仕様のログに決定事項を記録して後世に残してください。仕様への変更が行われた理由が明確である必要があります。ExecPlanは生きている文書であり、ExecPlanのみから、他の作業なしに再開できる必要があります。

困難な要件や重要な未知数がある設計を研究する際は、マイルストーンを使用して、ユーザーの提案が実現可能かどうかを検証できる概念実証、「おもちゃの実装」などを実装してください。ライブラリのソースコードを見つけるか取得して読み、深く研究し、より完全な実装を導くためのプロトタイプを含めてください。

### 要件

**交渉不可の要件**：

* すべてのExecPlanは完全に自己完結している必要があります。自己完結とは、現在の形式で、初心者が成功するために必要なすべての知識と指示が含まれていることを意味します。
* すべてのExecPlanは生きている文書です。貢献者は、進捗が進み、発見が発生し、設計決定が確定するにつれて、それを改訂する必要があります。各改訂は完全に自己完結している必要があります。
* すべてのExecPlanは、このリポジトリの事前知識なしに、完全な初心者が機能をエンドツーエンドで実装できるようにする必要があります。
* すべてのExecPlanは、単に「定義を満たす」ためのコード変更ではなく、実証可能に動作する動作を生成する必要があります。
* すべてのExecPlanは、専門用語のすべての用語を平易な言葉で定義するか、使用しないでください。

目的と意図が最初に来ます。まず、ユーザーの視点から、なぜこの作業が重要かを数文で説明してください：この変更の後、誰かが以前はできなかったことをできるようになること、そしてそれがどのように動作するかを確認する方法です。次に、その結果を達成するための正確なステップを読者に導いてください。編集する内容、実行する内容、観察すべき内容を含めてください。

あなたの計画を実行するエージェントは、ファイルをリストし、ファイルを読み、検索し、プロジェクトを実行し、テストを実行できます。以前のコンテキストを知らず、以前のマイルストーンからあなたが何を意味したかを推測できません。依存する仮定を繰り返してください。外部のブログやドキュメントを指さないでください。知識が必要な場合は、計画自体に独自の言葉で埋め込んでください。ExecPlanが以前のExecPlanに基づいており、そのファイルがチェックインされている場合は、参照によってそれを組み込んでください。そうでない場合は、その計画から関連するすべてのコンテキストを含める必要があります。

### フォーマット

フォーマットとエンベロープはシンプルで厳格です。各ExecPlanは、`md`としてラベル付けされた単一のフェンスされたコードブロックで、トリプルバッククォートで始まり終わる必要があります。内部に追加のトリプルバッククォートコードフェンスをネストしないでください。コマンド、トランスクリプト、差分、またはコードを示す必要がある場合は、その単一のフェンス内でインデントされたブロックとして提示してください。ExecPlanのコードフェンスを早期に閉じるのを避けるために、ExecPlan内のコードフェンスではなく、明確さのためにインデントを使用してください。すべての見出しの後に2つの改行を使用し、#と##などを使用し、順序付きリストと順序なしリストの正しい構文を使用してください。

ファイルの内容が*単一のExecPlanのみ*であるMarkdown（.md）ファイルにExecPlanを書き込む場合、トリプルバッククォートを省略する必要があります。

平易な散文で書いてください。リストよりも文を優先してください。簡潔さが意味を曖昧にする場合を除き、チェックリスト、テーブル、長い列挙を避けてください。チェックリストは、`Progress`セクションでのみ許可され、そこでは必須です。物語のセクションは散文優先のままである必要があります。

### ガイドライン

自己完結性と平易な言葉が最も重要です。「daemon」、「middleware」、「RPC gateway」、「filter graph」など、普通の英語ではないフレーズを導入する場合は、すぐに定義し、このリポジトリでどのように現れるかを読者に思い出させてください（例えば、それが現れるファイルやコマンドに名前を付けることによって）。「以前に定義されたように」や「アーキテクチャドキュメントによると」と言わないでください。必要な説明をここに含めてください。たとえ自分自身を繰り返すことになってもです。

一般的な失敗モードを避けてください。未定義の専門用語に依存しないでください。「機能の文字」を狭く説明して、結果のコードがコンパイルされるが意味のあることを何もしないようにしないでください。重要な決定を読者に委任しないでください。曖昧さが存在する場合、計画自体で解決し、そのパスを選択した理由を説明してください。ユーザーに見える効果を過度に説明し、偶発的な実装の詳細を過少に指定する側に誤りを犯してください。

観察可能な結果で計画を固定してください。実装後にユーザーができること、実行するコマンド、見るべき出力を述べてください。受け入れは、内部属性（「HealthCheck構造体を追加」）ではなく、人間が検証できる動作として表現する必要があります（「サーバーを起動した後、[http://localhost:8080/health](http://localhost:8080/health)に移動すると、HTTP 200と本文OKが返される」）。変更が内部的な場合は、その影響をどのように実証できるかを説明してください（例えば、変更の前後に失敗し、その後通過するテストを実行し、新しい動作を使用するシナリオを示すことによって）。

リポジトリのコンテキストを明示的に指定してください。完全なリポジトリ相対パスでファイルに名前を付け、関数とモジュールを正確に名前を付け、新しいファイルを作成する場所を説明してください。複数の領域に触れる場合、初心者が自信を持ってナビゲートできるように、それらの部分がどのように組み合わされるかを説明する短い方向性の段落を含めてください。コマンドを実行する際は、作業ディレクトリと正確なコマンドラインを示してください。結果が環境に依存する場合、仮定を述べ、合理的な場合は代替案を提供してください。

べき等性と安全性を確保してください。ステップを複数回実行しても損害やドリフトを引き起こさないように書いてください。ステップが途中で失敗する可能性がある場合は、再試行または適応する方法を含めてください。移行や破壊的な操作が必要な場合は、バックアップや安全なフォールバックを明確に述べてください。進めながら検証できる加算的でテスト可能な変更を優先してください。

検証はオプションではありません。テストを実行する指示、該当する場合はシステムを起動する指示、有用なことを行うことを観察する指示を含めてください。新しい機能や機能に対する包括的なテストを説明してください。初心者が成功と失敗を区別できるように、期待される出力とエラーメッセージを含めてください。可能な場合は、コンパイルを超えて変更が効果的であることを証明する方法を示してください（例えば、小さなエンドツーエンドシナリオ、CLI呼び出し、またはHTTPリクエスト/レスポンストランスクリプトを通じて）。プロジェクトのツールチェーンに適した正確なテストコマンドと、その結果を解釈する方法を述べてください。

証拠を捕捉してください。ステップがターミナル出力、短い差分、またはログを生成する場合、それらを単一のフェンスされたブロック内にインデントされた例として含めてください。成功を証明するものに焦点を当てて、それらを簡潔に保ってください。パッチを含める必要がある場合は、大きなブロブを貼り付けるよりも、読者が指示に従って再現できるファイルスコープの差分または小さな抜粋を優先してください。

### マイルストーン

マイルストーンは物語であり、官僚主義ではありません。作業をマイルストーンに分割する場合、各マイルストーンを、スコープ、マイルストーンの終わりに存在するもの、実行するコマンド、観察する受け入れを説明する短い段落で紹介してください。物語として読みやすく保ってください：目標、作業、結果、証明。進捗とマイルストーンは異なります：マイルストーンは物語を語り、進捗は細かい作業を追跡します。両方が存在する必要があります。簡潔さのためにマイルストーンを省略しないでください。将来の実装に重要である可能性のある詳細を省略しないでください。

各マイルストーンは独立して検証可能であり、実行計画の全体的な目標を段階的に実装する必要があります。

### 生きている計画と設計決定

* ExecPlanは生きている文書です。重要な設計決定を行う際は、決定とその背後にある思考の両方を記録するために計画を更新してください。すべての決定を`Decision Log`セクションに記録してください。
* ExecPlanは、`Progress`セクション、`Surprises & Discoveries`セクション、`Decision Log`、および`Outcomes & Retrospective`セクションを含み、維持する必要があります。これらはオプションではありません。
* オプティマイザーの動作、パフォーマンスのトレードオフ、予期しないバグ、またはアプローチを形成した逆/非適用セマンティクスを発見した場合、短い証拠スニペット（テスト出力が理想的）とともに`Surprises & Discoveries`セクションにそれらの観察を捕捉してください。
* 実装の途中でコースを変更する場合は、`Decision Log`に理由を文書化し、`Progress`に影響を反映してください。計画は、あなたのチェックリストと同じくらい、次の貢献者のためのガイドです。
* 主要なタスクまたは完全な計画の完了時に、達成されたこと、残っていること、学んだ教訓を要約する`Outcomes & Retrospective`エントリを書いてください。

### プロトタイピングマイルストーンと並列実装

より大きな変更のリスクを軽減するために、明示的なプロトタイピングマイルストーンを含めることは許容され、しばしば推奨されます。例：実現可能性を検証するために依存関係に低レベルのオペレータを追加する、またはオプティマイザーの効果を測定しながら2つの合成順序を探索する。プロトタイプを加算的でテスト可能に保ってください。スコープを「プロトタイピング」として明確にラベル付けしてください。結果を実行して観察する方法を説明してください。プロトタイプを昇格または破棄するための基準を述べてください。

テストが通過し続けるように、加算的なコード変更の後に減算を優先してください。並列実装（例えば、移行中に古いパスと並んでアダプターを保持する）は、リスクを軽減したり、大規模な移行中にテストが通過し続けるようにしたりする場合に問題ありません。両方のパスを検証する方法と、テストで安全に1つを廃止する方法を説明してください。複数の新しいライブラリや機能領域を扱う場合、これらの機能を**互いに独立して**評価するスパイクを作成することを検討してください。外部ライブラリが期待どおりに動作し、分離して必要な機能を実装することを証明してください。

### 良いExecPlanのスケルトン

```md
# <短い、行動指向の説明>

このExecPlanは生きている文書です。`Progress`、`Surprises & Discoveries`、`Decision Log`、および`Outcomes & Retrospective`セクションは、作業が進むにつれて最新の状態に保つ必要があります。

PLANS.mdファイルがリポジトリにチェックインされている場合、リポジトリルートからそのファイルへのパスをここで参照し、この文書がPLANS.mdに従って維持される必要があることに注意してください。

## Purpose / Big Picture

この変更の後、誰かが得るものと、それがどのように動作するかを確認する方法を数文で説明してください。有効にするユーザーに見える動作を述べてください。

## Progress

チェックボックス付きのリストを使用して、細かいステップを要約してください。すべての停止ポイントをここに文書化する必要があります。部分的に完了したタスクを2つ（「完了」と「残り」）に分割する必要がある場合でもです。このセクションは、作業の実際の現在の状態を常に反映する必要があります。

- [x] (2025-10-01 13:00Z) 完了したステップの例。
- [ ] 未完了のステップの例。
- [ ] 部分的に完了したステップの例（完了：X; 残り：Y）。

タイムスタンプを使用して進捗率を測定してください。

## Surprises & Discoveries

実装中に発見された予期しない動作、バグ、最適化、または洞察を文書化してください。簡潔な証拠を提供してください。

- 観察：…
  証拠：…

## Decision Log

計画に取り組んでいる間に行われたすべての決定を次の形式で記録してください：

- 決定：…
  根拠：…
  日付/著者：…

## Outcomes & Retrospective

主要なマイルストーンまたは完了時に、結果、ギャップ、学んだ教訓を要約してください。結果を元の目的と比較してください。

## Context and Orientation

読者が何も知らないかのように、このタスクに関連する現在の状態を説明してください。主要なファイルとモジュールに完全なパスで名前を付けます。使用する非自明な用語を定義してください。以前の計画を参照しないでください。

## Plan of Work

散文で、編集と追加のシーケンスを説明してください。各編集について、ファイルと場所（関数、モジュール）に名前を付け、挿入または変更する内容を指定してください。具体的で最小限に保ってください。

## Concrete Steps

実行する正確なコマンドと実行場所（作業ディレクトリ）を述べてください。コマンドが出力を生成する場合、読者が比較できるように短い期待されるトランスクリプトを示してください。このセクションは、作業が進むにつれて更新する必要があります。

## Validation and Acceptance

システムを起動または実行する方法と、観察する内容を説明してください。受け入れを、特定の入力と出力を持つ動作として表現してください。テストが関与する場合、「<プロジェクトのテストコマンド>を実行し、<N>が通過することを期待してください。新しいテスト<名前>は変更の前に失敗し、変更の後に通過します」と言ってください。

## Idempotence and Recovery

ステップを安全に繰り返すことができる場合は、そう言ってください。ステップがリスクがある場合は、安全な再試行またはロールバックパスを提供してください。完了後、環境をクリーンに保ってください。

## Artifacts and Notes

最も重要なトランスクリプト、差分、またはスニペットをインデントされた例として含めてください。成功を証明するものに焦点を当てて、それらを簡潔に保ってください。

## Interfaces and Dependencies

規範的であること。使用するライブラリ、モジュール、サービスに名前を付け、その理由を説明してください。マイルストーンの終わりに存在する必要がある型、トレイト/インターフェース、関数シグネチャを指定してください。`crate::module::function`や`package.submodule.Interface`などの安定した名前とパスを優先してください。例：

crates/foo/planner.rsで、以下を定義：

    pub trait Planner {
        fn plan(&self, observed: &Observed) -> Vec<Action>;
    }
```

上記のガイダンスに従うと、単一のステートレスエージェント、または人間の初心者が、ExecPlanを最初から最後まで読み、動作する観察可能な結果を生成できます。それが基準です：**自己完結、自己充足、初心者向け、結果重視**。

計画を改訂する際は、変更が生きている文書セクションを含むすべてのセクションに包括的に反映されていることを確認し、計画の下部に変更とその理由を説明するメモを書く必要があります。ExecPlanは、ほとんどすべてのものについて、何だけでなく、なぜを説明する必要があります。

## 重要なポイント

1. **自己完結性**: ExecPlanは、リポジトリの事前知識なしに、完全な初心者が機能をエンドツーエンドで実装できるようにする必要があります。

2. **生きている文書**: ExecPlanは、進捗、発見、決定に応じて継続的に更新される必要があります。

3. **観察可能な結果**: 計画は、内部実装の詳細ではなく、ユーザーが見ることができる動作に焦点を当てる必要があります。

4. **検証の重要性**: すべての変更は、テスト、実行、観察を通じて検証可能である必要があります。

5. **プロトタイピング**: リスクの高い変更については、プロトタイピングマイルストーンを含めることが推奨されます。

6. **並列実装**: 大規模な移行では、並列実装を使用してリスクを軽減できます。

このアプローチにより、Codexやgpt-5-codexなどのエージェントが、単一のプロンプトから長時間にわたる複雑なタスクを自律的に実装できるようになります。
