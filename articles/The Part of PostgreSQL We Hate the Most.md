---
title: "The Part of PostgreSQL We Hate the Most"
source: "https://www.cs.cmu.edu/~pavlo/blog/2023/04/the-part-of-postgresql-we-hate-the-most.html"
author:
  - "Andy Pavlo"
  - "Bohan Zhang"
published: 2023-04-26
created: 2026-01-04
description: "PostgreSQLのMVCC実装が他の主要RDBMSと比較して最も劣っている理由について、Carnegie Mellon大学の研究とOtterTuneの実務経験から詳細に解説した技術記事。"
tags:
  - "clippings"
  - "PostgreSQL"
  - "MVCC"
  - "database"
  - "performance"
  - "vacuum"
---

## 概要

この記事は、Andy PavloとBohan ZhangによってOtterTuneのために執筆され、PostgreSQLのMVCC (Multi-Version Concurrency Control) 実装の問題点を詳細に分析したものです。PostgreSQLは優れたDBMSですが、そのMVCC実装はMySQL、Oracle、Microsoft SQL Serverなどの他の主要RDBMSと比較して最も劣っており、Amazon RDS AuroraのPostgreSQLでも同じ問題が存在します。

## MVCCとは何か

**基本概念:**

- MVCCの目的は、複数のクエリが互いに干渉することなく同時にデータベースへの読み書きを可能にすること
- DBMSは既存の行を上書きせず、各論理行に対して複数の物理バージョンを維持
- クエリは、トランザクション開始時のデータベーススナップショットを参照（スナップショット分離）
- 明示的なレコードロックを不要にし、読み取りと書き込みの並行性を向上

**歴史的背景:**

- 1978年のDavid ReedのMIT博士論文で初めて記述
- 1980年代のInterBaseが最初の商用MVCC DBMS実装
- 過去20年間に作成されたトランザクションをサポートするほぼすべての新しいDBMSがMVCCを実装

**設計上の3つの主要な決定事項:**

1. 既存行の更新をどのように保存するか
2. 実行時にクエリに対して正しいバージョンをどのように見つけるか
3. もはや表示されない期限切れバージョンをどのように削除するか

## PostgreSQLのMVCC実装

### Append-Onlyストレージスキーム

**バージョン保存の仕組み:**

- クエリが既存行を更新すると、DBMSは行全体をコピーして新しいバージョンを作成
- すべての行バージョンを同じテーブル領域に保存
- 更新時に空きスロットを取得し、現在のバージョンの内容をコピーして変更を適用

**バージョンチェーン:**

- 単方向リンクリストでバージョンの系譜を記録
- PostgreSQLは**Oldest-to-Newest (O2N)** 順序を採用（ほとんどのDBMSはNewest-to-Oldest順序）
- 各行ヘッダーには次のバージョンへのポインタ（t_tcid）を含む
- インデックスは最古のバージョンを参照し、最新バージョンを見つけるにはチェーンをたどる必要がある

**インデックス管理:**

- 長いバージョンチェーンの走査を避けるため、各物理バージョンに対してインデックスエントリを追加
- 1つの論理行に5つの物理バージョンがある場合、インデックスには最大5つのエントリが存在

**Heap-Only Tuple (HOT) 最適化:**

- 更新がインデックス参照列を変更せず、新バージョンが同じページに格納される場合に適用
- 複数のインデックスエントリの作成を回避
- ディスクI/Oを削減

### Vacuumプロセス

**デッドタプル:**

- アクティブなトランザクションに表示されなくなった古いバージョン
- Vacuumプロセスがこれらを削除してスペースを再利用可能にする

**Autovacuum:**

- グローバル設定とテーブルレベルの設定で自動的に定期実行
- 手動で`VACUUM`コマンドを実行することも可能
- 最後の実行以降に変更されたテーブルページを順次スキャン

## PostgreSQLのMVCCが最悪である理由

### 問題1: バージョンコピー

**問題点:**

- 更新時にタプル全体をコピー（1カラムのみ変更でも全カラムをコピー）
- 大量のデータ重複と増加したストレージ要件
- より多くのメモリとディスクストレージが必要

**他のDBMSとの比較:**

- MySQLとOracleは新旧バージョン間のコンパクトなデルタを保存（gitのdiffのような仕組み）
- 1000カラムのテーブルで1カラムのみ更新する場合:
  - MySQL/Oracle: その1カラムの変更のみを含むデルタレコードを保存
  - PostgreSQL: 変更された1カラム + 未変更の999カラムを含む新バージョンを作成

**改善の試み:**

- EnterpriseDBが2013年に開始したzheapプロジェクト
- デルタバージョンを使用するようにappend-onlyストレージエンジンを置き換える試み
- 2021年の最終更新以降、プロジェクトは停滞

### 問題2: テーブル肥大化（Table Bloat）

**問題点:**

- デッドタプルがライブタプルよりも多くのスペースを占有
- 書き込み負荷の高いワークロードでは、Vacuumが追いつく速度よりも速くデッドタプルが蓄積
- デッドタプルとライブタプルがページ内で混在し、クエリ実行時にメモリにロード
- 不正確なオプティマイザ統計により不適切なクエリプランが生成

**具体例:**

- 1000万ライブタプル + 4000万デッドタプル（テーブルの80%が不要データ）
- 各タプル平均1KBの場合:
  - ライブタプル: 10GB
  - デッドタプル: 40GB
  - 合計: 50GB
- フルテーブルスキャン時、PostgreSQLは50GB全体をディスクから取得してメモリに保存

**Vacuumの制限:**

- 通常の`VACUUM`はデッドタプルを削除してページ内でライブタプルを再配置するだけ
- 空のページをディスクから回収しない
- 40GBのデッドタプルを削除しても、50GBの割り当て済みストレージスペースは保持される

**ストレージ回収:**

- `VACUUM FULL`またはpg_repack拡張機能を使用してテーブル全体を新しいスペースに書き換え
- リソース集約的で時間がかかる操作
- 本番データベースではクエリパフォーマンスに深刻な影響

### 問題3: セカンダリインデックスのメンテナンス

**問題点:**

- 1つのタプル更新でテーブルのすべてのインデックスを更新する必要がある
- PostgreSQLはプライマリおよびセカンダリインデックスの両方でバージョンの正確な物理位置を使用
- HOT更新でない限り、すべての更新でこの処理が発生

**パフォーマンスへの影響:**

- 更新クエリが遅くなる（より多くの作業が必要）
- 各インデックスを走査して新しいエントリを挿入するための追加I/O
- インデックスとDBMS内部データ構造（バッファプールのページテーブルなど）でのロック/ラッチ競合
- すべてのインデックスに対してメンテナンス作業を実行（更新されたカラムがインデックスに含まれているかどうかに関係なく）

**他のDBMSとの比較:**

- MySQLとOracleはプライマリインデックスのみを更新
- セカンダリインデックスはプライマリキーを参照
- 更新されたカラムに対応するインデックスのみを変更

### 問題4: Vacuum管理

**Autovacuumの課題:**

- 書き込み負荷の高いワークロードでデッドタプルの蓄積に追いつけない
- Autovacuumの実行がクエリパフォーマンスに影響
- 適切なチューニングが困難

**設定の複雑さ:**

- グローバル設定とテーブルレベルの設定の両方が必要
- ワークロードに応じた最適な設定の決定が難しい
- 誤った設定は深刻なパフォーマンス問題を引き起こす可能性

## 結論

PostgreSQLのMVCC実装は1980年代の設計の遺物であり、現代の標準からは劣っています。もし今日新しいMVCC DBMSを構築するなら、PostgreSQLの方式（append-onlyストレージとautovacuum）を採用すべきではありません。

**現状:**

- OrioleDBやYugabyteDBなどのハードフォークがMVCC実装を置き換えているが、これらの変更はメインのPostgreSQLコードベースにマージされることはない
- 当面、PostgreSQLのappend-only MVCCと付き合っていく必要がある

**著者の立場:**

- OtterTuneの目標は、データベースに関して心配事を減らすこと
- 次週のフォローアップ記事で、RDSとAuroraデータベースのPostgreSQL MVCC問題を自動的に管理するOtterTuneのソリューションを紹介予定

## 技術的詳細

**MVCCの実装において考慮すべき設計決定:**

1. **バージョンストレージ**: PostgreSQLはappend-only、MySQL/Oracleはデルタストレージ
2. **バージョンチェーン**: PostgreSQLはO2N、ほとんどのDBMSはN2O
3. **インデックス戦略**: PostgreSQLは全バージョンにインデックスエントリ、他のDBMSは最新バージョンのみ
4. **ガベージコレクション**: PostgreSQLはVacuum、他のDBMSはより効率的な機構

**研究の裏付け:**

- Carnegie Mellon大学での研究
- 2018年VLDB論文「MVCCに関する最高の論文」
- Amazon RDSでのPostgreSQLインスタンス最適化の実務経験

**制限事項:**

- この記事はPostgreSQLのMVCC実装に焦点を当てており、PostgreSQL全体の評価ではない
- PostgreSQLは依然として信頼性が高く、機能が豊富で、ほとんどの運用ワークロードに適している
- MVCC実装の問題は深刻だが、対処可能
