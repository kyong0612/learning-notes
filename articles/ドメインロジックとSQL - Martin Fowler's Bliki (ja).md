---
title: "ドメインロジックとSQL - Martin Fowler's Bliki (ja)"
source: "https://bliki-ja.github.io/DomainLogicAndSQL/"
author:
  - Martin Fowler
  - kdmsnr (翻訳)
published: 2003-02
created: 2025-10-08
description: |
  エンタープライズアプリケーション開発において、ビジネスロジックをSQLに配置すべきか、メモリ上のコードに配置すべきかという問題について、パフォーマンスと保守性の観点から考察した記事。Transaction Script、Domain Model、複雑なSQLクエリという3つのアプローチを比較し、それぞれのトレードオフを詳しく解説している。
tags:
  - SQL
  - ドメインロジック
  - エンタープライズアプリケーション
  - アーキテクチャ
  - パフォーマンス
  - 設計
---

## 概要

データベース指向の開発者とメモリ上のアプリケーション開発者の間のギャップは広がり続けており、ビジネスロジックをデータベース（SQLやストアドプロシージャ）に置くべきか、メモリ上のコードに置くべきかという議論が絶えない。この記事では、主にパフォーマンスと更新性の観点から、リッチなSQLクエリの利点と欠点を深く掘り下げている。

## 問題の背景

エンタープライズアプリケーション（EA）構築では、ロジックを複数のレイヤに分割するのが一般的である。特に重要なのは、ドメインロジック（ビジネスルール）とデータソースロジック（データ取得方法）の分離である。

多くのアプリケーション開発者（特にOO開発者）は、RDBを単なるストレージ装置と見なしがちで、フレームワークもSQLの複雑さを隠蔽しようとする。しかし、SQLはデータのアップデートや検索だけでなく、様々なタスクを処理できる強力なツールである。

## 3つのアプローチの比較

### 1. Transaction Script（トランザクションスクリプト）

リクエストに応じて処理を行う手続き型のパターン。

**特徴：**

- 必要なデータをすべて読み込み、メモリ上でループ処理
- シンプルで理解しやすい
- SQLを効果的に使わない（複数回のクエリ発行が必要）

**例：** Cuillenディスカウント適用月の取得

```ruby
def cuillen_months name
  customerID = find_customerID_named(name)
  result = []
  find_orders(customerID).each do |row|
    result << row['date'].month if cuillen?(row['orderID'])
  end
  return result.uniq
end
```

### 2. Domain Model（ドメインモデル）

オブジェクト指向的なアプローチ。メモリ上にオブジェクトを作り、データベーステーブルと対応させる。

**特徴：**

- ドメインロジックとデータアクセスロジックが明確に分離
- オブジェクト内でロジックを実行
- 読み込みロジックを変更してもドメインロジックには影響なし
- 複数のドメインロジックで同じ読み込みロジックを再利用可能

**例：**

```ruby
class Customer
  def cuillenMonths
    result = []
    orders.each do |o|
      result << o.date.month if o.cuillen?
    end
    return result.uniq
  end
end

class Order
  def cuillen?
    discountableAmount = 0.dollars
    line_items.each do |line|
      discountableAmount += line.cost if 'Talisker' == line.product
    end
    return discountableAmount > 5000.dollars
  end
end
```

### 3. Logic in SQL（SQL内にロジック）

SQLの強力なクエリ機能を活用するアプローチ。

**特徴：**

- わずか数行で大容量データのフィルタリングや集約が可能
- ドメインロジックを組み込むことも可能
- レイヤ分離の原則には反する可能性

**例：**

```sql
SELECT DISTINCT MONTH(o.date) AS month
  FROM lineItems l
    INNER JOIN orders o ON l.orderID = o.orderID
    INNER JOIN customers c ON o.customerID = c.customerID
  WHERE (c.name = ?) AND (l.product = 'Talisker')
  GROUP BY o.orderID, o.date, c.NAME
  HAVING (SUM(l.cost) > 5000)
```

## パフォーマンスの考察

### 初期結果

著者のテストでは、複雑なSQLクエリは他の2つのアプローチよりも**20倍高速**だった。

**理由：**

- インメモリアプローチでは複数回SQLクエリを発行（2 + N回、Nは注文数）
- 複雑なSQLは1回のクエリでレコード選択とコスト合計を実行

### 最適化後

トランザクションスクリプトとドメインモデルを最適化（1回のクエリに統合）した結果：

- トランザクションスクリプト：**3倍高速化**
- ドメインモデル：読み込みロジックのみ変更、ドメインロジックは不変
- それでも複雑なSQLより約6倍遅い

**重要な発見：**

- インメモリアプローチでも、インテリジェントなクエリで大幅な性能向上が可能
- ドメインモデルの利点：ドメインロジックに影響を与えずに読み込みロジックを最適化可能

## 更新性（保守性）の考察

エンタープライズアプリケーションは長寿命で、頻繁に変更される。変更しやすいシステム設計が重要。

### SQLの限界

- 複雑なアルゴリズム（例：メジアンの計算）には不向き
- ベンダー固有の拡張機能が必要になることがある
- データベースに保存する前にビジネスロジックを実行したい場合に問題

### 分かりやすさ

- **ドメインモデル**：ドメインロジックが最も追いやすい（データベースアクセスが分離）
- **SQL**：次に分かりやすい
- **トランザクションスクリプト**：最も分かりにくい

チームのSQLスキルレベルに応じて適切なアプローチを選択すべき。

### 重複排除（DRY原則）

**問題：** 新しい仕様追加時の重複

Domain Modelの利点：

- ビジネスロジックを一箇所に集約
- 変更が必要な箇所は1か所のみ
- 例：`cuillen?`メソッドを変更すれば、すべての利用箇所が自動的に更新

**SQLの解決策：ビュー**

ビューを使用することで重複を排除可能：

```sql
-- Orders2 ビューを定義
SELECT o.orderID, c.name, c.customerID, o.date,
       SUM(li.cost) AS totalCost,
       CASE WHEN (SELECT SUM(li2.cost)
                    FROM lineitems li2
                    WHERE li2.product = 'Talisker'
                      AND o.orderID = li2.orderID) > 5000
            THEN 'Y' ELSE 'N'
       END AS isCuillen
  FROM dbo.orders o
    INNER JOIN dbo.lineItems li ON o.orderID = li.orderID
    INNER JOIN dbo.CUSTOMERS c ON o.customerID = c.customerID
  GROUP BY o.orderID, c.name, c.customerID, o.date
```

しかし、実務ではビューによる重複排除はあまり行われていない。

### カプセル化

**目的：** アプリケーション全体を変更せずにデータベーススキーマを変更可能にする

**実現方法：**

- **レイヤ分け**：ドメインロジックとデータソースロジックの分離
- **ビュー**：テーブル変更時に古いテーブルをサポートするビューを作成
- **ストアドプロシージャ**：DML（Data Management Language）をラップ

**課題：**

- 複数のデータソース（RDB、レガシーシステム、ファイルなど）が存在する場合、アプリケーションコード内のレイヤでのみ完全なカプセル化が可能

### データベース移植性

**現実：**

- 標準SQLは理論上どのデータベースでも使用可能
- 実際には各ベンダー固有の拡張機能で躓くことが多い
- 移植性を確保するとSQLの強力な機能が損なわれる

**考慮点：**

- データベース市場は主要3企業で占められている
- 企業はいずれかと強く結びついている
- 移植性が不要なら、ベンダー固有機能を活用すべき
- 複数DBをサポートする製品開発者は移植性に注意が必要

### テスト容易性

**問題：**

- 実務ではSQLのテストが行われていないことが多い
- 重要なビューやストアドプロシージャが構成管理ツールに置かれていないことも

**解決策：**

- xunitツールでデータベース環境のテストが可能
- Evolutionary database（進化的データベース設計）テクニックの活用
- テストデータベースの作成

**パフォーマンスの違い：**

- ビジネスロジックのテストはメモリ上の方が高速
- Service Stubを使用してデータベース接続を置き換え可能

## 結論と推奨事項

### データが分散している場合

データが複数のデータソースに分散（SQLが使えないデータソースを含む）：

- **推奨：** データソース層をカプセル化し、ドメインロジックをメモリ上に配置
- **理由：** SQLの強力さは無意味（すべてのデータソースでSQLが使えないため）

### データが単一RDBにある場合

考慮すべき2つの軸：

1. **プログラミング言語**：SQL vs アプリケーション言語
2. **実行場所**：データベース上 vs メモリ上

**判断基準：**

- **SQLの得意不得意**：タスクによってSQLの適性が異なる
- **チームのスキル**：メンバーのSQL習熟度
- **移植性の要件**：必要なら複雑なSQLは避ける
- **パフォーマンス要件**：ボトルネックがあればSQLの活用を検討

### 推奨アプローチ

1. **基本方針**：更新性を最優先し、ドメインロジックをメモリ上に配置
2. **最適化**：プロファイラでボトルネックを特定
3. **部分的なSQL活用**：ボトルネックのみ複雑なSQLで解決
4. **ビューの活用**：重複排除とカプセル化のためにビューを使用
5. **データソースビューとビジネスロジックビューの分離**：より良いカプセル化を実現

### 重要な考慮事項

- パフォーマンスは重要だが、最初から最適化すべきではない
- 更新性に優れたコードは、後からパフォーマンス改善が容易
- システムのごく一部のみが実際にパフォーマンスを必要とする
- SQLを使う場合でも、適切に設計・テストする必要がある
- チーム構成とスキルセットが適切なアーキテクチャを決定する

## 技術的詳細

**使用例：** Cuillenディスカウント（タリスカーを一度に5000ドル以上購入した顧客に適用）の適用月を取得

**データモデル：**

- Customers（顧客）
- Orders（注文）
- LineItems（注文明細）

**実装言語：** Ruby（コンパクトで構造化されたコード、OO的な実装が容易）

**パフォーマンス測定結果：**

- 複雑なSQL：最速
- インメモリ（未最適化）：20倍遅い
- インメモリ（最適化後）：6倍遅い（トランザクションスクリプトは3倍改善）

この記事は、SQLとメモリ上のコードのトレードオフを理解し、プロジェクトの要件に応じて適切な判断を下すための包括的なガイドを提供している。
