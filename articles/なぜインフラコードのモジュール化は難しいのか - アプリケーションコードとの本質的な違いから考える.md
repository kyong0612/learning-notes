---
title: "なぜインフラコードのモジュール化は難しいのか - アプリケーションコードとの本質的な違いから考える"
source: "https://speakerdeck.com/mizzy/yapc-fukuoka-2025?slide=90"
author:
  - "[[Gosuke Miyashita]]"
published: 2025-11-14
created: 2025-11-17
description: |
  インフラコードのモジュール化が難しい理由を、アプリケーションコードとの本質的な違いから考察する発表。Terraformモジュールを例に、なぜ有名なパブリックモジュールでも「まとめすぎ」「細分化しすぎ」といった問題が起きるのかを、凝集度・結合度の観点から分析。インフラコードは状態を記述し詳細が関心事であるため、抽象化しにくくホワイトボックス的利用が必要であることを説明し、適切な向き合い方を提示する。
tags:
  - "clippings"
  - "Infrastructure as Code"
  - "Terraform"
  - "モジュール化"
  - "ソフトウェア設計"
  - "凝集度"
  - "結合度"
---

# なぜインフラコードのモジュール化は難しいのか - アプリケーションコードとの本質的な違いから考える

## 発表の趣旨

- インフラコードのモジュール化が難しい理由を言語化したい
- 既存の資料で十分に語られていない
- 難しさとどう向き合うべきかを考える
- 具体的なIaCツールとしてTerraformを扱う

## 01 インフラコードのモジュール化の難しさ

### Terraformモジュールに関する問題点

#### まとめすぎ

**具体例: terraform-aws-vpcモジュール**

- 定義されている変数: 236個（すべてオプショナル）
- 扱っているリソースタイプ: 32種類
  - main.tf: 27種類
  - vpc-flow-logs.tf: 5種類（VPC Flow Logs関連リソース）
- 最小構成: 4種類/4個のリソース
- 最大構成: 32種類/118個のリソース
- main.tf: 1542行

**問題点:**

- VPC関連であれば何でも詰め込む
- 機能的な関連性ではなく、分類的な関連性でまとめている
- コア機能と周辺機能が混在（Flow Logs、VPN、サブネットグループなど）
- 236個の変数により内部構造がそのまま露出
- 1542行のmain.tfにより全体像の把握が不可能

#### 細分化しすぎ

**具体例: terraform-google-networkモジュール**

- terraform-aws-vpcモジュールと対照的にサブモジュールに細かく分割されている
- main.tfが呼んでいるサブモジュール:
  - modules/vpc: 2種類（google_compute_network、google_compute_shared_vpc_host_project）
  - modules/subnet: 1種類（google_compute_subnetwork）
  - modules/route: 1種類（google_compute_route）
  - modules/firewall-rules: 1種類（google_compute_firewall）

**問題点:**

- 各サブモジュールが1〜2種類のリソースしか扱っていない
- VPC、サブネット、ルート、ファイアウォールは密接に関連し、通常セットで設計・管理するリソース群
- これらを分離することで、かえって全体像が把握しにくくなっている

#### 多段構成による問題の悪化

**terraform-google-network: 2段階構成**

- メインモジュール → サブモジュール
- 既に「細分化しすぎ」と「まとめすぎ」が同時に存在

**terraform-google-project-factory: 3段階のモジュール階層**

- Level 1（メインモジュール）: 複数のサブモジュールを呼び出し
- Level 2（core_project_factory）: プロジェクトのコア機能を管理
- Level 3（project_services）: API有効化とサービスアイデンティティ管理

**問題点:**

- 2段構成から既に問題が発生
- 3段構成以上でさらに複雑化・深刻化
- 階層が深くなるほど、内部構造の可視性が損なわれる

### 凝集度と結合度で見た問題

**凝集度（低い順）:**

- 偶発的凝集（最悪）
- 論理的凝集
- 時間的凝集
- 手続き的凝集
- 通信的凝集
- 逐次的凝集
- 機能的凝集（最良）

**結合度（高い順）:**

- 内容結合（最悪）
- 共通結合
- 外部結合
- 制御結合
- スタンプ結合
- データ結合
- メッセージ結合（最良）

**問題の分析:**

- **まとめすぎ（terraform-aws-vpc）**: 論理的凝集（凝集度が低い）
- **細分化しすぎ（terraform-google-network）**: 制御結合（結合度が高い）
- **多段構成**: 凝集度の低さ・結合度の高さが同時に存在し、さらに複雑化

### 統合強度で見た問題

**統合強度（強い順）:**

- 侵入結合（Intrusive coupling）: 実装詳細への依存、最も強い結合
- 機能結合（Functional coupling）: ビジネスロジックの共有
- モデル結合（Model coupling）: データモデルの共有
- コントラクト結合（Contract coupling）: 統合専用のインターフェース、最も弱い結合

**問題の分析:**

- **terraform-aws-vpc（まとめすぎ）**: 236個の変数を公開し、内部モデルをそのまま共有（モデル結合）。浅いモジュール：複雑性をカプセル化できていない。漏れのある抽象化。
- **terraform-google-network（細分化しすぎ）**: 機能結合（親が変数で子の構成を制御）
- **terraform-google-project-factory（多段構成）**: モデル結合と機能結合が複合的に存在

### まとめ

- 有名なパブリックモジュールによく見られる凝集度・結合度の問題
- アプリケーションコードでは悪い設計として認識されるが、インフラコードではこれがまかり通っている
- 次章以降で、なぜ論理的凝集・制御結合がインフラコードで起きやすいかを考える

## 02 記述対象: 状態を記述するインフラコード vs 処理を記述するアプリケーションコード

### 根本的な違い

**インフラコード:**

- 「状態」を記述する
- リソースの詳細が主眼

**アプリケーションコード:**

- 「処理」を記述する
- 処理の役割が主眼

### 特徴の比較

#### 記述内容

**インフラコード:**

- 「VPC」「パブリックサブネット」「プライベートサブネット」といったあるべき状態を宣言
- リソースの状態を宣言し、依存関係を記述する

**アプリケーションコード:**

- 「ユーザー検索」 → 「認証」 → 「セッション生成」といった手順を記述
- 処理の流れと呼び出し関係を記述する

#### 関心事

**インフラコード:**

- VPCやサブネットの設定内容（CIDRブロック、DNS設定、AZ、Nameタグなど）
- リソースの詳細な設定内容が関心事

**アプリケーションコード:**

- ユーザー検索、認証、セッション生成
- 処理の役割が関心事で、実装の詳細は関心外

#### 抽象化のしやすさ

**インフラコード:**

- リソースの詳細な内容や依存関係が関心事
- 抽象化して隠蔽すると実際の設定内容や依存関係が見えなくなる
- 抽象化できる範囲が限定的

**アプリケーションコード:**

- 実装の詳細は関心外
- 抽象化して隠蔽しても、処理の流れが理解できればよい
- 広い範囲で抽象化でき、実装の詳細を隠蔽できる

### まとめ

- インフラコードとアプリケーションコードの根本的な違い
  - インフラコード：状態を記述 → 詳細が関心事
  - アプリケーションコード：処理を記述 → 処理が何をするかが関心事
- この違いが関心事の違いを生む
- 関心事の違いが抽象化のしやすさに影響する
  - インフラコード：詳細を隠せない → 抽象化しにくい
  - アプリケーションコード：詳細を隠せる → 抽象化しやすい

## 03 抽象化の目的: 構成のパターン化 vs 処理のカプセル化

### 関心事の違いが抽象化の目的を決める

**インフラコード:**

- 詳細が関心事 → 構成のパターン化

**アプリケーションコード:**

- 処理が何をするかが関心事 → 処理のカプセル化

### インフラコードの抽象化の目的

- 詳細が関心事なので、実装の詳細を隠蔽できない
- 設定の詳細や依存関係が見えている必要がある
- そのため抽象化しにくい

**抽象化の目的:**

- 構成のパターンを再利用するため
  - 構成パターンをテンプレート化して使い回す
  - セキュリティのベストプラクティスを組み込む
  - 組織の標準設定を適用する

**例: 3-AZ構成のVPC**

- パブリックサブネット×3、プライベートサブネット×3、NATゲートウェイ×3
- この「パターン」をすべての環境に適用したい

### アプリケーションコードの抽象化の目的

- 処理が何をするかが関心事なので、実装の詳細を隠蔽できる
- そのため抽象化しやすい

**抽象化することで実現できること:**

- 本質的な処理に集中できる
- 実装変更を容易にする
- 変更の影響範囲を限定する
- コードを再利用可能にする

### まとめ

- 関心事の違いが抽象化の目的を決める
- インフラコードは構成のパターンを再利用する
- アプリケーションコードは処理をカプセル化する

## 04 利用のしかた: ホワイトボックス的利用 vs ブラックボックス的利用

### 抽象化のしやすさの違いが利用のしかたに影響

**インフラコード:**

- 詳細が関心事 → 詳細を隠せない
- モジュールの中身を理解して使う必要がある
- **ホワイトボックス的利用**（中身を理解して使う）

**アプリケーションコード:**

- 処理が何をするかが関心事 → 詳細を隠せる
- モジュールの中身を知らなくても使える
- **ブラックボックス的利用**（中身を知らずに使える）

### インフラコード：ホワイトボックス的利用

**モジュールの中身を理解して使う必要がある:**

- どんなリソースが作られるか
- どういう依存関係になるか
- どんな設定が可能か

**モジュールの全容が把握しやすい必要がある:**

- コードを読めば理解できる
- ドキュメントで構成内容が把握できる
- 要件に過不足のない構成（内容が推測しやすい）
- 合意形成を通じた共通理解の形成

**パブリックなモジュールをそのまま使うのは難しい:**

- 要件に完全に合致するモジュールは少ない
- 組織内で管理されたモジュールを使うか、自作する

### アプリケーションコード：ブラックボックス的利用

**モジュールの中身を知らなくても使える:**

- インターフェースだけわかればよい
- 何をするかがわかればよい
- どうやっているかは知らなくてよい

**モジュールの全容を把握する必要がない:**

- インターフェースが安定していればよい
- 内部実装を知らなくてよい
- 後方互換性が保たれていればよい

**パブリックなモジュールもそのまま使えることが多い:**

- インターフェースが明確に定義されている
- 処理の抽象化により汎用的な要件として利用できる

### まとめ

- 抽象化のしやすさの違いがモジュールの利用のしかたに影響する
- インフラコード：ホワイトボックス的利用
- アプリケーションコード：ブラックボックス的利用
- この違いがモジュール設計に影響する

## 05 設計への影響: 内部構造の可視性 vs 抽象性・階層化

### 利用のしかたの違いがモジュール設計に影響

**インフラコード:**

- ホワイトボックス的利用 → **内部構造の可視性を重視**

**アプリケーションコード:**

- ブラックボックス的利用 → **抽象性・階層化を重視**

### インフラコード：内部構造の可視性を重視

**モジュールの中身を理解する必要がある:**

- → 内部構造が見えるように設計する

**内部構造の可視性を高めるための設計:**

- 内部構造が見えやすい粒度で分割する
- 階層を深くしすぎない
- 階層の深さを統一する

**抽象化しすぎると逆効果:**

- 何が作られるか見えなくなる
- 依存関係が隠蔽される
- 値の定義と使用の場所が離れ、実際の設定が把握しにくい
- 内部構造が見えなくなる

### アプリケーションコード：抽象性・階層化を重視

**モジュールの中身を知る必要がない:**

- → 抽象化して詳細を隠す設計をする

**抽象性を高めるための設計:**

- インターフェースを明確にする
- 実装の詳細を隠蔽する
- 階層化して複雑さを管理する

**抽象化が設計の基本:**

- 処理の流れが理解できればよい
- 実装の詳細は変更可能
- モジュールの独立性が高まる

### インフラコード：階層化の問題

**2段構成でも問題が発生:**

- 本来一緒に管理すべきリソースが分離される
- 内部構造が見えにくくなる

**3段構成以上でさらに深刻:**

- 「まとめすぎ」と「細分化しすぎ」が同時に存在
- 内部構造の把握と依存関係の追跡が困難

**階層の深さが統一されていないとさらに問題:**

- あるモジュールは2段、別のモジュールは3段、また別のは4段
- 統一性のなさが内部構造の把握を困難にする

**インフラコードでの階層化は慎重に:**

- 階層を深くするほど内部構造の可視性が損なわれる
- 階層の深さを統一することも重要

### アプリケーションコード：階層化のメリット

**階層化は複雑さを管理する有効な手段:**

- 適切に抽象化すれば、各層の役割が明確になる

**階層化による整理の例（データベース操作）:**

- ORM → database/sql → ドライバ
- 各層が明確なインターフェースを提供し、実装の詳細を隠蔽

**階層が深くても問題になりにくい:**

- 各層のインターフェースを理解すればよい
- 実装の詳細は隠蔽されている

**インフラコードとの対比:**

- 階層化が設計の基本的な手法
- 深い階層も適切に設計すれば問題ない

### 設計の優先順位の違い

**インフラコード：内部構造の可視性を重視**

- 内部構造が見えやすい粒度で分割する
- 階層を深くしすぎない
- 階層の深さを統一する

**アプリケーションコード：抽象性・階層化を重視**

- インターフェースを明確にする
- 実装の詳細を隠蔽する
- 階層化して複雑さを管理する

### まとめ

- 利用のしかたの違いが設計の優先順位に影響する
- インフラコード：内部構造の可視性を重視
- アプリケーションコード：抽象性・階層化を重視
- この違いがインフラコードのモジュール化を難しくしている

## 06 難しさとどう向き合うか

### 基本的な考え方

- これまで見てきた難しさ:
  - インフラコードは詳細が関心事で抽象化しにくい
  - ホワイトボックス的利用が必要で、内部構造の可視性を重視する必要がある
  - ブラックボックス的利用を前提としたアプリケーションコードの感覚でモジュール化すると問題が起きる
- この本質的な違いを理解した上で、向き合い方を考える
- 基本的にTerraformの話になる

### 向き合わない

**無理にモジュール化しない:**

- シンプルに保つ
- 必要になるまでモジュール化を避ける
- YAGNI (You Aren't Gonna Need It)
- 本当に必要になってから考える

**事例: バイセルテクノロジーズ**

- 共通moduleを廃止してシンプルな構成に変更
- チーム全員がメンテナンスできることを優先

### ディレクトリ分割

- ディレクトリ分割も広義のモジュール化
- 機能的凝集を意識して分割する
- なるべくお互いに依存しないような形でわける
- 依存がある場合、変更の少ないものに依存する

**Terraformのディレクトリ構成の変更は割と容易にできるので気軽にやる:**

- import/moved/removedブロックやtfmigrateを活用
- 安全に変更するためCI/CDワークフローを組む

### ファイル分割

- ファイル分割も広義のモジュール化
- これも機能的凝集を意識する
- 論理的凝集にしない
  - 例: security_groups.tfにセキュリティグループを詰め込むのは避ける

**main.tfというファイル名は避ける:**

- 機能を表す適切な名前にする
- ただしひとつしかtfファイルがない場合はmain.tfでも問題ない
- そもそも状態を記述しているので、処理の起点となるmainなエントリーポイントは存在しない

**Terraformのファイル構成を後からいくらでも変更できるので気軽にやる**

### モジュール機能の利用

- これも機能的凝集を意識する
- 誤ったDRYに注意
  - 表面的な類似性だけで共通化しない

**モジュールの設計:**

- モジュールの目的や内容が予測しやすい名前や構成にする
  - 例: ecsではなくecs_on_managed_instances
- 組織や機能に適したデフォルト設定を内部で定義する
  - 合意形成が重要
- 階層を深くしすぎない、階層の深さを統一する
- レベル分けするのもあり
  - CDK L2, L3コンストラクトのようなイメージ

### パブリックモジュールは原則として利用しない

**汎用的すぎる:**

- 論理的凝集になっていて機能的凝集になっていない
- 共有される知識（変数）が多い
  - 大量の変数を公開し、内部モデルをそのまま共有（モデル結合）
  - 浅いモジュール：複雑性をカプセル化できていない
  - 境界を越えて共有される知識を削減できていない
  - 利用者の認知負荷を増加

**なぜインフラコードでこれが起こるか:**

- 詳細が関心事なので、抽象化できる範囲が限定的
- 汎用性を求めると、あらゆるケースに対応しようとする
  - 機能を詰め込む（論理的凝集）
  - 細分化しすぎる（制御結合）
  - 内部モデルをそのまま大量の変数として公開（モデル結合、漏れのある抽象化）

**組織内で管理されたモジュールを使うか、自作する**

### まとめ

- **向き合わない**: 無理にモジュール化しない、YAGNI、シンプルに保つことを優先
- **ディレクトリ分割・ファイル分割**: 論理的凝集ではなく機能的凝集を意識
- **モジュール機能の利用**: 論理的凝集ではなく機能的凝集を意識、組織や機能に適したデフォルト設定を内部で定義する、階層を深くしすぎない、階層の深さを統一する
- **パブリックモジュールは原則として利用しない**: 汎用的すぎて論理的凝集・制御結合になりやすく、内部モデルをそのまま大量の変数として露出している（モデル結合、漏れのある抽象化）、組織内で管理されたモジュールを使うか、自作する

## 本発表のまとめ

- **インフラコードとアプリケーションコードは本質的に異なる**
  - インフラコード：状態を記述 → 詳細が関心事 → 構成のパターン化
  - アプリケーションコード：処理を記述 → 処理が何をするかが関心事 → 処理のカプセル化

- **この違いがモジュール化の難しさを生む**
  - インフラコード：内部構造の可視性が必要（ホワイトボックス的利用）
  - アプリケーションコード：抽象化が可能（ブラックボックス的利用）

- **難しさを理解した上で、適切に向き合う**
  - 無理にモジュール化しない（YAGNI）
  - 機能的凝集を意識する
  - 組織や機能に適したデフォルト設定を内部で定義する
  - 階層を深くしすぎない、階層の深さを統一する
  - パブリックモジュールは原則として使わず、組織内で管理する
