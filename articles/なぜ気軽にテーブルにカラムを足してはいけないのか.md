---
title: "なぜ気軽にテーブルにカラムを足してはいけないのか"
source: "https://zenn.dev/mj2mkt/articles/2025-10-12-dont-add-columns-at-random"
author:
  - "まじまっちょ"
published: 2025-10-13
created: 2025-10-16
description: |
  データベース設計において、安易にテーブルへカラムを追加することの危険性を3つの観点から解説。正規化の不足や複数エンティティの混在といった設計上の問題、データベースリファクタリングの高コストと長時間のダウンタイムリスク、そして複雑化するインデックス設計の課題について具体例を交えて説明し、適切なデータモデリングの重要性を強調する。
tags:
  - "database"
  - "RDB"
  - "SQL"
  - "データベース設計"
  - "正規化"
  - "リファクタリング"
---

## はじめに

データベース（RDB）の設計において、深く考えずにテーブルにカラムを追加してしまうことはよくある失敗パターンです。テーブルの追加よりもアプリケーション側での変更が少ないため、心理的ハードルが低いことも一因です。しかし、安易なカラム追加は取り返しのつかない事態を招く可能性があります。

この記事では、なぜ気軽にテーブルにカラムを足してはいけないのかを以下の3つの観点から説明します：

1. そもそもデータベース設計がちゃんとできていないことの兆候である
2. 変更のコストが大きい
3. インデックスの設計が難しくなる

## そもそもデータベース設計がちゃんとできていないことの兆候である

カラム数が多すぎるテーブルは「Database Smell」（データベースの設計上の悪い兆候）の1つとされています。気軽にカラムを増やしてしまう場合、以下の問題があることが多いです。

### 正規化ができていない

正規化はデータベース設計の基本中の基本です。カラム追加の最も初歩的な失敗例として、**マルチカラムアトリビュート**（列持ちテーブル）があります。

**悪い例：連絡先テーブル**

| user_id | phone1 | phone2 | phone3 |
|---------|--------|--------|--------|
| 1 | 090-xxxx-xxxx | 080-xxxx-xxxx | NULL |
| 2 | 070-xxxx-xxxx | NULL | NULL |
| 3 | 090-xxxx-xxxx | 050-xxxx-xxxx | 03-xxxx-xxxx |

この設計の問題点：

- 特定の電話番号を検索するには全てのカラムを検索する必要がある
- 一意性の保証ができない
- 更新時にどのカラムを更新するかのロジックが必要になる

**良い例：正規化された連絡先テーブル**

| id | user_id | priority | phone |
|----|---------|----------|-------|
| 1 | 1 | 1 | 090-xxxx-xxxx |
| 2 | 1 | 2 | 080-xxxx-xxxx |
| 3 | 2 | 1 | 070-xxxx-xxxx |
| 4 | 3 | 1 | 090-xxxx-xxxx |
| 5 | 3 | 2 | 050-xxxx-xxxx |
| 6 | 3 | 3 | 03-xxxx-xxxx |

電話番号を別テーブルに分割し、1対Nの関係を持たせることで上記の問題は解決されます。

パフォーマンスの問題などで正規化を崩すことが必要な時もありますが、最初の設計としては正規化するところから始めることが推奨されます。

### 複数エンティティを混在させてしまう

カラムが増えてしまうもう1つの原因は、複数のエンティティが1つのテーブルに混在してしまうことです。

**最初の注文テーブル**

| id | user_id | product_id | ordered_on |
|----|---------|------------|------------|
| 1 | 1 | 101 | 2024-01-01 |
| 2 | 2 | 102 | 2024-01-02 |
| 3 | 1 | 103 | 2024-01-03 |

**発送日を追加した注文テーブル（悪い例）**

| id | user_id | product_id | ordered_on | shipped_on |
|----|---------|------------|------------|------------|
| 1 | 1 | 101 | 2024-01-01 | 2024-01-05 |
| 2 | 2 | 102 | 2024-01-02 | NULL |
| 3 | 1 | 103 | 2024-01-03 | NULL |

この設計は、**注文エンティティと発送エンティティの一部が混在**してしまっている状態です。発送エンティティが混在していると、後から発送に関する情報をもっと入れたいとなったときに、ここに追加し続けてしまうことになります。この場合、発送は別のテーブルとして切り出すのが適切です。

**よくある失敗パターン：**

- 安直に日時（`xxx_at` / `xxx_on`）のカラムを追加
- フラグ（`xxx_flag`）のカラムを追加
- ステータス（`xxx_status`）のカラムを追加

これらを追加したくなったときには、他のエンティティではないかと疑いましょう。

## 変更のコストが大きい

アプリケーションのリファクタリングと比べて、**データベースのリファクタリングはコスト（時間・工数・リスク）が大きい**です。影響範囲、既存データ量、ダウンタイムの許容度などを考慮する必要があります。

> データベースリファクタリングは影響範囲も広く、時間がかかる。だからこそ一番必要なのはやり切るぞ！という覚悟である。

気軽に追加したカラムを後から削除するのはとても大変です。

### 移行時に負荷・ロックの発生により長時間のダウンタイムが発生する可能性がある

`ALTER TABLE`は多くのケースでロックを取ります。レコード数が多いとき、実行時間が長くなり、数時間そのテーブルに対する書き込みができなくなる場合もあります。新テーブルへの`INSERT`の場合も、レコード数が多いと実行時間が長くかかったり、データベースのCPUを圧迫する可能性があります。

**重要：** 事前にテスト環境でデータ移行のリハーサルを行い、実行時間やデータベースの負荷を確認しておくことが重要です。利用しているRDBMSで`ALTER TABLE`がどのようなロックを取るかは意識して運用すると安全です。

### Dual Write期間を設ける可能性がある

データ移行が大規模でリスクが大きい場合、アプリケーション側で新旧両方のテーブルに書き込む**Dual Write**を行うというプラクティスがあります。

**メリット：**

- アプリケーションのロールバックが可能になる
- データ移行のリスクを減らせる

**デメリット：**

- アプリケーション内部での複雑性が増す
- コードの変更にかかるコストが増大
- リリースを複数段階に分けて行う必要がある
- スケジュール管理が複雑になる

### 変更した時よりも時間が経つほど移行のコストは大きくなる

#### 移行自体のコスト

レコード数が大きくなると、ロックを取る時間やリソースの逼迫に大きく影響します。場合によっては**8時間以上**かかることもあり、「一晩のメンテだけで済むと思ってたら翌営業日の朝になっても終らない」なんてこともありえます。

本番環境でデータ移行を実施するときに「postgresql alter table 終わらない」というようなGoogle検索をしてしまうことがないようにしましょう。

#### 影響範囲を調べるコスト

カラムを別テーブルに移動させる際、アプリケーションの影響範囲を調査する必要があります。カラムに依存していなくても、テーブルへの依存があると、カラムに依存がないかどうかを確認する必要が出てきます。時間が経つほど、テーブルに対する依存が増えるため、カラムの依存調査にかかる手間が増えます。

また、データベースに入っているデータそのものはアプリケーションコードのようにGitを使って差分管理することはできないので、**全く予期せぬ値が入っていることもありえます**。保証してくれるのはデータベースのスキーマ定義のみです。

システムとしての使われ方も、時間の推移とユーザーの増加によって変わりえます。もともと想定していたのとは違う使われ方をしていたり、想定しない値が入っている可能性もあります。昔からある膨大なレコードに対しては事前に入念な検証が必要になります。

## インデックスの設計が難しくなる

一般的に、**カラムが少ないほどインデックス設計は楽**です。逆にカラム数が増えるほど、設計は難しいものになりやすいです。

### 複合インデックスの制約

インデックスは1つのテーブルに対してスキャンする際には1つしか使われません。そのため、複数のカラムに対してインデックスを使った検索を行いたい場合は、**複合インデックス**を使います。

しかし、複合インデックスも全てのカラムにつければいいわけではありません。一般的に複合インデックスは**左方一致する条件でしか利用されません**（左から順番にしか使われない）。

**例：書籍テーブル**

| id | name | category_id | publisher_id |
|----|------|-------------|--------------|
| 1 | A | 1 | 1 |
| 2 | B | 2 | 2 |
| 3 | C | 3 | 3 |

**インデックス：**

```sql
CREATE INDEX books_index ON books (category_id, publisher_id)
```

**インデックスが利用されるクエリ：**

```sql
-- 複合インデックスで指定されているすべての列を含む
SELECT * FROM books WHERE category_id = 1 and publisher_id = 1

-- 複合インデックスで指定されている左側の列を含む
SELECT * FROM books WHERE category_id = 1
```

**インデックスが利用されないクエリ：**

```sql
-- 複合インデックスで指定されている右側の列のみを含む
SELECT * FROM books WHERE publisher_id = 1
```

### インデックスショットガンの問題

むやみやたらにインデックスを増やすと**更新時のパフォーマンスが大きく劣化**します。これはSQLアンチパターンで説明されている「インデックスショットガン」という問題です。

気軽にカラムを増やすと、後でパフォーマンスチューニングをする際にも足枷になりやすいことがわかります。

## 慣れるより習う（習うより慣れよではない）

データベース設計の失敗は時間が経ってから気づくことが多いです。そのため、自分で失敗した内容から学ばずに、異動や転職などで新しい環境に行って同じ失敗を繰り返してしまうこともあるでしょう。

逆に、他の人が失敗した内容を見て学ぶことはできます。しかし、問題が大きくなってしまった後では理想の状態を描くことが難しいのも確かです。

> DBの問題は忘れた頃にやってくる

学習のためにいい本や資料はたくさんあります。経験と学習の両方が、適切なデータベース設計には必要です。

## 終わりに

カラムの追加はデータベースの操作の中でも基本的な操作ですが、さまざまな問題を起こしうることをご理解いただけたでしょうか。

カラム追加が適切な場合ももちろんありますが、適切なデータモデリング・テーブル設計が行われた上で初めて判断できることです。適切にデータベース設計ができるようになるまでは経験と学習が必要です。

### 推奨書籍

- [達人に学ぶDB設計徹底指南書 第2版](https://www.shoeisha.co.jp/book/detail/9784798110660) - 第2版で大幅に加筆され、内容も刷新されています
- [SQLアンチパターン 第2版](https://www.shoeisha.co.jp/book/detail/9784798103853)
- [失敗から学ぶ RDBの正しい歩き方](https://gihyo.jp/book/2019/978-4-297-10408-5)

### 参考資料

1. [Refactoring Databases: Evolutionary Database Design](https://www.oreilly.com/library/view/refactoring-databases-evolutionary/0321293533/) - Database Smellsについて記載
2. データベースリファクタリングについての参考記事：<https://soudai.hatenablog.com/entry/database-refactoring-double-write>
3. PostgreSQLのALTER TABLEのロックレベル：<https://masahikosawada.github.io//2023/05/08/Lock-Levels-Of-ALTER-TABLE/>
4. データベース学習資料まとめ：<https://zenn.dev/rebi/articles/28c7f1fee5730a>
