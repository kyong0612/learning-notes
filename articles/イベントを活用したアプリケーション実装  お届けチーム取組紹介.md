---
title: "イベントを活用したアプリケーション実装 | お届けチーム取組紹介"
source: "https://product.10x.co.jp/entry/2025/10/15/133107"
author:
  - "ryota_suzuki_10X"
published: 2025-10-15
created: 2025-10-17
description: |
  10Xのお届けチームによる、イベント駆動アーキテクチャの実装についての詳細な解説。書き込み系でのイベント発生のパターン、Firestoreへの永続化戦略、参照系でのスナップショット活用、集計データの構築方法など、実際のコード例を交えながらCQRS+ESに近い設計思想を紹介。
tags:
  - "event-driven-architecture"
  - "CQRS"
  - "event-sourcing"
  - "Firestore"
  - "domain-driven-design"
  - "async-processing"
  - "10X"
  - "Stailer"
  - "software-architecture"
---

## 概要

10XのStailerプロダクトにおけるお届けチーム（ピッキング・配送領域を担当）が、イベント駆動アーキテクチャを採用した実装について解説した記事。書き込み系と参照系それぞれでイベントをどのように扱っているかを、実際のDartコード例を交えながら詳しく説明しています。

## 書き込み系の実装

### イベント駆動の基本パターン

書き込み系では、ステートフルなモデル（例：`Picking`）がライフサイクル上の出来事としてイベントを発生させます。イベントは業務に近い言葉で定義され、システム寄りの用語を避けています。

**イベント発生の3段構成：**

1. **入力の検証** - 操作が可能な状態かを確認
2. **イベントの生成** - 現在の状態と入力からイベントを生成
3. **自分へのイベントの適用** - イベントを元に状態遷移を実行

```dart
class Picking {
  PickingItemPicked pick(PickedItemAmount pickedAmount, {required bool withImmediatelyPack}) {
    // 1. 入力の検証
    if (pickingItems.progressAmount(requestedAmount).isPickingItemsOperationFinished()) {
      throw Error('pickingItemsOperation is already finished');
    }

    // 2. イベントの生成 & 3. 自分へのイベントの適用
    return apply(PickingItemPicked(
      attribute: _nextAttribute,
      beforeChangeAmount: pickingFinishCondition().progressAmount(),
      pickingItems: pickingItems.pick(pickedAmount: pickedAmount, withoutScan: withoutScan),
      changedAmount: changedItems.progressAmount(requestedAmount),
      withImmediatelyPack: withImmediatelyPack,
    ));
  }
}
```

### メリット：「状態遷移あるところにはイベントあり」

この実装パターンにより、以下が保証されます：

- 状態遷移が起きるたびに必ずイベントが記録される
- データ分析時に「操作のデータがない」という事態を防げる
- GAなどの外部ツールへの「送り忘れ」や「データ不整合」を防止

### Firestoreへの永続化戦略

Stailerでは**スナップショット方式**を採用しています。

```dart
class PickingRepositoryOnFirestore implements PickingRepository {
  Future<void> store(FirestoreTransaction tx, Picking picking) async {
    final pickingDto = PickingFirestoreDto.fromPicking(picking);
    
    // スナップショット（現在の状態）を永続化
    tx.update(pickingDto, createIfNotExist: true);

    // イベントも別途保存（protobuf形式のJSON）
    for (final event in picking.occurredEvents) {
      tx.create(PickingEventProtoTranslate().toProtoFormat(event));
    }
  }
}
```

**スナップショットを採用する理由：**

- ピッキング業務は高頻度のwrite操作が発生
- 常に最新状態を参照できることでFirestoreとのやり取りが最小化
- 全イベントの再生が不要になりパフォーマンスが向上

**注意点：**

- すべてのモデルがスナップショットを取るわけではない
- モデルの特性（書き込み頻度など）に応じて判断

## 参照系の実装

### スナップショットの活用

書き込み系で保存したスナップショットを参照系でも活用しています。厳密なCQRS+ESではありませんが、現状問題がないためこの方針を採用。

```dart
class PickingRepositoryOnFirestore implements PickingRepository {
  Future<List<Picking>> listOriginLabelPrintReadyPickingsByPickingOrderId(
    PickingOrderId pickingOrderId,
  ) {
    // スナップショットから必要なデータを取得
    final pickingDtoStream = _firestore.listAll(
      PickingFirestoreDto.reference,
      where: [
        PickingFirestoreDto.filterOfSamePickingOrderId(pickingOrderId),
        PickingFirestoreDto.filterOfProductOriginLabelPrintReady(),
        PickingFirestoreDto.filterOfNonCancelledPicking(),
      ],
    );

    // モデルに変換して返す
    return pickingDtoStream.map((dto) => dto.toPicking()).toList();
  }
}
```

**パフォーマンス最適化：**

- 必要なフィールドのみを取得する専用の読み込みモデルを定義
- 全フィールドを取得せず、`select`で絞り込み

```dart
Future<List<PickingProgressByProduct>> listPickingProgressesByProduct(
  List<PickingOrderId> pickingOrderIds) {
  final dtoStream = _firestore.listAllWithContainedIn(
    PickingProgressByProductDto.reference,
    containedIn: ('pickingOrderId', pickingOrderIds.map((id) => id.toString()).toList()),
    where: [PickingFirestoreDto.filterOfNonCancelledPicking()],
    // 必要なフィールドのみ取得
    select: PickingProgressByProductDto.requireFields,
  );
  return dtoStream.map((dto) => dto.toModel()).toList();
}
```

### 集計データの構築

日次集計のような集計データはイベントを取り込んで構築します。

**イベントベースの集計のメリット：**

1. **モデルの肥大化を防ぐ** - 集計用の不要なフィールドをモデルに持たせなくて済む
2. **認知負荷の軽減** - nullableなフィールドが増えることによる複雑性を回避
3. **シンプルな実装** - イベントに含まれる発生日時を元に判断するだけ

**比較例：**

❌ **モデルに集計用フィールドを持たせる場合**

```dart
class Picking {
  final ProductId productId;
  final DateTime? lastStockoutAt; // 集計のためだけに必要
}

class DailySummary {
  void addSummaryWhenStockout(Picking picking) {
    // pickingがlastStockoutAtを持っていることを信じる必要がある
    if (picking.lastStockoutAt!.isAfter(alreadyRecordedTime)) {
      _lastStockoutTimes.add(picking.lastStockoutAt);
    }
  }
}
```

✅ **イベントから集計する場合**

```dart
class PickingItemStockout {
  final PickingId pickingId;
  final ProductId productId;
  final DateTime occurrenceTime;
}

class DailySummary {
  void addSummaryWhenStockout(PickingItemStockout stockout) {
    final alreadyRecordedTime = _lastStockoutTimes.get(stockout.productId);
    if (stockout.occurrenceTime.isAfter(alreadyRecordedTime)) {
      _lastStockoutTimes.add(stockout.occurrenceTime);
    }
  }
}
```

## 全体設計の考え方

### CQRS+ESとの関係

- イベントをアプリケーションの中心に据える設計
- CQRS+ESに近い構造に自然と収束
- 厳密な分離は目指していないが、参考にしている
- **重要な境界線：** Command側にQuery側の関心が混入する一線を超えないよう注意

### 推奨リソース

記事では『[オブジェクト設計スタイルガイド](https://www.oreilly.co.jp/books/9784814400331/)』を紹介。

**本の特徴：**

- イベントを使いつつ、完全なCQRS+ESまでやらなくてもメリットがある、という立場
- オブジェクト指向に限らず参考になる内容
- 段階的な導入を検討している場合に有用

### 実装上の注意点

1. **Firestoreとの相性** - 集計データは事前に作成する方が扱いやすい
2. **スナップショットの選択** - モデルの特性に応じて判断
3. **境界の意識** - Command/Query間の関心の混入に敏感になる
4. **業務言語の重視** - イベント名は業務に近い言葉で定義

## 参考記事

記事内で言及されている関連記事：

- [イベント駆動設計を支える非同期処理について](https://product.10x.co.jp/entry/2025/05/30/093811)
- [お届けチームがイベント駆動アーキテクチャを採用した理由](https://product.10x.co.jp/entry/2025/03/26/105353)
- [技術的チャレンジへつながるピックパックのモジュール化](https://product.10x.co.jp/entry/2025/04/10/150702)
- [アクターシステムに頼らずEvent Sourcingする方法について](https://speakerdeck.com/j5ik2o/akutasisutemunilai-razuevent-sourcingsurufang-fa-nituite)
- [Akka Platform GuideのMemory Image Pattern](https://doc.akka.io/libraries/guide/concepts/memory-image-pattern.html#sharded_entities)

## まとめ

10Xのお届けチームは、イベント駆動アーキテクチャを採用することで以下を実現しています：

1. **データの一貫性** - 状態遷移とイベント記録の一体化
2. **分析基盤の充実** - すべての業務イベントが自動的に記録される
3. **保守性** - モデルの肥大化を防ぎ、関心の分離を維持
4. **パフォーマンス** - スナップショット戦略による効率的なデータアクセス

完全なCQRS+ESではなく、チームの状況に合わせて実用的な設計判断を行いながら、イベント中心の設計のメリットを享受している事例といえます。
