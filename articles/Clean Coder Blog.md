---
title: "Clean Coder Blog"
source: "https://blog.cleancoder.com/uncle-bob/2019/06/16/ObjectsAndDataStructures.html"
author:
  - "Robert C. Martin (Uncle Bob)"
published: 2019-06-16
created: 2025-09-01
description: |
  オブジェクトとデータ構造の違いについての考察。オブジェクトが振る舞いをカプセル化するのに対し、データ構造はデータを公開する。この違いが、新しい型や関数の追加のしやすさ、そしてソースコードの依存関係の方向にどのように影響するかを論じている。
tags:
  - "clippings"
  - "Object-Oriented Programming"
  - "Data Structures"
  - "Software Design"
  - "Dependency Inversion"
  - "Clean Code"
---

# クラス vs データ構造

> *クラスとは何ですか？*

クラスとは、類似したオブジェクトの集合の仕様です。

> *オブジェクトとは何ですか？*

オブジェクトとは、カプセル化されたデータ要素を操作する関数の集合です。

> *というより、オブジェクトとは、*暗黙の*データ要素を操作する関数の集合です。*

*暗黙の*データ要素とはどういう意味ですか？

> *オブジェクトの関数は、いくつかのデータ要素の存在を暗黙的に示しますが、そのデータはオブジェクトの外部から直接アクセスしたり、見たりすることはできません。*

データはオブジェクトの内部にあるのではないのですか？

> *そうかもしれませんが、そうでなければならないというルールはありません。ユーザーの視点から見ると、オブジェクトは関数の集合に過ぎません。それらの関数が操作するデータは存在しなければなりませんが、そのデータの場所はユーザーにはわかりません。*

ふーむ。なるほど、一旦はそれで納得しておきましょう。

> *よろしい。では、データ構造とは何ですか？*

データ構造とは、まとまりのあるデータ要素の集合です。

> *言い換えると、データ構造とは、暗黙の関数によって操作されるデータ要素の集合です。*

なるほど、なるほど。理解しました。データ構造を操作する関数はデータ構造によって指定されませんが、データ構造の存在はいくつかの操作が存在しなければならないことを暗黙的に示しているわけですね。

> *その通り。さて、これら2つの定義について何か気づくことはありますか？*

なんだか正反対のようですね。

> *その通り。それらは互いに補完的な関係にあります。手袋に手を入れるように、ぴったりと合います。*

> * *オブジェクトとは、暗黙のデータ要素を操作する関数の集合です。*
> * *データ構造とは、暗黙の関数によって操作されるデータ要素の集合です。*

すごい、じゃあオブジェクトはデータ構造ではないんですね。

> *正解です。オブジェクトはデータ構造の正反対です。*

では、DTO（Data Transfer Object）はオブジェクトではないのですか？

> *正解です。DTOはデータ構造です。*

ということは、データベースのテーブルもオブジェクトではないのですね？

> *その通り。データベースにはデータ構造が含まれており、オブジェクトは含まれていません。*

しかし、待ってください。ORM（Object Relational Mapper）はデータベースのテーブルをオブジェクトにマッピングするのではないのですか？

> *もちろん違います。データベースのテーブルとオブジェクトの間にマッピングは存在しません。データベースのテーブルはデータ構造であり、オブジェクトではありません。*

では、ORMは何をするのですか？

> *データ構造間でデータを転送します。*

では、オブジェクトとは何の関係もないのですか？

> *全くありません。Object Relational Mapperなどというものは存在しません。なぜなら、データベースのテーブルとオブジェクトの間にマッピングは存在しないからです。*

でも、ORMは私たちのビジネスオブジェクトを構築してくれると思っていました。

> *いいえ、ORMは私たちのビジネスオブジェクトが操作するデータを抽出します。そのデータはORMによってロードされたデータ構造に含まれています。*

では、ビジネスオブジェクトはそのデータ構造を含んでいるのですか？

> *そうかもしれないし、そうでないかもしれません。それはORMの仕事ではありません。*

それは些細な意味論的な問題のように思えます。

> *全く違います。この区別には重要な意味があります。*

例えば？

> *例えば、データベーススキーマの設計とビジネスオブジェクトの設計です。ビジネスオブジェクトはビジネスの*振る舞い*の構造を定義します。データベーススキーマはビジネス*データ*の構造を定義します。これら2つの構造は、全く異なる力によって制約されます。ビジネスデータの構造は、必ずしもビジネスの振る舞いにとって最適な構造ではありません。*

ふーむ。それは混乱しますね。

> *こう考えてみてください。データベーススキーマは1つのアプリケーションのためだけに調整されているわけではありません。企業全体にサービスを提供しなければなりません。ですから、そのデータの構造は多くの異なるアプリケーション間の妥協点なのです。*

なるほど、それは理解できます。

> *よろしい。では、個々のアプリケーションを考えてみましょう。各アプリケーションのオブジェクトモデルは、それらのアプリケーションの振る舞いがどのように構造化されているかを記述します。各アプリケーションは、そのアプリケーションの振る舞いに合わせて調整された、異なるオブジェクトモデルを持つことになります。*

ああ、わかりました。データベーススキーマは様々なアプリケーションの妥協点なので、そのスキーマは特定のアプリケーションのオブジェクトモデルには適合しないのですね。

> *その通り！オブジェクトとデータ構造は全く異なる力によって制約されます。それらがうまく一致することはめったにありません。かつて人々はこれをオブジェクト/リレーショナルのインピーダンスミスマッチと呼んでいました。*

それは聞いたことがあります。でも、そのインピーダンスミスマッチはORMによって解決されたと思っていました。

> *そして今、あなたは違うと知りました。オブジェクトとデータ構造は同形ではなく補完的であるため、インピーダンスミスマッチは存在しません。*

どういうことですか？

> *それらは似たような実体ではなく、正反対のものです。*

正反対？

> *はい、非常に興味深い形で。オブジェクトとデータ構造は、正反対の制御構造を暗示しているのです。*

待ってください、どういうことですか？

> *共通のインターフェースに準拠するオブジェクトクラスの集合を考えてみてください。例えば、形状の`area`（面積）と`perimeter`（周囲長）を計算する関数を持つ、二次元の形状を表すクラスを想像してみてください。*

なぜソフトウェアの例はいつも形状が関わってくるのですか？

> *`Square`（正方形）と`Circle`（円）という2つの異なる型だけを考えてみましょう。これら2つのクラスの`area`と`perimeter`関数が、異なる暗黙のデータ構造を操作することは明らかでしょう。また、それらの操作が動的ポリモーフィズムを介して呼び出されることも明らかです。*

待ってください。ゆっくりお願いします。何ですって？

> *`area`関数は2つあります。1つは`Square`用、もう1つは`Circle`用です。呼び出し元が特定のオブジェクトの`area`関数を呼び出すと、どの関数を呼び出すかを知っているのはそのオブジェクト自身です。これを動的ポリモーフィズムと呼びます。*

なるほど。確かに。オブジェクトは自身のメソッドの実装を知っている。確かに。

> *では、それらのオブジェクトをデータ構造に変えてみましょう。判別共用体（Discriminated Unions）を使います。*

判別…なんですか？

> *判別共用体です。この場合、それは`Square`用と`Circle`用の2つの異なるデータ構造にすぎません。`Circle`のデータ構造には、中心点と半径というデータ要素があります。また、それが`Circle`であることを識別するための型コードも持っています。*

enumのようなものですか？

> *ええ。`Square`のデータ構造には、左上の点と辺の長さがあります。また、型判別子、つまりenumも持っています。*

なるほど。型コードを持つ2つのデータ構造ですね。

> *その通り。では、`area`関数を考えてみてください。その中にはswitch文がありますよね？*

ええと。確かに、2つの異なるケースのために。1つは`Square`用、もう1つは`Circle`用です。そして`perimeter`関数も同様のswitch文が必要になりますね。

> *その通り。さて、これら2つのシナリオの構造について考えてみましょう。オブジェクトのシナリオでは、`area`関数の2つの実装は互いに独立しており、型に（ある意味で）属しています。`Square`の`area`関数は`Square`に属し、`Circle`の`area`関数は`Circle`に属します。*

なるほど、どこへ向かっているか分かってきました。データ構造のシナリオでは、`area`関数の2つの実装は同じ関数の中に一緒にあり、型には「属して」いませんね（その言葉がどういう意味であれ）。

> *さらに良いことがあります。オブジェクトのシナリオに`Triangle`（三角形）型を追加したい場合、どのコードを変更する必要がありますか？*

コードの変更はありません。新しい`Triangle`クラスを作成するだけです。ああ、インスタンスの作成者を変更する必要があるかもしれませんね。

> *その通り。新しい型を追加しても、変更はほとんどありません。では、新しい関数、例えば`center`関数を追加したい場合はどうでしょう。*

その場合は、`Circle`、`Square`、`Triangle`の3つの型すべてにそれを追加する必要があります。

> *よろしい。新しい関数を追加するのは大変で、各クラスを変更する必要があります。*

しかし、データ構造では違います。`Triangle`を追加するためには、各関数を変更してswitch文に`Triangle`のケースを追加する必要があります。

> *その通り。新しい型を追加するのは大変で、各関数を変更する必要があります。*

でも、新しい`center`関数を追加するときは、何も変更する必要はありません。

> *そうです。新しい関数を追加するのは簡単です。*

すごい。全くの正反対ですね。

> *まさにその通りです。レビューしましょう：*

> * *クラスの集合に新しい関数を追加するのは大変で、各クラスを変更する必要がある。*
> * *データ構造の集合に新しい関数を追加するのは簡単で、関数を追加するだけで他は何も変更されない。*
> * *クラスの集合に新しい型を追加するのは簡単で、新しいクラスを追加するだけである。*
> * *データ構造の集合に新しい型を追加するのは大変で、各関数を変更する必要がある。*

ええ。正反対。興味深い形で正反対ですね。つまり、型の集合に新しい関数を追加することが分かっているなら、データ構造を使いたいでしょう。しかし、新しい型を追加することが分かっているなら、クラスを使いたいでしょう。

> *良い観察です！しかし、今日私たちが考えるべき最後のことがもう1つあります。データ構造とクラスが正反対である別の方法がまだあります。それは依存関係に関することです。*

依存関係？

> *はい、ソースコードの依存関係の方向です。*

なるほど、食いつきますよ。違いは何ですか？

> *データ構造のケースを考えてみてください。各関数には、判別共用体内の型コードに基づいて適切な実装を選択するswitch文があります。*

なるほど、それは本当ですが、それがどうしたのですか？

> *`area`関数の呼び出しを考えてみてください。呼び出し元は`area`関数に依存し、`area`関数はすべての具体的な実装に依存します。*

「依存する」とはどういう意味ですか？

> *`area`の各実装が、それぞれ独自の関数に書かれていると想像してください。つまり、`circleArea`、`squareArea`、`triangleArea`があるわけです。*

なるほど、switch文は単にそれらの関数を呼び出すだけですね。

> *それらの関数が異なるソースファイルにあると想像してください。*

すると、switch文を持つソースファイルは、それらすべてのソースファイルをインポート、またはuse、またはincludeしなければならなくなります。

> *その通り。それがソースコードの依存関係です。あるソースファイルが別のソースファイルに依存します。その依存関係の方向はどちらですか？*

switch文を持つソースファイルが、すべての実装を含むソースファイルに依存します。

> *そして、`area`関数の呼び出し元についてはどうですか？*

`area`関数の呼び出し元は、switch文を持つソースファイルに依存し、そのソースファイルはすべての実装に依存します。

> *正解です。すべてのソースファイルの依存関係は、呼び出しの方向、つまり呼び出し元から実装へと向かいます。ですから、それらの実装の1つに小さな変更を加えると…*

なるほど、どこへ向かっているか分かってきました。実装のいずれか1つへの変更は、switch文を持つソースファイルの再コンパイルを引き起こし、それはそのswitch文を呼び出す誰もが、この場合は`area`関数ですが、再コンパイルされる原因となります。

> *その通り。少なくとも、どのモジュールをコンパイルすべきかを判断するためにソースファイルの日付に依存する言語システムではそうです。*

それは静的型付けを使用するほとんどすべてですよね？

> *はい、そしてそうでないものもいくつかあります。*

それはたくさんの再コンパイルですね。

> *そして、たくさんの再デプロイです。*

なるほど、しかしこれはクラスの場合は逆になるのですか？

> *はい、なぜなら`area`関数の呼び出し元はインターフェースに依存し、実装関数もそのインターフェースに依存するからです。*

あなたの言う意味が分かります。`Square`クラスのソースファイルは、`Shape`インターフェースのソースファイルをインポート、またはuse、またはincludeします。

> *その通り。実装のソースファイルは、呼び出しの方向とは反対の方向を指します。それらは実装から呼び出し元へと向かいます。少なくとも、静的型付け言語ではそうです。動的型付け言語では、`area`関数の呼び出し元は全く何も依存しません。リンケージは実行時に解決されます。*

なるほど。OK。では、実装の1つに変更を加えると…

> *変更されたファイルだけが再コンパイルまたは再デプロイされる必要があります。*

そして、それはソースファイル間の依存関係が呼び出しの方向とは逆を向いているからですね。

> *その通り。これを依存性逆転と呼びます。*

OK、ではまとめられるか試してみます。クラスとデータ構造は、少なくとも3つの異なる方法で正反対です。

* クラスは関数を可視にし、データを暗黙的に保ちます。データ構造はデータを可視にし、関数を暗黙的に保ちます。
* クラスは型の追加を容易にしますが、関数の追加を困難にします。データ構造は関数の追加を容易にしますが、型の追加を困難にします。
* データ構造は呼び出し元を再コンパイルと再デプロイにさらします。クラスは呼び出し元を再コンパイルと再デプロイから隔離します。

> *その通りです。これらは、すべての優れたソフトウェア設計者とアーキテクトが心に留めておくべき問題です。*
