# Why pg_dump Is Amazing

ref: <https://rhaas.blogspot.com/2024/11/why-pgdump-is-amazing.html>

Title: Why pg_dump Is Amazing

- **人間が読めるアウトプット**: pg_dump は人間が読めるテキスト形式のアウトプットを生成するため、物理的なバックアップと比べてデータベースオブジェクトの再作成やテーブルデータの再読み込みが容易になります。
- **物理的バックアップの制限**: 物理的バックアップはPostgreSQLの内部フォーマットに依存しているため、他のシステムや異なるバージョンのPostgreSQLへのデータ移行が複雑になる可能性があります。
- **データ処理の柔軟性**: pg_dumpでは選択的なバックアップと復元が可能で、ユーザーは全データベースではなく特定のテーブルやオブジェクトをターゲットにできます。
- **依存関係の管理**: pg_dumpは、データベーススキーマを再作成する際に依存関係を賢明に管理するため、ユーザーが手動でスキーマを再作成する複雑さを軽減します。
- **エラーのトラブルシューティング**: メジャーバージョンアップグレード時に発生する問題は、物理的バックアップよりも pg_dump を使うことで、より簡単に診断および解決できることがあります。
- **データ破損の回復**: pg_dumpは、まだ読み取り可能なテーブルをダンプして復元することで、影響を受けたデータを回復する方法を提供し、データ破損を排除することができます。
- **バックアップと復元のオプション**: このツールはさまざまなバックアップ形式(tar、カスタムなど)をサポしており、復元プロセスの際の柔軟性を高めています。
- **エンジニアリングの複雑さ**: pg_dumpの開発には、SQLおよびデータ依存関係の複雑さに対処するための多大な努力が必要とされています。
- **日常的ではない作業に不可欠**: 日常的なバックアップには適していませんが、非標準のシナリオや複雑なデータベース管理タスクを処理する際には、pg_dumpは不可欠です。
- **信頼性と有用性**: pg_dumpは、PostgreSQLユーザーにとって最も信頼性の高く有用なツールの1つとして位置づけられており、必須のデータベース管理ツールの1つと言えます。

---

数週間前に「pg_dumpはバックアップツールか？」というタイトルのブログ記事を書きました。その投稿では、肯定的に主張しましたが、同時にそれがあなたの主要なバックアップメカニズムであるべきではないとも言いました。そのためには、PostgreSQL自体に含まれているものを直接使用するのではなく、barmanやpgbackrestのようなよくメンテナンスされたサードパーティのバックアップツールを使用するべきです。しかし今日は、pg_dumpがPostgreSQL関連のさまざまな問題を解決するために驚くほど便利であり、また素晴らしい技術であると信じる理由についてもう少し話したいと思います。

pg_dumpの核心的な価値提案は、出力が人間が読めるテキストであることです。データベースオブジェクトを再作成するために使用できるDDLコマンドや、テーブルデータを再ロードするために使用できるCOPYコマンド（またはINSERT、リクエストがあれば）を得ることができます。これは、データベースクラスター全体をバックアップおよび復元しようとしている場合には本当に利点ではありません。なぜなら、PostgreSQLの内部フォーマットからテキストに変換し、再び戻すのには多くのCPUリソースを使用するからです。代わりに物理バックアップを取得して復元すれば、そのオーバーヘッドを回避できます。

しかし、他の何かをしようとしている場合はどうでしょうか？物理バックアップが全く役に立たない状況はたくさんあります。すべてのデータがPostgreSQLの内部フォーマットに保存されているため、そのデータは互換性のあるPostgreSQLのバージョンでしか使用できません。したがって、PostgreSQL以外のシステムにデータを移行したい場合や、異なるメジャーバージョンのPostgreSQLにデータを移行したい場合、その物理バックアップは役に立ちません。実際、異なるCPUアーキテクチャに切り替えるだけでも、その物理バックアップはおそらく役に立たないでしょう。整数や浮動小数点数などの値はCPUのネイティブフォーマットを使用して表現されており、それが異なる場合、ディスク上のフォーマットは互換性がありません。

さて、pg_dumpはこれらの問題を自動的に解決するわけではありません。たとえば、非PostgreSQLシステムが修正されていないpg_dumpの出力をエラーなしに処理できる可能性は低いですが、SQLの素晴らしい点は、自分でテキストエディタやスクリプトを使って修正できることです。同様に、pg_dumpを使用したメジャーバージョンのアップグレードは遅くなる可能性があり、たとえば、システムカタログの列に依存するビューを作成している場合、新しいリリースでその列が削除されていると、失敗することもあります。しかし、これは自分でトラブルシューティングして修正できる可能性が高い問題であり、物理バックアップのトラブルとは対照的に、自分で修正できないし、修正すべきではありません。（注：ダンプを再ロードする際、ダンプを作成する際に古いバージョンのpg_dumpを使用すると失敗することもあるので、それは避けてください。新しいバージョンを使用してください。中には、pg_upgradeではなくpg_dumpをメジャーバージョンのアップグレードに使用すべきだと考えている方もいるかもしれませんが、pg_dumpが内部で使用されていることを忘れないでください。）

物理バックアップが役に立つ場合もありますが、論理ダンプの方がはるかに優れている可能性があります。たとえば、単一のテーブルや関数定義のような他のタイプの単一オブジェクトをバックアップおよび復元したい場合があります。これに物理バックアップを使用すると、データベースクラスター全体を復元し、その後必要なオブジェクトを抽出する必要があります...おそらくpg_dumpを使用して。しかしpg_dumpを使用すれば、選択的に行うことができます。pg_dumpには、ダンプに含まれるものを制御するために使用できる長いオプションリストがあります。これは素晴らしいことですが、実際の魔法は復元側で起こります。ダンプがtar形式（pg_dump -Ft）またはカスタム形式（pg_dump -Fc）で取得されると、pg_restoreは復元したいオブジェクトを正確に選び出して復元できます。pg_restoreコマンドラインで直接行えるフィルタリングに加えて、pg_restoreの非常に強力で柔軟な-L、--use-listオプションを見逃さないでください。（公平を期すために、いくつかのアウトオブコアバックアップソリューションも選択的なダンプと復元を提供していますが、私の知る限り、pg_dumpとpg_restoreでできることほど強力なものはありません。さらに、それらはPostgreSQL自体がサポートされていないシナリオと見なすことを行うため、ツールの作成者がすべてのリスクを認識していることを本当に願う必要があります。）

pg_dumpがこれらのオプションを提供できる理由は、出力がテキスト形式であるからです。PostgreSQLのバイナリ形式では、データはすべて絡み合っています。たとえば、ネイティブバイナリ形式では、各テーブル行はMVCCをサポートするために使用される可視性情報と一緒に保存され、その可視性情報は本質的にデータディレクトリの他の場所に保存されているファイルで参照される数字の集まりです。したがって、そのファイルを拾って、他のファイルの内容が異なる別のデータベースクラスターにドロップすることはできません。また、PostgreSQLは物理バックアップが取得されている間、データファイルへの書き込みをロックしないため、データディレクトリはリカバリが実行されるまで不整合な状態になります。これにより、特定のテーブルを特定したり、物理バックアップからその内容を抽出したりする良い方法はありません。適切な構成でサーバーを起動し、リカバリにすべてを整理させる必要があります。ダンプは論理的であるため、これらの問題はありません。データはアクセス可能にすることを意図した方法で保存されており、データベース操作を効率的にすることを意図した方法ではありません。

テキスト形式への変換とその逆は、内部バイナリ形式の破損を排除する方法としても使用できます。たとえば、タプルのxminがリレーションのrelfrozenxidよりも小さい行を含むデータベーステーブルがあると想像してくださいが、残念ながらそのタプルはフリーズされていません。言い換えれば、破損したデータベースがあります。これがあなたに起こらないことを願っていますし、もし起こった場合は、影響を受けていないレプリカにフェイルオーバーするか、破損していないバックアップから復元できることを願っています。しかし、この種の破損は、破損にもかかわらずデータベースがまだ読み取り可能であるため、比較的長い期間検出されないことが簡単です。したがって、問題が認識される頃には、すべてのレプリカとバックアップが影響を受けている可能性があります。しかし、ある日、システムはもはや必要ないと思われる古いclogファイルを削除し、その瞬間にデータが読み取れなくなります。明らかに、私はこの例を選んでポイントを証明しました。なぜなら、PostgreSQLがディスク上でデータをどのように表現しているかの詳細に精通していなくても、影響を受けたテーブルをダンプして復元する解決策が、データがまだ読み取れる時点であることがわかるからです。実際、これはデータベースのダンプと物理バックアップが実際の問題を解決するために手を取り合って機能する方法を示しています。ある日、テーブルが突然読み取れなくなったとき、データがまだ読み取れた物理バックアップから復元し、その後pg_dumpを使用してデータを取り出し、好きな場所に再ロードできます。（このような複雑なシナリオでは、PostgreSQLインスタンスに商業サポートを求めることをお勧めします。そうでない場合は、あなた自身がそのような問題の専門家でない限り。私の雇用主からそのようなサポートを受けることができます。）

しかし、今度はpg_dumpが小さなエンジニアリングの驚異である理由について話しましょう：依存関係です。別のサーバーでデータベーススキーマを手動で再作成しようとしたことはありますか？もしあれば、それは全く楽しくないことを発見したことでしょう。たとえば、テーブルを作成しようとすると、そのテーブルがまだ存在しない他のテーブルへの外部キーを持っているために失敗することがあります。正しい順序で物事を再作成する必要がありますが、その正しい順序がわかりません。時には、どのテーブルを最初に作成しても、何らかの理由で失敗する循環依存関係があるかもしれません。その場合、外部キーや制約、インデックスのような付随するオブジェクトなしで最初にテーブルを作成し、他のデータベースオブジェクトを設定した後にそれらを追加することで依存関係の問題を解決する必要があるかもしれません。そして素晴らしいことは、これらすべてを自分で行う代わりに、pg_dumpを実行すればそれを解決してくれることです。データだけでなくスキーマもダンプしている場合、pg_dumpはデータの復元ができるだけ効率的になるように、データのロード後にインデックスの作成を延期することでダンプを整理します。これにより、DBAの時間とエネルギーを大幅に節約できます。

さて、誰かがpg_dumpがすべてのケースで依存関係の問題を100％信頼性を持って解決しないことを指摘するだろうと思います。そしてそれは正しいです。しかし、その不満はPostgreSQLユーザーがどれほど甘やかされているかを示していると思います。依存関係を意識したツールなしで複雑なデータベーススキーマを再作成することは絶対的な悪夢です。pg_dumpを使用すれば、通常は簡単です。それが簡単でない場合やユーザーの介入が必要な場合は、確かに面倒ですが、pg_dumpを放棄して自分の手作りのコードですべてを行っても、もっと楽しくはないと自信を持っています。非常に賢い人々、主にトム・レーンによって、この作業がこれほどうまく機能するように多くの時間とエネルギーが注がれています。そして、残っている問題のいくつかは、停止問題を解決しない限り解決できません。SQLは非常に非常に複雑です。そして、pg_dumpが依存関係の問題を解決するのと同じように解決することは非常に難しいです。

要約すると、pg_dumpはほぼすべての複雑なバックアップシナリオに対処するための優れたツールだと感じています。ルーチンのバックアップと復元には他のオプションが一般的に優れていますが、非ルーチンの状況になると、pg_dumpは少なくとも私の経験では絶対に不可欠なツールになります。面倒だったことが簡単になり、不可能だったことが少なくとも可能になります。pg_dumpは、私の最も信頼性が高く、一般的に役立つPostgreSQLツールの短いリストに載っています。もしあなたのリストに載っていないなら、載せるべきかもしれません！
