# How Vercel adopted microfrontends

ref: <https://vercel.com/blog/how-vercel-adopted-microfrontends>

Vercelがどのようにしてビルド時間を短縮し、開発者の速度を向上させながら、マイクロフロントエンドでスムーズなユーザー体験を維持したかを学びましょう。

Vercelのメインウェブサイトは、かつては単一の大規模なNext.jsアプリケーションでしたが、ウェブサイトの訪問者とログインしたダッシュボードの両方にサービスを提供しています。しかし、Vercelが成長するにつれて、この設定は改善の機会を明らかにしました。ビルド時間が増加し、依存関係の管理がより複雑になり、ワークフローの最適化が必要になりました。小さな変更がフルビルドを引き起こし、孤立した開発やCIパイプラインに影響を与えました。

変化が必要であることは明らかでした。

アーキテクチャを再考することで、垂直マイクロフロントエンドに移行し、よりシンプルな開発体験を実現し、プレビューのビルド時間とローカル開発のコンパイルで40％以上の改善を達成しました。他のマイクロフロントエンドのコードを削除することで依存関係を簡素化し、ページの重さを減らし、エンドユーザーのパフォーマンスを向上させ、Largest Contentful Paint (LCP) や Interaction to Next Paint (INP) などのCore Web Vitalsでの向上を実現しました。

Vercelのマイクロフロントエンドのサポートを基に、このオーバーホールは開発者体験（DX）を改善し、さらなる最適化のための領域を明らかにしました。大規模アプリの移行を通じてのドッグフーディングにより、私たちのシフトはすべてのユーザーのためにプラットフォームを合理化する新しい方法を明らかにしました。このブログは私たちの旅を共有するだけでなく、すべての人のためにプロセスをスムーズにする方法も示しています。私たちが引き続き洗練を進める中で、単一のアプリケーションのビルドをより速くし、エンドユーザーのパフォーマンスを損なうことなく、さらなるDXを実現しています。

私たちがどのようにそれを実現したかを見てみましょう。

## Turboを利用する

私たちの最初のステップは、ローカルコンパイル、ビルド時間、CIワークフローの改善に焦点を当てることでした。VercelのモノレポはTurborepoによって支えられており、Vercel Remote Cacheや--affectedのような機能を使ってタスクを最適化することができました。Turbopackを採用することで、ローカル開発の速度が大幅に向上しました。

しかし、これらの改善を進める中で、Vercel.comにとってシングルアプリモデルはもはや必要ないことに気付きました。アプリケーション内の論理的な分割により、すべてのビルドとコンパイルでの不必要な作業を回避でき、さらに大きな開発者の生産性向上を実現しました。

## 水平または垂直の分割の重み付け  

マイクロフロントエンドは、大規模なアプリケーションを小さく独立したユニットに分解する方法を提供し、製品領域やエンジニアリングチーム間での並行開発を可能にします。単一のアプリケーションは一貫性がありますが、マイクロフロントエンドは、アプリケーションと組織が成長するにつれてスケーリングの問題に対処するのに役立ちます。主に2つの戦略があります：

- 垂直マイクロフロントエンド：パスで分割し、各ページは単一のアプリによって処理されます
- 水平マイクロフロントエンド：機能で分割し、複数のアプリケーションが同じページで実行されます

![alt text](<assets/CleanShot 2024-11-18 at 18.51.56@2x.png>)

正解も不正解もなく、それぞれにトレードオフがあります。各アプローチは、ユースケースに応じて substantial benefits を提供できます。ルカ・メッツァリラのマイクロフロントエンドに関する本は、このトピックに関する良いリソースです。

垂直分割は一貫性を提供しますが、異なるマイクロフロントエンドによってサポートされるアプリケーション間の切り替え時に難しいナビゲーションを引き起こす可能性があります。プリフェッチやChromiumの推測ルールのようなAPIなどの技術が役立ちますが、リソース使用量の増加や限られたブラウザサポートなどの制限があります。

水平分割では、複数のマイクロフロントエンドが同じページで動作するため、テスト、リリース、監視、デバッグがより複雑になります。

私たちは垂直マイクロフロントエンドを採用しました。これは、ユーザーがほとんど交差しない論理的なセクションにアプリを分割することで、ビルド時間を短縮し、依存関係を簡素化し、統一されたモノレポを維持することを目的としています。

初期のテストでは、このアプローチがビルド時間を半分にし、開発と生産の両方で所有権を合理化できることが示され、開発者に単一のアプリケーションで作業している感覚を与えました。

## 私たちの移行パス  

次のステップは、開発やユーザー体験を妨げることなく、モノリシックなフロントエンドアプリをより小さな垂直アプリケーションに移行することでした。アプリケーションを3つのコア領域に分解しました：

- マーケティング
- ドキュメンテーション
- ログイン後のダッシュボード

これらの領域は自然に区別されていました。ユーザーはそれらの間を頻繁に行き来することはなく、それぞれが独自のユーザーインターフェースを維持しているため、分離に理想的でした。

![alt text](<assets/CleanShot 2024-11-18 at 18.53.38@2x.png>)

私たちはNext.jsを使用しているため、垂直マイクロフロントエンドをサポートするNext.jsのマルチゾーン機能を利用しました。

段階的な移行は私たちにとって優先事項でした。元のコードベースをフォークするのではなく、新しいアプリケーションを作成することを選びました。フォークは表面的には簡単に見えましたが、リスクを伴うことになります。ヘッダー、フッター、デザインシステムなどの共有コンポーネントは、複数のリポジトリで複製され、維持される必要があり、同期の問題や潜在的な不整合を引き起こす可能性がありました。

モノレポを続け、モノレポ内のパッケージにコードを集中させることで、共有コンポーネントの一貫性を確保しながら、重要な領域を簡単に、段階的に分離することができました。TurborepoやDependency Cruiserのようなツールは、このプロセスを簡素化するのに役立ちました。

![alt text](<assets/CleanShot 2024-11-18 at 18.54.29@2x.png>)

機能フラグを使用することで、まだ稼働中のモノリシックなフロントエンドアプリから新しいマイクロフロントエンドへと段階的にトラフィックをルーティングすることができました。これにより、リスクを最小限に抑え、古いコードを削除する前にパフォーマンスの向上を検証することができました。新しいページが少なくとも1週間エラーなくトラフィックを処理した後、既存のアプリケーションからコードを削除し、依存関係とビルド時間を段階的に削減しました。

![alt text](<assets/CleanShot 2024-11-18 at 18.55.00@2x.png>)

このモノレポのセットアップと垂直分割アプローチにより、私たちは自信を持ち、コントロールできていると感じました。 一貫性を保ち、ビルド時間を短縮し、アプリ開発をシンプルに保ちながら、非常に迅速に動くことができました。

## 教訓とトレードオフの管理  

Vercel.comでのマイクロフロントエンドの成功した導入の後、私たちは同じアプローチを2024 Next.js Confページなどの他のサイトにも拡張しました。このページはnextjs.orgとは別のアプリケーションとして動作します。このインフラストラクチャを使用することで、異なる領域を独立したアプリケーションに抽出でき、Next.js ConfチームとNext.js開発チームが迅速かつ独立して反復できるため、開発サイクルが加速しました。

とはいえ、課題もありました。いくつかの問題に直面し、特にSpeed Insightsのようなツールを使用して実際の使用状況を監視し、Vercel Toolbarを使用してレイアウトのシフトやインタラクションのタイミングアラートを確認することで、パフォーマンスが低下しないように努めました。

私たちは早い段階で、ローカルおよびプレビューでのマイクロフロントエンドのテストが難しいことを認識しました。ドラフトモードのような機能は正しく動作せず、ハードナビゲーションのようなパフォーマンスのボトルネックは既知の問題でした。これらの問題を解決するために、Chromiumの推測ルールを使用したプリフェッチやプリレンダリングのような戦略を採用しました。

### トレードオフを克服する例

ハードナビゲーションの影響を軽減するために、リンクが表示されるとすぐに初期ページのリソース（JavaScriptとCSS）をダウンロードしてブラウザキャッシュをプライミングします。これにより、ユーザーがナビゲートするとき、これらのアセットはキャッシュから読み込まれます。ただし、ページはまだレンダリングと残りのアセット（HTMLなど）の取得を必要とします。

ユーザーがインタラクトするとき（例：リンクをタップする）にページをプリレンダリングすることで、さらに一歩進めます。これにより、すべてのネットワークリクエストと処理を含むページがバックグラウンドでレンダリングされるため、ユーザーが到着したときには瞬時に感じられます。このアプローチは、パフォーマンスとリソース使用のバランスを取ります—デバイスの過負荷を避けつつ、望ましい体験を提供するために、適切なタイミングでのみプリフェッチとプリレンダリングを行います。

![alt text](<assets/CleanShot 2024-11-18 at 18.56.45@2x.png>)

## 前を見据えて  

イテレーション速度の向上に伴い、私たちはプラットフォーム全体でマイクロフロントエンドの強化に注力しています。私たちの焦点は、ルーティングの洗練、プレビューワークフローの合理化、ハードナビゲーションパフォーマンスの最適化にあります。また、ダッシュボード体験の向上やワークフローの課題に取り組み、マイクロフロントエンド開発を最初から最後まで改善しています。  

垂直マイクロフロントエンドへの移行は、開発者の速度を大幅に向上させ、ビルド時間を短縮しました。チームは、共有パッケージを通じて整合性を保ちながら、より独立して作業できるようになり、自律性と統一された開発のバランスを取るシステムを構築しています。  

このアーキテクチャを引き続き洗練させる中で、その可能性にワクワクしています。マイクロフロントエンドを探求している方も、単一のアプリケーションに留まる方も、Vercelは最高の開発者体験を提供することにコミットしています。
