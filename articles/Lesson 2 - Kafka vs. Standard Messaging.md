---
title: "Lesson 2 - Kafka vs. Standard Messaging"
source: "https://www.youtube.com/watch?v=lwMjjTT1Q-Q"
author:
  - "Mark Richards"
  - "[[Software Architecture Monday]]"
published: 2018-01-29
created: 2025-11-30
description: "Mark RichardsがApache Kafkaと標準的なメッセージングシステム（ActiveMQ、RabbitMQなど）の核心的な違いを説明・デモンストレーションする動画。各システムの強みと弱みを理解し、適切な選択がアーキテクチャに与える影響について解説。"
tags:
  - "Kafka"
  - "メッセージング"
  - "ActiveMQ"
  - "RabbitMQ"
  - "ソフトウェアアーキテクチャ"
  - "分散システム"
  - "イベントストリーミング"
---

## 概要

このレッスンでは、Mark RichardsがApache Kafkaと標準的なメッセージングシステム（ActiveMQ、RabbitMQなど）の核心的な違いを説明しています。各システムの強みと弱みを理解することは、適切なアーキテクチャ選択において非常に重要です。

---

## 標準的なメッセージングシステムの特徴

### 基本概念

- **プロデューサー**がメッセージを**キュー**または**トピック**に送信
- **コンシューマー**がメッセージを受信して処理
- 非同期通信を可能にし、システム間の疎結合を実現

### メッセージモデル

#### 1. Point-to-Point（キューベース）

- 1つのメッセージは1つのコンシューマーのみが受信
- メッセージは消費後にキューから削除される
- 負荷分散に適している

#### 2. Publish-Subscribe（トピックベース）

- 1つのメッセージを複数のサブスクライバーが受信可能
- ブロードキャスト型の通信パターン

### 代表的なシステム

- **ActiveMQ**: JMSをサポートするオープンソースメッセージブローカー
- **RabbitMQ**: AMQPプロトコルベースの柔軟なメッセージブローカー

---

## Apache Kafkaの特徴

### アーキテクチャの根本的な違い

```
┌─────────────────────────────────────────────────────────┐
│                     Kafka Cluster                        │
│  ┌─────────────────────────────────────────────────────┐│
│  │                    Topic                             ││
│  │  ┌───────────┐ ┌───────────┐ ┌───────────┐         ││
│  │  │Partition 0│ │Partition 1│ │Partition 2│         ││
│  │  │  offset 0 │ │  offset 0 │ │  offset 0 │         ││
│  │  │  offset 1 │ │  offset 1 │ │  offset 1 │         ││
│  │  │  offset 2 │ │  offset 2 │ │  offset 2 │         ││
│  │  │    ...    │ │    ...    │ │    ...    │         ││
│  │  └───────────┘ └───────────┘ └───────────┘         ││
│  └─────────────────────────────────────────────────────┘│
└─────────────────────────────────────────────────────────┘
```

### 核心的な特徴

1. **分散型イベントストリーミングプラットフォーム**
   - 単なるメッセージキューではなく、イベントログとして設計
   - 高スループット・低レイテンシーを実現

2. **メッセージの永続化**
   - メッセージは消費後も削除されない
   - 設定可能な保持期間（retention period）で管理
   - ディスクベースのストレージ

3. **オフセット管理**
   - 各コンシューマーが自身のオフセット（読み取り位置）を管理
   - メッセージの再処理（replay）が可能

4. **パーティションによるスケーラビリティ**
   - トピックを複数のパーティションに分割
   - パーティション内でのメッセージ順序は保証
   - 水平スケーリングが容易

---

## 主要な違いの比較

| 特性 | 標準メッセージング | Apache Kafka |
|------|-------------------|--------------|
| **メッセージ保持** | 消費後に削除 | 設定期間保持 |
| **スケーリング** | 垂直スケーリング中心 | 水平スケーリング容易 |
| **メッセージ再処理** | 困難 | オフセットで容易に可能 |
| **順序保証** | 設定依存 | パーティション内で保証 |
| **配信モデル** | プッシュ型 | プル型 |
| **スループット** | 中程度 | 非常に高い |
| **複雑性** | 比較的シンプル | 設定・運用が複雑 |

---

## コンシューマーグループ

### 標準メッセージング

- キューの場合：複数コンシューマーで負荷分散
- トピックの場合：各サブスクライバーが全メッセージ受信

### Kafka

```
┌─────────────────────────────────────────────────────────┐
│              Consumer Group A                            │
│  ┌──────────┐  ┌──────────┐  ┌──────────┐              │
│  │Consumer 1│  │Consumer 2│  │Consumer 3│              │
│  │ (P0, P1) │  │  (P2)    │  │  (P3)    │              │
│  └──────────┘  └──────────┘  └──────────┘              │
└─────────────────────────────────────────────────────────┘
                         ↓
                  各パーティションは
                グループ内の1つのコンシューマーに割当
```

- **コンシューマーグループ**により、同じトピックに対して異なる処理が可能
- グループ内では各パーティションは1つのコンシューマーにのみ割り当て
- 異なるグループは同じメッセージを独立して処理可能

---

## ユースケースの選択指針

### 標準メッセージングが適するケース

- ✅ シンプルなタスクキュー処理
- ✅ トランザクション性が重要な場面
- ✅ 小〜中規模のメッセージ処理
- ✅ 複雑なルーティングロジックが必要
- ✅ 短期的なメッセージ処理

### Kafkaが適するケース

- ✅ **リアルタイム分析・モニタリング**
- ✅ **ログ集約・イベントソーシング**
- ✅ **大規模データストリーミング**
- ✅ **メッセージの再処理が必要**
- ✅ **高スループットが求められる**
- ✅ **複数システムでの同一データ消費**

---

## 重要な結論

1. **「正しい」選択は存在しない** - ユースケースに応じた適切な選択が重要
2. **誤った選択はアーキテクチャ全体に影響** - 後からの変更は困難
3. **Kafkaは万能薬ではない** - シンプルなメッセージングには過剰な場合も
4. **ハイブリッドアプローチも有効** - 要件に応じて両方を併用することも検討

---

## 関連リソース

- [Apache Kafka 公式ドキュメント](https://kafka.apache.org/documentation/)
- [RabbitMQ 公式ドキュメント](https://www.rabbitmq.com/documentation.html)
- [ActiveMQ 公式サイト](https://activemq.apache.org/)
- [Developer to Architect](https://www.developertoarchitect.com/lessons/) - Mark Richardsのレッスンシリーズ
