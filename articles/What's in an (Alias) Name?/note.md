# What's in an (Alias) Name?

ref: <https://go.dev/blog/alias-names>

**著者**: ロバート・グリーセマー  
**公開日**: 2024年9月17日  

この記事では、ジェネリックエイリアスタイプについて、それが何であり、なぜ必要なのかを解説します。

---

#### 背景

Goは、大規模なプログラミングを目的として設計されました。大規模なプログラミングとは、大量のデータだけでなく、大規模なコードベースを扱い、多くのエンジニアが長期間にわたって作業することを意味します。

Goのコードをパッケージに分割する仕組みは、大規模なプログラミングを支える重要な特徴です。この仕組みにより、大規模なコードベースを管理可能な小さな単位に分割し、異なる人々が異なる部分を作成できるようになります。これらのパッケージは、公開APIを介して連携します。APIは、パッケージからエクスポートされる識別子（定数、型、変数、関数、構造体の公開フィールドや型のメソッド）で構成されます。

ソフトウェアプロジェクトが進化するにつれ、元々のコードの構造が不十分であると判明し、再構築（リファクタリング）が必要になることがあります。この場合、エクスポートされた識別子とその宣言を、古いパッケージから新しいパッケージへ移動しなければなりません。この移動では、移動した宣言を参照しているコードをすべて更新する必要があります。しかし、大規模なコードベースでは、これを一度に行うのは非現実的です。その代わり、変更は段階的に行う必要があります。

例えば、関数 `F` を移動する場合、新しいパッケージに `F` の宣言を追加し、古いパッケージから削除しないようにします。これにより、クライアントは時間をかけて徐々に更新できます。

---

#### 型を移動するには？

Goでは、型の同一性は名前（修飾された識別子）によって決まります。たとえば、パッケージ `pkg1` に定義された型 `T` は、別のパッケージ `pkg2` に定義された同名の型 `T` とは異なる型として扱われます。この特性があるため、型をあるパッケージから別のパッケージに移動しつつ、元のパッケージにも保持することが困難です。

例えば、型 `pkg2.T` の値は型 `pkg1.T` の変数には代入できません。段階的な移行の間、両方の型の値や変数を持つクライアントが存在する可能性があり、これは意図的には同一の型であるべきものを分断してしまいます。

この問題を解決するため、Go 1.9では型エイリアスが導入されました。型エイリアスは、新しい名前を既存の型に付ける方法を提供し、新しい型を導入することなく同一性を保持します。

以下はその例です：

```go
type A = T  // 「=」はエイリアス宣言を示します
```

通常の型定義：

```go
type T T0
```

これは、新しい型を宣言します。この新しい型は、右辺の型とは異なる型として扱われます。

エイリアス宣言：

```go
type A = T
```

これは右辺の型 `T` に新しい名前 `A` を与えるだけであり、両者は同一の型です。

型エイリアスを使用することで、新しいパッケージで型の新しい名前を提供しつつ、型の同一性を保つことが可能になります。

```go
package pkg2

import "path/to/pkg1"

type T = pkg1.T
```

この例では、型名は `pkg1.T` から `pkg2.T` に変更されますが、型 `pkg2.T` の値は型 `pkg1.T` の変数に代入可能です。

---

#### ジェネリックエイリアスタイプ

Go 1.18ではジェネリクスが導入され、型定義や関数宣言で型パラメータを使用できるようになりました。しかし、技術的な理由から、エイリアスタイプは当初ジェネリクスをサポートしていませんでした。また、当時はジェネリック型をエクスポートし、それをリファクタリングする必要があるような大規模なコードベースも存在していませんでした。

現在では、ジェネリクスが普及し、ジェネリック機能を利用する大規模なコードベースが増えてきています。そのため、ジェネリック型を別のパッケージに移動する必要性が高まっています。

これをサポートするために、Go 1.24（2025年2月リリース予定）では、提案 #46477 に基づいてエイリアスタイプに型パラメータを完全にサポートする予定です。この新機能では、左辺のエイリアス名に続けてオプションの型パラメータリストを指定することができます。

以前は次のように書くことしかできませんでした：

```go
type Alias = someType
```

しかし、今後は型パラメータを宣言することが可能になります：

```go
type Alias[P1 C1, P2 C2] = someType
```

#### ジェネリック型エイリアスの例

元のパッケージ `pkg1` で型パラメータ `P` を持つジェネリック型 `G` が宣言されているとします：

```go
package pkg1

type Constraint someConstraint
type G[P Constraint] someType
```

この型 `G` を新しいパッケージ `pkg2` からもアクセスできるようにする場合、ジェネリックエイリアスタイプを利用できます：

```go
package pkg2

import "path/to/pkg1"

type Constraint = pkg1.Constraint
type G[P Constraint] = pkg1.G[P]
```

ここで注意すべき点は、次のようには書けないことです：

```go
type G = pkg1.G
```

この制約にはいくつかの理由があります：

1. 既存の仕様では、ジェネリック型は使用時に型パラメータを具体化（インスタンス化）する必要があります。エイリアス宣言の右辺で型 `pkg1.G` を使用する場合、型引数を提供しなければなりません。

2. エイリアス宣言が独自の型パラメータを宣言しない場合、ジェネリック型であることが明示されなくなり、可読性が低下します。

型パラメータリストを明示的に記述することは、一見すると負担に思えるかもしれませんが、柔軟性を提供します。たとえば、エイリアスタイプが宣言する型パラメータの数は、エイリアス元の型が持つ型パラメータの数と一致する必要はありません。

以下にジェネリックマップ型の例を示します：

```go
type Map[K comparable, V any] mapImplementation
```

このマップ型をセットとして使用することが一般的な場合、以下のようなエイリアスが便利です：

```go
type Set[K comparable] = Map[K, bool]
```

このエイリアスにより、`Set[int]` と `Map[int, bool]` は同一の型になります。もし `Set` がエイリアスでなく通常の型定義であれば、この同一性は保証されません。

さらに、ジェネリックエイリアスタイプの型制約は、元の型の制約と一致する必要はなく、それを満たしていれば十分です。たとえば、以下のように整数型専用のセットを定義できます：

```go
type integers interface { ~int | ~int8 | ~int16 | ~int32 | ~int64 }
type IntSet[K integers] = Set[K]
```

この型は、`integers` 制約を満たす任意のキー型でインスタンス化できます。

最後に、エイリアスは型リテラルを示すこともできるため、ジェネリック型リテラルを作成することも可能です：

```go
type Point3D[E any] = struct { x, y, z E }
```

これらの例は特別なケースではなく、ジェネリクスの既存のルールに基づいて動作します。仕様に追加されたのは、エイリアス宣言で型パラメータを宣言できる能力だけです。

---

#### 型名についての小休止

エイリアスタイプが導入される前、Goには次の形式の型宣言しか存在しませんでした：

```go
type TypeName existingType
```

この宣言は、新しい型を既存の型から作成し、その新しい型に名前を付けます。この新しい型は既存の型とは異なるものとして扱われます。そのため、このような型は "named types" と呼ばれてきました。これに対し、例えば次のような名前のない型リテラル（`struct{ x, y int }`）とは区別されていました。

Go 1.9でエイリアスタイプが導入されたことで、型リテラルにも名前（エイリアス）を付けることが可能になりました。例えば：

```go
type Point2D = struct { x, y int }
```

エイリアス名は型の名前ですが、その型がリテラルかどうかは関係ありません。このため、"named types" という概念は、リテラル型とは異なるものであるという認識が揺らぐことになりました。

これらの理由から、Go 1.9以降、仕様ではこれまで "named types" と呼ばれていた型を "defined types" と呼ぶようになりました。

---

#### ジェネリクスと型名

Go 1.18でジェネリクスが導入され、仕様はさらに複雑になりました。型パラメータも型であり、名前を持ちます。型パラメータは定義済みの型と多くのルールを共有しています。例えば、異なる名前の型パラメータは異なる型を表します。

さらに、Goの事前定義型（`int` や `string` など）も名前を持つ型として扱われます。これらは、名前が異なる場合異なる型として扱われます（`byte` と `rune` のエイリアス型を除く）。

これらの背景から、Go 1.18では仕様で "named types" の概念が正式に再導入されました。現在では、"named types" は "事前定義型、定義済み型、型パラメータ" を含むものと定義されています。

仕様では次のように述べられています：

> "エイリアス宣言で指定された型が名前を持つ型である場合、そのエイリアスは名前を持つ型を示す。"

---

#### 利用可能性

ジェネリック型エイリアスの実装には予想以上に時間がかかりました。これには、`go/types` に新しい `Alias` 型を追加し、型パラメータを記録できるようにする必要があったためです。さらに、コンパイラ側ではエクスポートデータフォーマットを変更する必要がありました。これにより、パッケージのエクスポートを記述するファイルフォーマットが型パラメータを記述できるようになりました。

これらの変更の影響はコンパイラに留まらず、`go/types` のクライアントやサードパーティのパッケージにも影響を及ぼしました。そのため、複数のリリースにわたる段階的な展開が必要でした。

これらの作業を経て、ジェネリック型エイリアスはGo 1.24でデフォルトで利用可能になります。

Go 1.23以降では、`GOEXPERIMENT=aliastypeparams` を設定することで、この機能を試験的に利用することができます。ただし、このバージョンではエクスポートされたジェネリックエイリアスの完全なサポートはまだ提供されていません。

完全なサポート（エクスポートを含む）はGoの最新バージョンで実装されており、間もなくデフォルト設定で有効になります。常に最新のバージョンを使用して新機能を試し、問題が発生した場合はIssueを報告してください。

---
