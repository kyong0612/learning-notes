---
title: "Testing Time (and other asynchronicities) - The Go Programming Language"
source: "https://go.dev/blog/testing-time"
author:
  - "Damien Neil"
published: 2025-08-26
created: 2025-08-29
description: |
  Goの`testing/synctest`パッケージは、並行・非同期コードのテストを簡素化します。この記事では、非同期関数のテストにおける課題（フレーキーさや低速性）を概説し、`synctest`がフェイクタイムと静止状態の待機機能を提供することで、いかに高速で信頼性の高いテストを実現するかを解説します。
tags:
  - "Go"
  - "testing"
  - "concurrency"
  - "asynchronous"
  - "synctest"
---

## 概要

Go 1.25で正式に利用可能となった`testing/synctest`パッケージは、並行・非同期コードのテストを大幅に簡素化するための新しい実験的パッケージです。この記事は、GopherCon Europe 2025での同名の講演をブログ記事にしたもので、非同期処理のテストにおける課題と、それを`synctest`がどのように解決するかを解説します。

## 1. 非同期関数テストの課題

### 同期関数と非同期関数

- **同期関数**: 呼び出されると、処理を実行し、完了後に制御を返す。
- **非同期関数**: 呼び出されるとすぐに制御を返し、処理はバックグラウンドで（将来）実行される。

例として、`context.WithDeadline`は、指定した時刻に将来キャンセルされる`context`を返す、本質的に非同期なAPIです。

### テストの難しさ

非同期関数のテストは、以下の理由で困難です。

1. **待機時間の問題**: バックグラウンド処理が完了するのを待つ必要があるが、適切な待機時間がわからない。
    - 待機時間が短すぎると、処理が終わる前に結果を検証してしまい、テストが失敗する（**フレーキーなテスト**）。
    - 待機時間が長すぎると、テストの実行が遅くなる（**低速なテスト**）。
2. **「何かが起こらないこと」の証明の難しさ**: ある事象が発生していないことを確認しても、それが後で発生しないとは断言できない。

`context.WithDeadline`のテストを例に挙げると、`time.Sleep`を使ってデッドラインが過ぎるのを待つ方法は、CI環境の負荷などによって簡単に失敗する可能性があり、信頼性が低く、実行時間もかかります。

## 2. 従来のテストアプローチと限界

### a) 同期的な関数に変換する

可能な限り、非同期処理を同期的な関数として設計し、呼び出し側が必要に応じてゴルーチンで実行する方法が最もシンプルでテストしやすいです。しかし、`context.WithDeadline`のように、API自体が本質的に非同期である場合はこの方法は適用できません。

### b) テスト容易性のためのコード計装

より良いアプローチは、コードをテストしやすくすることです。これには2つの基本原則があります。

1. **フェイクタイム（偽の時計）を使用する**: `time.Sleep`のようなリアルタイムの待機を避け、テスト内で時間を手動で進めることができる偽の時計を導入する。これにより、テストは高速になります。
2. **静止状態（Quiescence）を待機する方法を持つ**: 「すべてのバックグラウンドアクティビティが停止し、システムが安定している状態」を検知する仕組みを導入する。

しかし、このアプローチには大きな欠点があります。

- **実装が難しい**: 特に、いつバックグラウンド処理が完了したかを判断するのは困難。
- **コードが非慣用的になる**: 標準の`time`パッケージが使えず、特別なインターフェースを渡す必要がある。
- **サードパーティのコードに適用できない**: 依存しているライブラリがこの仕組みに対応していなければ利用できない。
- **既存のコードベースへの後付けがほぼ不可能**。

## 3. `synctest`パッケージによる解決策

これらの課題を解決するため、Goチームは`synctest`パッケージを開発しました。これは、テスト容易性のための2つの基本機能（フェイクタイムと静止状態の待機）を、Goのランタイムレベルでサポートします。

### `synctest`の主要な関数

`synctest`パッケージは、2つの主要な関数を提供します。

```go
package synctest

// Testは新しい「バブル」内で関数fを実行する。
// バブル内のゴルーチンはフェイクタイムを使用する。
func Test(t *testing.T, f func(*testing.T))

// Waitはバブル内のバックグラウンドアクティビティが完了するのを待つ。
func Wait()
```

- `synctest.Test`: テストコードを「**バブル**」と呼ばれる隔離された環境で実行します。バブル内では、`time`パッケージがフェイクタイムを使用するようになります。
- `synctest.Wait`: バブル内のすべてのゴルーチンが、他のバブル内のゴルーチンを待ってブロックされる状態（**恒久的にブロックされた状態**）になるまで待機します。

### `synctest`を使ったテストの例

`context.WithDeadline`のテストは、`synctest`を使うと以下のようになります。

```go
func TestWithDeadlineAfterDeadline(t *testing.T) {
    synctest.Test(t, func(t *testing.T) {
        deadline := time.Now().Add(1 * time.Second)
        ctx, _ := context.WithDeadline(t.Context(), deadline)

        time.Sleep(time.Until(deadline))
        synctest.Wait() // バックグラウンド処理（コンテキストのキャンセル）を待つ
        if err := ctx.Err(); err != context.DeadlineExceeded {
            t.Fatalf("context not canceled after deadline")
        }
    })
}
```

このテストは、`context`パッケージ自体を一切変更することなく、**高速**かつ**信頼性の高い**ものになります。`time.Sleep`は瞬時に完了し、`synctest.Wait`がキャンセル処理の完了を保証します。

## 4. `synctest`の仕組み

### バブルと時間

- **時間**: バブル内の時間は、すべてのゴルーチンがブロックされたときにのみ進みます。計算処理自体は時間を消費しません。これにより、`time.Sleep(10 * time.Second)`は瞬時に完了し、内部の時計が10秒進みます。
- **ゴルーチンの終了**: `synctest.Test`は、バブル内で開始されたすべてのゴルーチンが終了するまでリターンしません。

### 静止状態の待機と「恒久的なブロック」

`synctest.Wait`は、バブル内のすべてのゴルーチンが「恒久的にブロック（durably blocked）」されるまで待機します。

- **恒久的にブロック**: そのゴルーチンのブロックを解除できるのが、同じバブル内の別のゴルーチンだけである状態。

#### 恒久的にブロックされる操作

- `time.Sleep`
- 同じバブル内で作成されたチャネルでの送受信
- 同じバブルに属する`sync.WaitGroup`の待機
- `sync.Cond.Wait`
- 空の`select{}`

#### 恒久的にブロック**されない**操作

- **I/O（ファイル、パイプ、ネットワーク接続）**: データはバブルの外部（カーネルなど）から来る可能性があるため。ネットワークプログラムのテストには、インメモリのフェイクネットワーク実装が必要です。
- **Syscall、cgo呼び出し**
- **Mutex**: グローバルな状態を保護するためにバブル外のゴルーチンと共有されることが多く、パフォーマンスへの影響を避けるため。

### デッドロックの検出

バブル内のすべてのゴルーチンが恒久的にブロックされ、時間を進めてもどのゴルーチンも再開できない場合、`synctest`はデッドロックを検出し、パニックを発生させてスタックトレースを出力します。

## 5. `synctest`の進化と今後の展望

- **Go 1.24から1.25への変更点**:
  - `Run`を`Test`に改名し、バブルスコープの`*testing.T`を渡すように変更。
  - バブルのルートゴルーチンがリターンすると時間進行を停止するように変更。
  - 「恒久的なブロック」の定義を厳密化。
  - デッドロック時のスタックトレースを改善。
- **今後の作業**:
  - Mutex操作を恒久的にブロック可能にする改善。
  - 標準ライブラリに高品質なフェイクネットワーク実装を追加する可能性。

## 結論

`synctest`パッケージは、並行処理のテストを単純にするものではありませんが、Goの慣用的な書き方を維持したまま、最もシンプルで、高速かつ信頼性の高いテストを書くことを可能にします。これにより、開発者は並行コードの品質を容易に保証できるようになります。
