---
title: "Concurrency - Jujutsu docs"
source: "https://jj-vcs.github.io/jj/latest/technical/concurrency/"
author: []
published:
created: 2025-07-24
description: |
  Jujutsu (jj) version control system handles concurrency differently from traditional DVCS like Git. Instead of using lock files for local operations, it treats local and remote concurrent edits uniformly. This lock-free design is based on an "operation log" that allows for detecting and merging divergent operations, ensuring that no changes are lost even when syncing repositories via tools like rsync or Dropbox.
tags:
  - "Jujutsu"
  - "DVCS"
  - "Concurrency"
  - "Version Control"
  - "Operation Log"
---

## Jujutsuにおける並行処理の概要

Jujutsu (jj) は、Gitのような従来の分散バージョン管理システム（DVCS）とは異なる独自のアプローチで並行処理を扱います。ロックファイルに依存せず、ローカルとリモートの同時編集を一貫して処理することで、堅牢性と柔軟性を両立させています。この設計の中心にあるのが「オペレーションログ」です。

### 1. はじめに：ロックフリーなアプローチ

* **DVCSの基本**: DVCSの核となる機能は、異なるマシンでの同時編集とコミット作成を可能にすることです。
* **従来のアプローチとの違い**:
  * **MercurialやGit**: リモートでの変更が競合した場合、それぞれ異なる方法で対処します（例: Mercurialは`main@origin`のような競合ブックマークを作成、Gitは`origin/main`のようにブランチをリネーム）。
  * **Jujutsu**: 多くのDVCSがローカルの同時編集を「ロックファイル」で防ぐのに対し、Jujutsuはローカルとリモートの同時編集を同じように扱います。
* **ロックファイルの問題点**:
    1. **分散ファイルシステムとの非互換性**: NFSのような環境ではロックファイルが機能せず、リポジトリが破損する危険があります（例: Mercurial）。
    2. **実装の複雑性**: ロックの粒度を細かくしてユーザー体験を向上させようとすると、実装が複雑になります。
* **Jujutsuの解決策**: Jujutsuはロックファイルに依存せず、「同時変更は常に起こりうる」という前提に立ちます。競合が発生した場合は、リモートでの競合と同様に、その情報をユーザーに提示します。

### 2. `rsync`, NFS, Dropbox等での同期

Jujutsuのロックフリーな並行性により、`rsync`やDropboxのようなツールを使って異なるマシン上のリポジトリのコピーを安全にマージできます。

* 作業コピーとチェックアウトされた内容が一時的に食い違うことはありますが、コミットの追加やブックマークの移動といったリポジトリへの変更が失われることはありません。
* 競合が発生した場合（例: あるブックマークが同時に2つの異なるコミットを指した場合）、`jj log`では「?」付きで両方の場所に表示され、`jj status`でも競合が報告されます。

**制限事項・注意点**:

* **Gitバックエンドのバグ**: Gitバックエンドを使用している場合、バックエンドが完全にはロックフリーでないため、リポジトリが破損する可能性のある既知のバグが存在します ([Issue #2193](https://github.com/jj-vcs/jj/issues/2193))。
* **テストの現状**: このような利用方法はまだ十分にテストされておらず、特にco-locatedリポジトリの文脈では、ブックマークのポインタが失われる可能性があります。ただし、JujutsuではGitとは異なり、ポインタを失ってもコミットが失われることはありません。

### 3. オペレーションログ (Operation log)

ロックフリー設計を実現する最も重要な要素が「オペレーションログ」です。これにより、発散した操作の検出とマージが可能になります。

* **構造**:
  * GitのコミットDAG（有向非巡回グラフ）に似ていますが、「コミット」の代わりに「**オペレーション(operation)**」、「ツリー」の代わりに「**ビュー(view)**」で構成されます。
  * **ビュー**: リポジトリの完全な状態（可視ヘッドコミット、ブックマーク、タグ、作業コピーの状態など）を定義します。
  * **オペレーション**: ビューへのポインタ、親オペレーションへのポインタ、メタデータを含みます。
* **動作モデル**:
    1. コマンドは常に最新のオペレーションでリポジトリをロードするため、一貫したビューを参照できます。
    2. コマンドが完了すると、開始時のオペレーションを親として新しいオペレーションが書き込まれます。この書き込みは（ディスク障害などを除き）失敗しません。
    3. もし他のプロセスによって同時に変更が行われていた場合、その検出とマージは次回のコマンド実行時に行われます。このモデルにより、各コマンドの実装が大幅に簡素化されます。
* **操作のシミュレーション**: `jj --at-operation=<ID>` を使うと、過去の特定の時点でリポジトリをロードし、意図的にオペレーションログを分岐させることができます。これは同時操作をシミュレートするのに便利です。

#### 発散した操作のマージ

オペレーションログに複数のヘッド（分岐）が見つかった場合、Jujutsuは共通の祖先を見つけ、ビューオブジェクトの3-wayマージを自動的に行います。

* 競合は結果のビューオブジェクトに記録されます。例えば、ブックマーク`main`がコミットAからBへ、同時にCへと移動された場合、「AからBまたはCへ移動された」という競合状態として記録されます。
* この仕組みにより、ブックマークなどが競合状態にあってもエラーで停止することなく、リポジトリを使い続けることができます（ただし、競合したリソースを使おうとする一部のコマンドは失敗します）。

#### ストレージ

* オペレーションオブジェクトとビューオブジェクトは、Gitコミットと同様に**内容アドレス指定ストレージ(content-addressed storage)**に保存されるため、ロックなしで安全に書き込めます。
* オペレーションログの現在のヘッドを見つけるために、ヘッドのIDをファイル名とする空ファイルを使用します。操作が完了すると、新しいヘッドのファイルを作成し、古いものを削除することで、トランザクションの原子性が保証されます。
