---
title: "How I Use Every Claude Code Feature"
source: "https://blog.sshh.io/p/how-i-use-every-claude-code-feature"
author:
  - "Shrivu Shankar"
published: 2025-11-02
created: 2025-11-11
description: |
  Claude Codeの全機能を実践的に使用する方法についての包括的なガイド。CLAUDE.mdファイルからカスタムサブエージェント、Hooks、GitHub Actionsまで、各機能の使い方とベストプラクティス、アンチパターンを詳しく解説。個人プロジェクトから企業レベルのモノレポまで、実際の使用経験に基づいた実践的なアドバイスを提供。
tags:
  - "clippings"
  - "Claude Code"
  - "AI開発"
  - "エージェント開発"
  - "コーディング支援"
  - "開発ツール"
---

## 概要

著者はClaude Codeを個人的なプロジェクトと企業レベルのモノレポの両方で使用しており、月間数十億トークンのコード生成を扱うチームのAI-IDEルールとツールを構築している。この記事は、Claude Codeの全機能についての実践的な使用経験とベストプラクティスをまとめたリファレンスガイドである。

## CLAUDE.md

`CLAUDE.md`は、Claude Codeを効果的に使用するための最も重要なファイルであり、エージェントの「憲法」として機能する。

### 使用方法

- **個人プロジェクト**: Claudeに自由に書き込ませる
- **企業モノレポ**: 厳密に管理し、現在13KB（将来的に25KBまで拡張可能）

### ベストプラクティス

1. **ガードレールから始める**: 小さく始め、Claudeが間違えている点を文書化する
2. **`@`ファイルドキュメントを避ける**: ファイルを`@`で言及すると、毎回の実行でコンテキストウィンドウにファイル全体が埋め込まれる。代わりに、パスを言及し、なぜ・いつそのファイルを読むべきかを説明する
3. **「Never」だけを言わない**: 否定的な制約だけを提供すると、エージェントがそのフラグを使わなければならないと感じて行き詰まる。常に代替案を提供する
4. **強制機能として使用**: CLIコマンドが複雑で冗長な場合、長い説明を書くのではなく、シンプルなbashラッパーを作成し、それを文書化する

### 企業での運用

- エンジニアの30%以上が使用するツールとAPIのみを文書化（それ以外は製品やライブラリ固有のマークダウンファイルに記載）
- 各内部ツールのドキュメントに実質的な最大トークン数を割り当て、簡潔に説明できないツールは`CLAUDE.md`に含めない

**要点**: `CLAUDE.md`を高レベルのガードレールとポインターのセットとして扱い、包括的なマニュアルにしようとせず、よりAI（および人間）フレンドリーなツールへの投資を導くために使用する。

## Compact, Context, & Clear

コーディングセッション中に少なくとも1回は`/context`を実行して、200kトークンのコンテキストウィンドウの使用状況を理解することを推奨。モノレポでの新しいセッションは約20kトークン（10%）のベースラインコストがかかり、残り180kは変更に使用される。

### 主なワークフロー

1. **`/compact`（避ける）**: 自動圧縮は不透明で、エラーが発生しやすく、最適化されていない
2. **`/clear` + `/catchup`（シンプルな再起動）**: デフォルトの再起動方法。`/clear`で状態をクリアし、カスタム`/catchup`コマンドでgitブランチ内のすべての変更ファイルを読み込む
3. **「Document & Clear」（複雑な再起動）**: 大きなタスクの場合。Claudeに計画と進捗を`.md`ファイルにダンプさせ、`/clear`で状態をクリアし、`.md`を読んで続行するよう指示する

**要点**: 自動圧縮を信用せず、シンプルな再起動には`/clear`を使用し、「Document & Clear」メソッドで複雑なタスクのための永続的な外部「メモリ」を作成する。

## Custom Slash Commands

スラッシュコマンドは、頻繁に使用するプロンプトのシンプルなショートカットとして考える。

### 使用例

- `/catchup`: 現在のgitブランチ内のすべての変更ファイルを読み込む
- `/pr`: コードをクリーンアップし、ステージングして、プルリクエストを準備する

### アンチパターン

長い複雑なカスタムスラッシュコマンドのリストは、アンチパターンである。エージェントのポイントは、ほぼ何でも入力して有用でマージ可能な結果を得られること。エンジニア（または非エンジニア）に作業を完了するために新しい、どこかに文書化された必須の魔法のコマンドを学習させることを強制した時点で失敗している。

**要点**: スラッシュコマンドをシンプルな個人的なショートカットとして使用し、より直感的な`CLAUDE.md`とより良いツール化されたエージェントの構築の代替として使用しない。

## Custom Subagents

カスタムサブエージェントは、紙面上ではClaude Codeのコンテキスト管理のための最も強力な機能。複雑なタスクには`X`トークンの入力コンテキスト、`Y`トークンの作業コンテキスト、`Z`トークンの回答が必要。`N`個のタスクを実行すると、メインウィンドウに`(X + Y + Z) * N`トークンが必要になる。

サブエージェントソリューションは、`(X + Y) * N`の作業を専門エージェントに委託し、最終的な`Z`トークンの回答のみを返すことで、メインコンテキストをクリーンに保つ。

### 問題点

1. **コンテキストのゲートキーピング**: `PythonTests`サブエージェントを作成すると、すべてのテストコンテキストがメインエージェントから隠される。変更について全体的に推論できなくなり、コードを検証する方法を知るためにサブエージェントを呼び出すことを強制される
2. **人間のワークフローの強制**: Claudeに厳格な人間定義のワークフローを強制する。エージェントに解決してもらおうとしている問題そのものの委任方法を指示することになる

### 推奨される代替案

Claudeの組み込み`Task(...)`機能を使用して、一般的なエージェントのクローンを生成する。すべての重要なコンテキストを`CLAUDE.md`に配置し、メインエージェントに作業を自分自身のコピーに委任するタイミングと方法を決定させる。これにより、サブエージェントの欠点なしに、コンテキスト保存の利点が得られる。

**要点**: カスタムサブエージェントは脆弱なソリューション。メインエージェントにコンテキスト（`CLAUDE.md`内）を与え、独自の`Task/Explore(...)`機能を使用して委任を管理させる。

## Resume, Continue, & History

`claude --resume`と`claude --continue`を頻繁に使用。バグのあるターミナルを再起動したり、古いセッションを迅速に再起動したりするのに最適。数日前のセッションを`claude --resume`して、特定のエラーをどのように克服したかを要約させ、`CLAUDE.md`と内部ツールを改善するために使用することが多い。

Claude Codeはすべてのセッション履歴を`~/.claude/projects/`に保存。これらのログに対してメタ分析を実行するスクリプトを持ち、一般的な例外、権限リクエスト、エラーパターンを探して、エージェント向けコンテキストの改善に役立てている。

**要点**: `claude --resume`と`claude --continue`を使用してセッションを再起動し、埋もれた履歴コンテキストを発見する。

## Hooks

Hooksは重要。個人プロジェクトでは使用しないが、複雑な企業リポジトリでClaudeを導くために不可欠。`CLAUDE.md`の「すべき」提案を補完する、決定論的な「必須」ルール。

### 使用する2つのタイプ

1. **Block-at-Submit Hooks**: 主要な戦略。`Bash(git commit)`コマンドをラップする`PreToolUse`フック。`/tmp/agent-pre-commit-pass`ファイルをチェックし、テストスクリプトがすべてのテストが合格した場合にのみこのファイルを作成する。ファイルが欠けている場合、フックはコミットをブロックし、ビルドが成功するまでClaudeを「テストして修正」ループに強制する
2. **Hint Hooks**: エージェントが最適でないことをしている場合に「fire-and-forget」フィードバックを提供するシンプルな非ブロッキングフック

### 避けるべきもの

「block-at-write」フック（例：`Edit`や`Write`上）は意図的に使用しない。エージェントを計画の途中でブロックすると混乱や「フラストレーション」を引き起こす。エージェントに作業を完了させ、コミット段階で最終的な完了結果をチェックする方がはるかに効果的。

**要点**: コミット時に状態検証を強制するためにフックを使用（`block-at-submit`）。書き込み時にブロックすることを避け、エージェントに計画を完了させてから最終結果をチェックする。

## Planning Mode

計画は、AI IDEを使用した「大きな」機能変更に不可欠。

### 個人プロジェクト

組み込みの計画モードを独占的に使用。何かを構築する方法と、作業を停止して作業を示す必要がある「検査チェックポイント」の両方を定義する方法。これを使用することで、実装を台無しにすることなく良い計画を得るために必要な最小限のコンテキストについての強い直感が構築される。

### 企業モノレポ

Claude Code SDK上に構築されたカスタム計画ツールの展開を開始。ネイティブ計画モードと同様だが、既存の技術設計形式に合わせて出力を調整するよう強くプロンプトされている。また、コード構造からデータプライバシーとセキュリティまで、内部ベストプラクティスを最初から強制する。これにより、エンジニアがシニアアーキテクトのように（少なくともそれがピッチ）新しい機能を「vibe plan」できる。

**要点**: エージェントが作業を開始する前に計画に合わせるために、複雑な変更には常に組み込み計画モードを使用する。

## Skills

**Skillsは（おそらく）MCPよりも大きな問題である。**

エージェントの自律性のメンタルモデルは3つの段階に進化：

1. **Single Prompt**: 1つの巨大なプロンプトでエージェントにすべてのコンテキストを与える（脆弱、スケールしない）
2. **Tool Calling**: 「クラシック」エージェントモデル。ツールを手作りし、エージェントのために現実を抽象化する（より良いが、新しい抽象化とコンテキストのボトルネックを作成）
3. **Scripting**: エージェントに生の環境（バイナリ、スクリプト、ドキュメント）へのアクセスを与え、それらと対話するためにコードを動的に書く

このモデルを念頭に置いて、**Agent Skills**は明らかな次の機能。これらは「Scripting」レイヤーの正式な製品化。

MCPよりもCLIを優先している場合、すでにSkillsの利点を暗黙的に得ている。`SKILL.md`ファイルは、これらのCLIとスクリプトを文書化し、エージェントに公開するための、より組織化され、共有可能で、発見可能な方法。

**要点**: Skillsは正しい抽象化。MCPが表す厳格なAPIライクなモデルよりも堅牢で柔軟な「スクリプト」ベースのエージェントモデルを正式化する。

## MCP (Model Context Protocol)

SkillsはMCPが死んだことを意味しない。以前、多くの人が、REST API（`read_thing_a()`、`read_thing_b()`、`update_thing_c()`）を単にミラーリングする数十のツールを持つ、コンテキストが重い恐ろしいMCPを構築していた。

「Scripting」モデル（現在Skillsによって正式化）はより良いが、環境にアクセスするための安全な方法が必要。これが、MCPの新しい、より焦点を絞った役割。

膨張したAPIの代わりに、MCPはシンプルで安全なゲートウェイであり、いくつかの強力な高レベルツールを提供する：

- `download_raw_data(filters…)`
- `take_sensitive_gated_action(args…)`
- `execute_code_in_environment_with_state(code…)`

このモデルでは、MCPの仕事はエージェントのために現実を抽象化することではなく、認証、ネットワーキング、セキュリティ境界を管理し、その後邪魔にならないようにすること。エージェントのエントリーポイントを提供し、その後エージェントはスクリプトと`markdown`コンテキストを使用して実際の作業を行う。

現在も使用している唯一のMCPは[Playwright](https://github.com/microsoft/playwright-mcp)用で、これは理にかなっている（複雑でステートフルな環境）。すべてのステートレスツール（Jira、AWS、GitHubなど）はシンプルなCLIに移行済み。

**要点**: データゲートウェイとして機能するMCPを使用する。エージェントに1つまたは2つの高レベルツール（生データダンプAPIなど）を与え、その後スクリプトで対処できるようにする。

## Claude Code SDK

Claude Codeは単なるインタラクティブなCLIではなく、コーディングと非コーディングタスクの両方のための完全に新しいエージェントを構築するための強力なSDKでもある。LangChain/CrewAIなどのツールよりも、ほとんどの新しい個人プロジェクトのデフォルトエージェントフレームワークとして使用を開始。

### 3つの主な使用方法

1. **大規模並列スクリプト**: 大規模なリファクタリング、バグ修正、または移行の場合、インタラクティブチャットを使用しない。`claude -p "in /pathA change all refs from foo to bar"`を並列で呼び出すシンプルなbashスクリプトを書く。これは、メインエージェントに数十のサブエージェントタスクを管理させるよりもはるかにスケーラブルで制御可能
2. **内部チャットツールの構築**: SDKは、非技術ユーザー向けのシンプルなチャットインターフェースで複雑なプロセスをラップするのに最適。エラー時にClaude Code SDKにフォールバックしてユーザーの問題を修正するインストーラーなど。または、デザインチームが社内UIフレームワークでモックフロントエンドを「vibe-code」できる社内「[v0-at-home](http://v0.dev/)」ツールで、アイデアが高忠実度で、コードがフロントエンド本番コードでより直接的に使用可能
3. **迅速なエージェントプロトタイピング**: 最も一般的な使用。コーディングだけではない。エージェントタスクのアイデア（例：カスタムCLIやMCPを使用する「脅威調査エージェント」）がある場合、完全な展開されたスキャフォールディングにコミットする前に、Claude Code SDKを使用して迅速にプロトタイプを構築してテストする

**要点**: Claude Code SDKは強力な汎用エージェントフレームワーク。バッチ処理コード、内部ツールの構築、より複雑なフレームワークに到達する前に新しいエージェントを迅速にプロトタイピングするために使用する。

## Claude Code GHA

Claude Code GitHub Action（GHA）は、おそらく最も好きで最も見過ごされている機能の1つ。シンプルな概念：GHAでClaude Codeを実行するだけ。しかし、このシンプルさが非常に強力な理由。

[Cursorのバックグラウンドエージェント](https://cursor.com/docs/cloud-agent)やCodex管理Web UIと似ているが、はるかにカスタマイズ可能。コンテナと環境全体を制御し、データへのより多くのアクセスと、他の製品が提供するよりもはるかに強力なサンドボックスと監査制御を提供。さらに、HooksやMCPなどの高度な機能をサポート。

### GHAの使用例

カスタム「PR-from-anywhere」ツールを構築。ユーザーはSlack、Jira、またはCloudWatchアラートからPRをトリガーでき、GHAがバグを修正または機能を追加し、完全にテストされたPRを返す。

GHAログは完全なエージェントログであるため、一般的な間違い、bashエラー、または整合性のないエンジニアリングプラクティスについて、会社レベルでこれらのログを定期的にレビューする運用プロセスがある。これにより、データ駆動のフライホイールが作成される：バグ → 改善されたCLAUDE.md / CLI → より良いエージェント。

```bash
query-claude-gha-logs --since 5d | claude -p "see what the other claudes were getting stuck on and fix it, then put up a PR"
```

**要点**: GHAはClaude Codeを運用化する究極の方法。個人ツールから、エンジニアリングシステムの核心的で監査可能で自己改善する部分に変える。

## settings.json

個人と企業の両方の作業で不可欠な特定の`settings.json`設定：

- **`HTTPS_PROXY`/`HTTP_PROXY`**: デバッグに最適。Claudeが送信しているプロンプトを正確に確認するために生のトラフィックを検査するために使用。バックグラウンドエージェントの場合、細かいネットワークサンドボックスのための強力なツール
- **`MCP_TOOL_TIMEOUT`/`BASH_MAX_TIMEOUT_MS`**: これらを増やす。長く複雑なコマンドを実行するのが好きで、デフォルトのタイムアウトはしばしば保守的すぎる。bashバックグラウンドタスクが存在するようになった今、これがまだ必要かどうかは正直わからないが、念のため保持している
- **`ANTHROPIC_API_KEY`**: 企業ではエンタープライズAPIキーを使用（[apiKeyHelper経由](https://www.reddit.com/r/ClaudeAI/comments/1jwvssa/comment/mtt0urz/?utm_source=share&utm_medium=web3x&utm_name=web3xcss&utm_term=1&utm_content=share_button)）。「シートごと」ライセンスから「使用量ベース」の価格設定に移行し、作業方法により適したモデル
  - 開発者間の使用量の*巨大な*差異を考慮（エンジニア間で1:100倍の差異を観察）
  - エンジニアが非Claude-Code LLMスクリプトをいじることを許可し、すべてが単一のエンタープライズアカウントの下
- **`"permissions"`**: Claudeが自動実行することを許可したコマンドのリストを時々自己監査

**要点**: `settings.json`は高度なカスタマイズのための強力な場所。

## 結論

多くの内容だったが、役立つことを願っている。Claude CodeやCodex CLIのようなCLIベースのエージェントをまだ使用していない場合、おそらく使用すべき。これらの高度な機能の良いガイドはほとんどないため、学習する唯一の方法は飛び込むこと。

## 重要な洞察

- **ツールの選択**: CLIエージェントスペースは混雑しているが、開発者の選択はしばしば表面的なもの（「幸運な」機能実装や好みのシステムプロンプト「雰囲気」）に基づいている。これらのツールはすべてかなり良い
- **出力スタイル**: 「あなたは絶対に正しい！」というお世辞は注目すべきバグではなく、ループに深く入りすぎているという信号。目標は「shoot and forget」—委任し、コンテキストを設定し、作業させること。最終的なPRでツールを判断し、そこに到達する方法ではない
- **AI生成PRのレビュー**: 顧客リクエストから直接生成されたPR（内部の人間のプロンプターなし）には、いくつのレビュアーが必要かという哲学的な質問。現在、AI開始PRには2つの人間の承認を設定しているが、もはや人間が別の人間がレビューするために何かを作っているわけではないというパラダイムシフト
