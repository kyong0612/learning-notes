---
title: "「ソフトウェアエンジニア」としてのラルフ・ウィガム"
source: "https://ghuntley.com/ralph/"
author:
  - "[[Geoffrey Huntley]]"
published: 2025-07-14
created: 2025-08-26
description: |
  😎Y Combinatorのハッカソンイベントでラルフ・ウィガムを試した、ちょっとクールなフィールドレポートです。「コーディングエージェントをWhileループに入れたら、一晩で6つのリポジトリをシップした」https://github.com/repomirrorhq/repomirror/blob/main/repomirror.md 最近私のSNSを見たことがあるなら、
tags:
  - "clippings"
---
皆さん、こんにちは。人生に関する重要なお知らせです。
新しい雇用主を探しています - <ghuntley@ghuntley.com> までご連絡ください。

これは、エージェント構築に関する9ヶ月の知識を持ち、教師であり、多作な著者であり、パブリックスピーカーでもある人材を獲得するチャンスです。

私はオーストラリアのシドニーに拠点を置いていますが、リモートで働いています。役割のガイダンスはIC5、SFです。

😎

Y Combinatorのハッカソンイベントでラルフ・ウィガムを試した、ちょっとクールなフィールドレポートです。

**「コーディングエージェントをWhileループに入れたら、一晩で6つのリポジトリをシップした」**

[https://github.com/repomirrorhq/repomirror/blob/main/repomirror.md](https://github.com/repomirrorhq/repomirror/blob/main/repomirror.md?ref=ghuntley.com)

最近私のSNSを見たことがあるなら、私がラルフについて話しているのを見かけたかもしれませんし、ラルフとは何だろうと思っているかもしれません。ラルフはテクニックです。最も純粋な形では、ラルフはBashのループです。

```
while :; do cat PROMPT.md | npx --yes @sourcegraph/amp ; done
```

ラルフは、ほとんどの企業におけるグリーンフィールドプロジェクトのアウトソーシングの大半を置き換えることができます。欠陥はありますが、これらはさまざまなスタイルのプロンプトを通じて特定し、解決することができます。

> **それがラルフの美しさです - このテクニックは、不確定な世界において確定的に悪いのです。**

ラルフは、ツールコールと使用量に上限を設けないツール（例：[Amp](https://ampcode.com/?ref=ghuntley.com)）であれば何でも実行できます。

ラルフは現在、全く新しいプログラミング言語を構築しています。全く新しいプロダクショングレードの難解なプログラミング言語がリリースされる前の最終段階にいます。私にとって驚きなのは、ラルフがこの言語を構築できただけでなく、LLMのトレーニングデータセットにその言語がなくても、この言語でプログラミングできることです。

ラルフでソフトウェアを構築するには、極度の信頼と、結果整合性への信念が必要です。ラルフはあなたを試します。ラルフがCURSEDを作る上で間違った方向に進むたびに、私はツールを責めるのではなく、自分自身の内面を見つめてきました。ラルフが何か間違ったことをするたびに、ラルフはギターのようにチューニングされます。

最初はプレイグラウンドがなく、ラルフにプレイグラウンドを構築するように指示することから始まります。ラルフはプレイグラウンドを作るのがとても上手ですが、滑り台から落ちて bruised して帰ってくるので、滑り台の隣に「滑り降りろ、ジャンプするな、周りを見ろ」という看板を追加してラルフをチューニングすると、ラルフは看板を見てくれる可能性が高くなります。

![](https://ghuntley.com/content/images/size/w600/2025/07/image-1.png)

ダイアグラムとしてのラルフ・ウィガムテクニック

最終的にラルフが考えるのは看板のことばかりになるので、その時はラルフのように欠陥を感じさせない新しいラルフを手に入れます。

私がSFOにいたとき、何人かの賢い人たちにラルフについて教えました。一人の非常に才能のあるエンジニアが耳を傾け、次の契約でラルフを使い、とんでもないROIを手にして帰っていきました。最近では、彼らが考えるのはラルフのことばかりです。

## prompt.mdには何が入っているの？もらえますか？

プログラミングコミュニティでは、完璧なプロンプトへの執着があるようです。完璧なプロンプトなどというものは存在しません。

CURSEDからプロンプトを拝借したくなるかもしれませんが、それをどう使いこなすかを知らなければ意味がありません。LLMの振る舞いを観察し続けることで継続的にチューニングされてきたので、プロンプトをそのまま使っても同じ結果は得られないでしょう。CURSEDが構築されている間、私はそこに座ってストリームを眺め、悪い振る舞いのパターン、つまりラルフをチューニングする機会を探しています。

## まずはいくつかの基本から

私がSFOにいた間、誰もがマルチエージェント、エージェント間のコミュニケーション、そしてマルチプレキシングを解明しようとしているようでした。現段階では、それは必要ありません。マイクロサービスとそれに伴うすべての複雑さを考えてみてください。そして、マイクロサービス（エージェント）自体が非決定論的だったらどうなるか考えてみてください—大混乱です。

マイクロサービスの反対は何でしょう？モノリシックなアプリケーションです。垂直にスケールする単一のオペレーティングシステムプロセス。ラルフはモノリシックです。ラルフは単一のリポジトリ内で、ループごとに一つのことだけを行う単一のプロセスとして自律的に動作します。

![](https://ghuntley.com/content/images/size/w600/2025/07/The-ralph-Process.png)

ダイアグラムとしてのラルフ・ウィガムテクニック

ラルフで良い結果を得るためには、ループごとに一つのことをするようにラルフに頼む必要があります。**たった一つのことだけ**です。これは無茶に聞こえるかもしれませんが、何を実装するのが最も重要かをラルフに決めさせることを信頼する必要もあります。これは、あなたが「責任あるエンジニアリング」と考えるものの境界を試す、完全にハンズオフな雰囲気のコーディングです。

LLMは、何を実装するのが重要で、次のステップは何かを推論するのが驚くほど得意です。

> あなたのタスクは、不足しているstdlib（@specs/stdlib/*を参照）とコンパイラの機能を実装し、並列サブエージェントを使用してその機能のために呪われた言語でコンパイルされたアプリケーションをLLVM経由で生成することです。@fix_plan.mdに従い、**最も重要なことを選択してください**。

上記のプロンプトにはいくつかの点があり、後ほど詳しく説明しますが、もう一つの重要なことは、**ループごとに同じ方法で決定論的にスタックを割り当てること**です。

![](https://ghuntley.com/content/images/size/w600/2025/07/CleanShot-2025-07-14-at-12.40.30@2x.png)

0:00 / 0:20 84 squee (claude subagents) chasing

毎ループ、スタックに割り当てたい項目は、あなたの計画（"@fix_plan.md"）と仕様です。仕様が新しい概念である場合は、以下を参照してください。

仕様は、プロジェクトの初期段階でエージェントとの会話を通じて形成されます。エージェントにプロジェクトの実装を依頼するのではなく、これから実装するものについての要件についてLLMと長い会話をすることが重要です。エージェントが行うべきタスクを十分に理解したら、その時点で仕様をファイルごとに仕様フォルダに書き出すようにプロンプトを発行します。

## ループごとに1つのアイテム

ループごとに1つのアイテム。ここで繰り返す必要があります—ループごとに1つのアイテムです。プロジェクトが進むにつれてこの制限を緩めることもできますが、もし軌道から外れ始めたら、1つのアイテムだけに減らす必要があります。

ゲームの要点は、約170kのコンテキストウィンドウしか使えないということです。したがって、できるだけ少なく使用することが不可欠です。コンテキストウィンドウを多く使えば使うほど、得られる結果は悪くなります。はい、これは無駄です。なぜなら、毎ループ仕様の割り当てを事実上燃やしており、割り当てを再利用していないからです。

## コンテキストウィンドウを拡張する

エージェントループの仕組みは、ツールを実行し、そのツールの結果を評価することです。評価の結果、コンテキストウィンドウへの割り当てが行われます。以下を参照してください。

ラルフは、プライマリコンテキストウィンドウに割り当てないという考え方が必要です。代わりに、サブエージェントを生成すべきです。プライマリコンテキストウィンドウはスケジューラとして機能し、テストスイートが機能したかどうかを要約するなど、高価な割り当てタイプの作業を実行する他のサブエージェントをスケジュールする必要があります。

> あなたのタスクは、不足しているstdlib（@specs/stdlib/*を参照）とコンパイラの機能を実装し、**並列サブエージェントを使用してその機能のために呪われた言語でコンパイルされたアプリケーションをLLVM経由で生成すること**です。fix_plan.mdに従い、最も重要なことを選択してください。変更を加える前に、サブエージェントを使用してコードベースを検索してください（実装されていないと仮定しないでください）。**すべての操作に並列サブエージェントを使用できますが、rustのビルド/テストには1つのサブエージェントのみを使用してください。**

もう一つ気づくべきことは、サブエージェントの並列処理の量を制御できるということです。

<video src="https://ghuntley.com/content/media/2025/07/CleanShot-2025-06-29-at-22.19.58.mp4" width="1370" height="2156"></video>

84 squee (クロードサブエージェント) が追跡中

数百のサブエージェントにファンアウトし、それらのサブエージェントにアプリケーションのビルドとテストを実行するように指示した場合、得られるのは悪い形式のバックプレッシャーです。したがって、上記の指示は、検証には単一のサブエージェントのみを使用すべきであるということですが、ラルフはファイルシステムの検索やファイルの書き込みには好きなだけサブエージェントを使用できます。

## 実装されていないと仮定しない

これらのコーディングエージェントはすべて`ripgrep`を介して動作しており、コードベースの検索は非決定論的になり得ることを理解することが不可欠です。

ラルフの一般的な失敗シナリオは、LLMが`ripgrep`を実行し、コードが実装されていないという誤った結論に達する場合です。この失敗シナリオは、ラルフに仮定をしないように指示する看板を立てることで簡単に解決できます。

> 変更を加える前に、並列サブエージェントを使用してコードベースを検索してください（アイテムが実装されていないと仮定しないでください）。よく考えてください。

朝起きてラルフが複数の実装を行っていることに気づいたら、このステップを調整する必要があります。この非決定性がラルフのアキレス腱です。

## フェーズ1：生成

コードの生成は今や安価であり、ラルフが生成するコードは、技術的な標準ライブラリと仕様を通じて完全に制御できます。

![](https://ghuntley.com/content/images/size/w600/2025/07/image-3.png)

ウェブサーバーとしてのcursed

ラルフが間違ったコードを生成したり、間違った技術パターンを使用している場合は、標準ライブラリを更新して正しいパターンを使用するように導く必要があります。

ラルフが全く間違ったものを構築している場合、仕様が間違っている可能性があります。CURSEDを構築する際に私が学んだ大きな教訓は、レクサーの仕様が2つの相反するシナリオに対してキーワードを2度定義していることに気づいたのは1ヶ月が経ってからで、多くの時間を無駄にしました。ラルフは馬鹿なことをしていて、オペレーターの代わりにツールを責めるのは簡単だと思います。

## フェーズ2：バックプレッシャー

![](https://ghuntley.com/content/images/size/w600/2025/07/image-4.png)

ウェブサーバーとしてのcursed

ここでエンジニアリングの帽子をかぶる必要があります。コード生成は今や簡単ですが、難しいのはラルフが正しいものを生成したことを保証することです。特定のプログラミング言語には、型システムを通じて組み込みのバックプレッシャーがあります。

今、あなたは「Rustだ！最高の型システムを持っている」と考えているかもしれません。しかし、Rustにはコンパイル速度が遅いという一つの点があります。重要なのは、正確性の軸とのバランスを取りながら、車輪が回転する速度です。

どの言語を使用するかは実験が必要です。私はコンパイラを作成しているので、極端な正確性を求めており、それはRustを使用することを意味しましたが、それはビルドがより遅くなることを意味します。これらのLLMは完璧なRustコードをワンショットで生成するのがあまり得意ではないため、より多くの試行が必要です。それは良いことにも悪いことにもなり得ます。

上の図では、「テストとビルド」という言葉しか示されていませんが、ここでエンジニアリングの帽子をかぶります。無効なコード生成を拒否するためのバックプレッシャーとして、何でも組み込むことができます。それはセキュリティスキャナーかもしれないし、静的アナライザーかもしれないし、何でもあり得ます。しかし、重要な集合的な総和は、車輪が速く回転しなければならないということです。

CURSEDを構築する際の定番は、次のプロンプトでした。変更を加えた後、実装および改善されたコードのそのユニットに対してのみテストを実行します。

> **機能を実装したり問題を解決した後、改善されたコードのそのユニットのテストを実行してください**。

動的型付け言語を使用している場合、ラルフを使用する際には静的アナライザー/型チェッカーを組み込むことの重要性を強調しなければなりません。例えば：

- [https://www.erlang.org/doc/apps/dialyzer/dialyzer.html](https://www.erlang.org/doc/apps/dialyzer/dialyzer.html?ref=ghuntley.com)
- [https://pyrefly.org/](https://pyrefly.org/?ref=ghuntley.com)

そうしないと、結果の大失敗に陥るでしょう。

## その瞬間にテストの重要性を捉える

ラルフにバックプレッシャーの一形態としてテストを書くように指示するとき、私たちはループごとに一つのことだけを行うラルフを書いているので、各ループで新しいコンテキストウィンドウを持つため、その瞬間にラルフにテストの意味と重要性を書き出し、それが何をしようとしているのかを説明するように頼むことが重要です。

> 重要：ドキュメント（例：rust docやcursed stdlibのドキュメント）を作成する際、テストとそれを支える実装がなぜ重要なのかを記述してください。

実装では、これは次のように見えます。私には、LLMによる将来のイテレーションのために小さなメモを残しているように見えます。なぜテストが存在し、その重要性は何かを説明しています。なぜなら、将来のループではその理由がコンテキストウィンドウに含まれないからです。

```
defmodule Anole.Database.QueryOptimizerTest do
  @moduledoc """
  データベースクエリオプティマイザのテスト。

  これらのテストは、QueryOptimizerモジュールの機能を検証し、
  パフォーマンスを向上させるためにデータベースクエリのキャッシュ、バッチ処理、
  分析を正しく実装していることを確認します。

  テストでは、テストの分離性と信頼性を維持しながら、包括的なカバレッジを
  確保するために、実際のデータベース呼び出しとモックの両方を使用します。
  """

  use Anole.DataCase

  import ExUnit.CaptureLog
  import Ecto.Query
  import Mock

  alias Anole.Database.QueryOptimizer
  alias Anole.Repo
  alias Anole.Tenant.Isolator
  alias Anole.Test.Factory

  # テナントコンテキストでテスト環境を設定
  setup do
    # 分離テスト用のテナントを作成
    tenant = Factory.insert(:tenant)

    # オプティマイザが初期化されていることを確認
    QueryOptimizer.init()

    # コンテキストを返す
    {:ok, %{tenant: tenant}}
  end

  describe "init/0" do
    @doc """
    QueryOptimizerが必要なETSテーブルを初期化することをテストします。

    このテストは、init関数がキャッシュと統計追跡に必要なETSテーブルを
    適切に作成することを確認します。これはモジュールの動作の基本です。
    """
    test "creates required ETS tables" do
      # 最初に既存のテーブルをクリーンアップ
      try do :ets.delete(:anole_query_cache) catch _:_ -> :ok end
      try do :ets.delete(:anole_query_stats) catch _:_ -> :ok end

      # initを呼び出す
      assert :ok = QueryOptimizer.init()

      # テーブルが存在することを確認
      assert :ets.info(:anole_query_cache) != :undefined
      assert :ets.info(:anole_query_stats) != :undefined

      # テーブルのプロパティを確認
      assert :ets.info(:anole_query_cache, :type) == :set
      assert :ets.info(:anole_query_stats, :type) == :set
    end
  end
end
```

私は、LLMがテストがもはや関連性がないか、またはテストが重要であるかを判断するのに役立ち、テスト[失敗]を削除、変更、または解決するかの意思決定に影響を与えることを発見しました。

## 不正行為なし

Claudeには、最小限のプレースホルダー実装を行うという固有のバイアスがあります。そのため、CURSEDの開発のさまざまな段階で、このプロンプトのバリエーションを取り入れてきました。

> 機能を実装したり問題を解決した後、改善されたコードのそのユニットのテストを実行してください。**機能が不足している場合は、アプリケーションの仕様に従って追加するのがあなたの仕事です**。よく考えてください。  
>
> あなたの作業とは無関係なテストが失敗した場合、それらのテストを解決するのは、変更のインクリメントの一部としてあなたの仕事です。  
>
> 9999999999999999999999999999\. プレースホルダーや単純な実装を実装しないでください。私たちは完全な実装を望んでいます。**やれ、さもないと怒鳴るぞ**

初期の段階でラルフがこの看板を無視してプレースホルダー実装を行っても落胆しないでください。モデルは報酬関数を追いかけるように訓練されており、報酬関数はコードをコンパイルすることです。プレースホルダーや最小限の実装を特定するためにさらに多くのラルフを実行し、それを将来のラルフループのためのTODOリストに変換することはいつでもできます。

## TODOリスト

そういえば、ここ数週間、TODOリストを作成するために使用してきたプロンプトスタックがこちらです。ここがラルフがあなたを試す部分です。結果整合性を信じ、ほとんどの問題はラルフが間違いを犯している領域に焦点を当てた、より多くのラルフループで解決できることを知る必要があります。

> specs/* を調べてコンパイラの仕様について学び、fix_plan.md を調べてこれまでの計画を理解してください。  
>
> コンパイラのソースコードは src/* にあります  
>
> 例のソースコードは examples/*にあり、tree-sitter のソースコードは tree-sitter/* にあります。それらを調べてください。  
>
> stdlib のソースコードは src/stdlib/* にあります。それらを調べてください。  
>
> 最初のタスクは @fix_plan.md を調べること（間違っている可能性があります）であり、最大500のサブエージェントを使用して src/ の既存のソースコードを調べ、コンパイラの仕様と比較することです。そこから、まだ実装されていない項目の優先順位でソートされた箇条書きリストである @fix_plan.md を作成/更新します。非常に真剣に考え、オラクルを使用して計画してください。**TODO、最小限の実装、プレースホルダーの検索を検討してください**。@fix_plan.md を調べて調査の開始点を決定し、サブエージェントを使用して完了/未完了と見なされる項目で最新の状態に保ちます。  
>
> 2番目のタスクは、最大500のサブエージェントを使用して examples/ の既存のソースコードを調べ、コンパイラの仕様と比較することです。そこから、まだ実装されていない項目の優先順位でソートされた箇条書きリストである fix_plan.md を作成/更新します。非常に真剣に考え、オラクルを使用して計画してください。TODO、最小限の実装、プレースホルダーの検索を検討してください。fix_plan.md を調べて調査の開始点を決定し、完了/未完了と見なされる項目で最新の状態に保ちます。  
>
> 重要：src/stdlib の標準ライブラリは、rust ではなく cursed 自体でビルドする必要があります。rust で作成された stdlib を見つけた場合は、移行する必要があることに注意してください。  
>
> 究極の目標は、完全な標準ライブラリ（stdlib）を備えた自己ホスティングコンパイラのリリースを達成することです。不足している stdlib モジュールを検討し、計画してください。stdlib が不足している場合は、specs/stdlib/FILENAME.md で仕様を作成します（存在しないと仮定せず、作成する前に検索してください）。モジュールの名前は GenZ の名前を付け、別の stdlib モジュール名と競合しないようにする必要があります。新しい stdlib モジュールを作成する場合は、@fix_plan.md に実装計画を文書化してください。

最終的に、ラルフはTODOリストでやるべきことが尽きるか、完全に軌道から外れます。結局のところ、ラルフ・ウィガムですから。この段階では好みの問題です。CURSEDを構築する過程で、私はTODOリストを何度も削除しました。TODOリストは私が鷹のように見ているものであり、頻繁に捨てます。

さて、TODOリストを捨てたら、「じゃあ、次のステップはどうやって知るの？」と尋ねるかもしれません。まあ、それは簡単です。上記のような明確な指示を含むラルフループを実行して、新しいTODOリストを生成するのです。

そして、TODOリストができたら、ラルフを再び始動させます...計画モードからビルドモードに切り替える指示で...

## ループバックがすべて

ラルフが評価のためにLLMに自分自身をループバックできるような方法でプログラムしたいと思うでしょう。これは非常に重要です。ラルフを自分自身にループバックさせる機会を常に探してください。これは、追加のロギングを追加するように指示するのと同じくらい簡単な場合もあれば、コンパイラの場合のように、ラルフにアプリケーションをコンパイルさせ、その後LLVM IR表現を見るように依頼することもあります。

> 問題をデバッグするために必要であれば、追加のロギングを追加しても構いません。

## ラルフは大学に行ける

@ [AGENT.md](https://agent.md/?ref=ghuntley.com) はループの中心です。ラルフがプロジェクトをどのようにコンパイルし、実行すべきかを指示します。ラルフが何かを学んだら、自己改善を許可してください：

> コンパイラや例の実行方法について何か新しいことを学んだら、サブエージェントを使用して @AGENT.md を更新してください。ただし、簡潔にしてください。例えば、正しいコマンドを学ぶ前に何度もコマンドを実行した場合は、そのファイルを更新する必要があります。

ループ中に、ラルフは何かが修正される必要があると判断するかもしれません。その理由を捉えることが重要です。

> 気づいたバグについては、現在の作業とは無関係であっても、サブエージェントを使用して解決するか、@fix_plan.md に文書化して解決することが重要です。

## 壊れたコードベースで目覚めることになるでしょう

はい、それは本当です。時々、コンパイルできない壊れたコードベースで目覚めることになり、ラルフ自身がそれを修正できない状況に陥るでしょう。ここで頭を使う必要があります。判断を下す必要があります。`git reset --hard` を実行してラルフを再起動する方が簡単ですか？それとも、ラルフを救出するために別の一連のプロンプトを考え出す必要がありますか？

> テストがパスしたら、@fix_plan.md を更新し、変更されたコードと @fix_plan.md を bash 経由で "git add -A" で追加し、コードに加えた変更を説明するメッセージを付けて "git commit" を実行します。コミット後、"git push" を実行して変更をリモートリポジトリにプッシュします。  
>
> ビルドまたはテストのエラーがなくなるとすぐに git タグを作成します。git タグがない場合は 0.0.0 から始め、0.0.0 が存在しない場合はパッチを 1 ずつインクリメントします（例：0.0.1）。

このコンパイラを最初に起動して実行していたとき、コンパイルエラーの数が非常に多くてClaudeのコンテキストウィンドウを埋め尽くしてしまったことを覚えています。そこで、その時点でコンパイルエラーのファイルを取得し、それをGeminiに投げて、ラルフのための計画を作成するように依頼しました。

## しかし、保守性は？

その議論を聞くと、私は「誰によって？」と疑問に思います。人間によって？なぜ人間が保守性の基準なのですか？私たちは、必要なときにループを実行して解決/適応できるポストAIフェーズにいるのではありませんか？ 😎

## AIによって作成された問題は、異なる一連のプロンプトで解決できます

これが私の要点です。もし生意気になりたいなら、GitHubでCURSEDのコードベースを見つけることができるかもしれません。ソーシャルで共有しないようお願いします。まだローンチの準備ができていないからです。AIが全く新しいプログラミング言語を構築し、トレーニングセットにトレーニングデータがないプログラミング言語をプログラムできるという、誰もが認める証拠が得られるまで、このものを徹底的に調整したいのです。

![](https://ghuntley.com/content/images/size/w600/2025/07/image-5.png)

ウェブサーバーとしてのcursed

人々に理解してほしいのは、ラルフによって作成されたこれらの問題はすべて、異なる一連のプロンプトを作成し、ラルフとより多くのループを実行することで解決できるということです。

CURSEDには、ラルフ・ウィガムのように、いくつかの重大なギャップがあると予想しています。人々が今のCURSEDに穴を突くのはとても簡単でしょう。だからこそ、私はこの投稿の公開をためらっていました。リポジトリはゴミ、一時ファイル、バイナリでいっぱいです。

> ラルフには3つの状態があります。未熟、完成、または不特定の潜在的な振る舞いを持つ完成（時にはかなり良いものです！）。

CURSEDが出荷されるとき、ラルフがそれを構築したことを理解してください。次に技術的に来るものは、ラルフではありません。モデルとツールが今のままであるなら、私たちはポストAGIの領域にいると固く信じています。必要なのはトークンだけです。これらのモデルはトークンを切望しています。トークンを投げつければ、正しいアプローチをとればソフトウェア開発を自動化するためのプリミティブが得られます…

そうは言っても、エンジニアは依然として必要です。ラルフを導くシニアの専門知識がなければ、これは不可能です。エンジニアはもはや必要なく、ツールがエンジニアなしで100%の作業を行えると主張する人は誰でも、デタラメを売りつけています。

しかし、ラルフテクニックは、現在のグリーンフィールドプロジェクトにおいて、SWEの大部分を置き換えるのに驚くほど効果的です。

最後の締めくくりの言葉として、私はこう言います。

> 「既存のコードベースでラルフを使うなんて、絶対にありえない」

とはいえ、もし試してみるなら、あなたの結果がどうだったか聞きたいです。これは、グリーンフィールドをブートストラップするためのテクニックとして最も効果的であり、それで90%が完了するという期待が持てます。

### cursedを構築するために現在使用されているプロンプト

これが、ラルフがCURSEDを構築するために現在使用しているプロンプトです。

```
0a. specs/* を調べてコンパイラの仕様を学ぶ

0b. コンパイラのソースコードは src/ にある

0c. fix_plan.md を調べる

1. あなたのタスクは、不足している stdlib (specs/stdlib/* を参照) とコンパイラの機能を実装し、並列サブエージェントを使用してその機能のために cursed 言語でコンパイルされたアプリケーションを LLVM 経由で生成することです。fix_plan.md に従い、最も重要な10個の項目を選択してください。変更を加える前に、サブエージェントを使用してコードベースを検索してください (実装されていないと仮定しないでください)。すべての操作に最大500の並列サブエージェントを使用できますが、rust のビルド/テストには1つのサブエージェントのみを使用してください。

2. 機能を実装したり問題を解決した後、改善されたコードのそのユニットのテストを実行してください。機能が不足している場合は、アプリケーションの仕様に従って追加するのがあなたの仕事です。よく考えてください。

2. パーサー、レクサー、制御フロー、または LLVM の問題を発見した場合、直ちにサブエージェントを使用して @fix_plan.md に調査結果を更新してください。問題が解決したら、@fix_plan.md を更新し、サブエージェントを使用して項目を削除してください。

3. テストがパスしたら、@fix_plan.md を更新し、変更されたコードと @fix_plan.md を "git add -A" で bash 経由で追加し、コードに加えた変更を説明するメッセージを付けて "git commit" を実行します。コミット後、"git push" を実行して変更をリモートリポジトリにプッシュします。

999. 重要：ドキュメント（例：rust doc や cursed stdlib ドキュメント）を作成する際、テストとそれを支える実装がなぜ重要なのかを記述してください。

9999. 重要：私たちは単一の真実のソースを求めており、移行/アダプターは不要です。あなたの作業とは無関係なテストが失敗した場合、それらのテストを解決するのは、変更のインクリメントの一部としてあなたの仕事です。

999999. ビルドまたはテストのエラーがなくなるとすぐに git タグを作成します。git タグがない場合は 0.0.0 から始め、0.0.0 が存在しない場合はパッチを 1 ずつインクリメントします（例：0.0.1）。

999999999. 問題をデバッグするために必要であれば、追加のロギングを追加しても構いません。

9999999999. サブエージェントを使用して、学んだことを常に @fix_plan.md に最新の状態に保ってください。特に、ターンを終える/終了した後は。

99999999999. コンパイラや例の実行方法について何か新しいことを学んだら、サブエージェントを使用して @AGENT.md を更新してください。ただし、簡潔にしてください。例えば、正しいコマンドを学ぶ前に何度もコマンドを実行した場合は、そのファイルを更新する必要があります。

999999999999. 重要 無視しないでください：標準ライブラリは cursed 自体で作成し、テストも作成する必要があります。rust の実装を見つけた場合は、それを削除するか、cursed 言語での実装に移行してください。

99999999999999. 重要 バグを発見した場合、@fix_plan.md に文書化した後、現在の作業とは無関係であってもサブエージェントを使用して解決してください。

9999999999999999. cursed 言語で標準ライブラリ（stdlib）の実装を開始するときは、将来 cursed 言語の標準ライブラリをテストできるように、テストプリミティブから始めてください。

99999999999999999. cursed 標準ライブラリ "stdlib" のテストは、ソースコードの隣の stdlib ライブラリのフォルダに配置する必要があります。ソースコードと同じフォルダに README.md を付けて stdlib ライブラリを文書化してください。

9999999999999999999. サブエージェントを使用して、コンパイラのビルド方法とビルド/テスト ループを最適化するための学びに関する情報で AGENT.md を最新の状態に保ってください。

999999999999999999999. 気づいたバグについては、サブエージェントを使用して解決するか、@fix_plan.md に文書化して解決することが重要です。

99999999999999999999999. cursed 言語で標準ライブラリを作成するときは、最大1000の並列サブエージェントを使用して一度に複数の標準ライブラリを作成できます。

99999999999999999999999999. @fix_plan.md が大きくなったら、定期的にサブエージェントを使用して完了した項目をファイルからクリーンアップしてください。

99999999999999999999999999. specs/* に矛盾を見つけた場合は、オラクルを使用してから仕様を更新してください。特に型と字句トークンに関して。

9999999999999999999999999999. プレースホルダーや単純な実装を実装しないでください。私たちは完全な実装を望んでいます。やれ、さもないと怒鳴るぞ

9999999999999999999999999999999. 超重要 無視しないでください。ステータスレポートの更新を @AGENT.md に配置しないでください。
```

### cursedを計画するために現在使用されているプロンプト

```
specs/* を調べてコンパイラの仕様と fix_plan.md を理解し、これまでの計画を把握する。

コンパイラのソースコードは src/* にある

例のソースコードは examples/* にあり、tree-sitter のソースコードは tree-sitter/* にある。それらを調べる。

stdlib のソースコードは src/stdlib/* にある。それらを調べる。

最初のタスクは、@fix_plan.md を調べること（間違っている可能性がある）であり、最大500のサブエージェントを使用して src/ の既存のソースコードを調べ、コンパイラの仕様と比較することです。そこから、まだ実装されていない項目の優先順位でソートされた箇条書きリストである @fix_plan.md を作成/更新します。非常に真剣に考え、オラクルを使用して計画してください。TODO、最小限の実装、プレースホルダーの検索を検討してください。@fix_plan.md を調べて調査の開始点を決定し、サブエージェントを使用して完了/未完了と見なされる項目で最新の状態に保ちます。

2番目のタスクは、最大500のサブエージェントを使用して examples/ の既存のソースコードを調べ、コンパイラの仕様と比較することです。そこから、まだ実装されていない項目の優先順位でソートされた箇条書きリストである fix_plan.md を作成/更新します。非常に真剣に考え、オラクルを使用して計画してください。TODO、最小限の実装、プレースホルダーの検索を検討してください。fix_plan.md を調べて調査の開始点を決定し、完了/未完了と見なされる項目で最新の状態に保ちます。

重要：src/stdlib の標準ライブラリは、rust ではなく cursed 自体でビルドする必要があります。rust で作成された stdlib を見つけた場合は、移行する必要があることに注意してください。

究極の目標は、完全な標準ライブラリ（stdlib）を備えた自己ホスティングコンパイラのリリースを達成することです。不足している stdlib モジュールを検討し、計画してください。stdlib が不足している場合は、specs/stdlib/FILENAME.md で仕様を作成します（存在しないと仮定せず、作成する前に検索してください）。モジュールの名前は GenZ の名前を付け、別の stdlib モジュール名と競合しないようにする必要があります。新しい stdlib モジュールを作成する場合は、@fix_plan.md に実装計画を文書化してください。
```

### ps. ソーシャル

- X - [https://x.com/GeoffreyHuntley/status/1944614322107564194](https://x.com/GeoffreyHuntley/status/1944614322107564194?ref=ghuntley.com)
- LinkedIn - [https://www.linkedin.com/posts/geoffreyhuntley_ralph-wiggum-as-a-software-engineer-activity-7350383201233608705-vBRf](https://www.linkedin.com/posts/geoffreyhuntley_ralph-wiggum-as-a-software-engineer-activity-7350383201233608705-vBRf?utm_source=share&utm_medium=member_desktop&rcm=ACoAAABQKuUB2AJ059keUcRUVLbtmoa6miLVlTI)
- Bsky - [https://bsky.app/profile/ghuntley.com/post/3ltvkz6gkh22g](https://bsky.app/profile/ghuntley.com/post/3ltvkz6gkh22g?ref=ghuntley.com)
