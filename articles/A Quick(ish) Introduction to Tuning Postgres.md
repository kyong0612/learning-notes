---
title: "A Quick(ish) Introduction to Tuning Postgres"
source: "https://byteofdev.com/posts/tuning-postgres-intro/"
author:
  - "Jacob Jackson"
published: 2025-07-22
created: 2025-08-04
description: |
  PostgreSQLのパフォーマンスチューニングの最も重要な要素のいくつかについて学び、その過程でPostgreSQLの基礎をより深く理解します。
tags:
  - "PostgreSQL"
  - "database"
  - "performance-tuning"
  - "linux"
  - "io_uring"
---
## PostgreSQL パフォーマンスチューニング入門

このガイドでは、PostgreSQLのパフォーマンスチューニングにおける最重要項目に焦点を当て、その内部的な仕組みと関連性を解説します。

### なぜPostgreSQLは低速になるのか？

データベースのパフォーマンス低下には、主に3つの原因があります。

1. **ディスクアクセス**:
    ストレージメディアの速度がデータベース性能の上限を決定します。PostgreSQLはRAMキャッシングでディスクI/Oを削減しようとしますが、キャッシュ設定が不適切だとパフォーマンスが低下します。

2. **ユーザ空間とカーネルの通信**:
    OSとデータベース間のインターフェースであるシステムコール（syscall）は、コンテキストスイッチを伴うため非常に低速です。チューニングにより、これらのコストが高い処理を最小限に抑えることができます。

3. **リソースの競合**:
    複数のクエリスレッドが共有リソース（メモリキャッシュやファイル）に同時にアクセスしようとすると競合が発生します。PostgreSQLはロック機構でこれを防ぎますが、ロック待ちはパフォーマンスのボトルネックとなり得ます。

### メモリ割り当ての最適化

PostgreSQLのメモリ設定を最適化することで、高コストなディスクアクセスを回避し、パフォーマンスを大幅に向上させることができます。

#### `shared_buffers` の増加

- **目的**: ディスクから読み込んだデータページをキャッシュするための共有メモリプールサイズを制御します。
- **推奨設定**: システムRAMの25〜40%。デフォルトの128MBから増やすことでキャッシュヒット率が向上し、ディスクI/Oが大幅に削減されます。
- **設定例**: `ALTER SYSTEM SET shared_buffers = '16GB';`
- **効果**: ベンチマークでは、`shared_buffers`を増やすことでスループット（TPS）が55%向上し、ディスク読み込みが90%以上削減されました。

#### `work_mem` の増加

- **目的**: ソートやハッシュ結合など、クエリ内の各操作が使用できるメモリ量を設定します。
- **仕組み**: この制限を超えると、PostgreSQLは低速なディスク上の一時ファイルを使用します。
- **推奨設定**: 複雑なクエリを実行するシステムでは、この値を増やすことでディスクへのデータ退避を防ぎ、クエリ速度を向上させます。

### ディスク効率の向上

ディスクアクセスを完全に避けることはできないため、ディスクI/O自体の効率を高めることが重要です。

#### `io_uring` による非同期I/O

- **概要**: PostgreSQL 18で利用可能になるLinuxの新しい非同期I/Oインターフェースです。
- **仕組み**: I/O操作を待たずにクエリ処理を継続できるため、コンテキストスイッチの削減、データコピーの不要化、I/O待ち時間の有効活用が可能になります。
- **効果**: I/O負荷の高いワークロードにおいて、7%以上の性能向上が期待できます。
- **設定**: `io_method` を `io_uring` に設定します（Linux 5.1以降が必要）。

#### ヒュージページ

- **目的**: OSのメモリページサイズを標準の4kBから2MBなどに拡大し、メモリ管理のオーバーヘッドを削減します。
- **効果**: 大量にメモリを使用するデータベースにおいて、I/Oパフォーマンスが向上します。
- **設定**: LinuxカーネルでTransparent Huge Pages (THP) を無効にし、`vm.nr_hugepages` を適切に設定した上で、PostgreSQLの `huge_pages` を `on` にします。

### クエリ処理の最適化

クエリプランナの動作を調整し、CPUリソースを最大限に活用することで、クエリ処理を高速化します。

#### CPUコア使用率のチューニング

- **目的**: 複数のCPUコアを並列処理に活用します。
- **設定**: `max_worker_processes` や `max_parallel_worker_processes` をサーバーのCPUスレッド数に合わせて増やすことで、並列クエリの性能を最大限に引き出します。

#### クエリプランナのコスト計算の調整

- **`random_page_cost`**:
  - **目的**: ランダムなディスクアクセスにかかるコストを定義します。
  - **推奨設定**: SSD環境では、ランダムアクセスとシーケンシャルアクセスの速度差がほとんどないため、デフォルトの `4` から `1.1` や `1` に下げるべきです。これにより、インデックススキャンがより適切に選択されるようになります。

- **`effective_cache_size`**:
  - **目的**: PostgreSQLが利用可能と推定するキャッシュサイズ（`shared_buffers` + OSのファイルシステムキャッシュ）をプランナに伝えます。
  - **推奨設定**: システムRAMの60%程度。正確な値を設定することで、プランナはより最適な実行計画を立てることができます。

### まとめ

PostgreSQLのパフォーマンスチューニングは、データベースの内部動作を深く理解し、継続的にテストと測定を繰り返すプロセスです。このガイドで紹介した主要なパラメータを調整することで、システムのパフォーマンスを大幅に改善し、より安定した運用を実現することができます。
