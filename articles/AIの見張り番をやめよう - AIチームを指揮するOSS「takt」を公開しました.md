---
title: "AIの見張り番をやめよう - AIチームを指揮するOSS「takt」を公開しました"
source: "https://zenn.dev/nrs/articles/c6842288a526d7"
author:
  - "[[nrs]]"
published: 2026-01-27
created: 2026-01-30
description: "AIエージェントが指示を忘れたり、用意したツールを使ってくれない問題を解決するため、強制力のあるワークフローでマルチエージェント開発の再現性と品質を担保するOSSツール「takt」を公開。Claude CodeとOpenAI Codexに対応し、YAML形式でワークフローを定義することで、複数のAIエージェントを指揮者のように統制する。"
tags:
  - "clippings"
  - "AI"
  - "OSS"
  - "Claude Code"
  - "Codex"
  - "AIオーケストレーション"
  - "マルチエージェント"
  - "ワークフロー自動化"
---

## 概要

「takt」は、AIエージェントに強制力のあるワークフローを与えることで、マルチエージェント開発の再現性と品質を担保するOSSツール。名前は指揮者のタクト（指揮棒）に由来し、「Task Agent Koordination Tool」の略。

**GitHub**: https://github.com/nrslib/takt

## 背景と課題

### AIエージェントとの日々の格闘

- AIエージェントは便利だが、「与えた役割を忘れる」「共有した知識が抜け落ちる」「一度指摘したことをまたやらかす」という問題がある
- 複数プロジェクトを並行すると、常にAIからの質問や権限許可要求を処理する「見張り番」状態に
- AIに仕事を任せているはずが、AIの面倒を見ている状態になってしまう

### AIに見張り番をやらせる試みの失敗

- サブエージェントやSkillを用意しても、使ってくれるときと無視するときがある
- 「お願い」ベースでは再現性がない
- 結局、人間が進捗を確認し続ける必要があった

## 解決策：「強制力」という発想

**核心的な洞察**: AIに判断を委ねるのではなく、ワークフローとして強制すれば、気まぐれにレビューをスキップされることがなくなる。

- 「コードを書く→レビューする→修正する」の流れを事前定義
- AIが自分で使うか判断するのではなく、仕組みとして強制
- 決定権をAIではなくワークフローに移す

## taktの主要機能

### 1. ワークフロー定義（YAML形式）

```yaml
name: code-review
description: コードを書いてレビューするワークフロー
max_iterations: 10
steps:
  - name: write-code
    agent: ~/.takt/agents/default/coder.md
    instruction_template: |
      次のタスクを実行してください。
      {task}
    status_rules_prompt: |
      # ⚠️必須: ステータス出力ルール⚠️
      | 状況 | タグ |
      |------|------|
      | 実装完了 | `[CODER:DONE]` |
    transitions:
      - condition: done
        next_step: review
  - name: review
    agent: ~/.takt/agents/default/supervisor.md
    # ...
```

**ポイント**:
- `status_rules_prompt`でエージェントにステータスマーカーを出力させ、遷移を制御
- `max_iterations`で無限ループを防止

### 2. ビルトインエージェント

| エージェント | 役割 |
|------------|------|
| coder | コード実装特化 |
| architect | 設計・レビュー・フィードバック |
| supervisor | 最終検証と承認 |
| planner | タスク分析と計画 |
| ai-reviewer | AI生成コード専門レビュー |
| security | セキュリティレビュー |

### 3. カスタムエージェント

- `~/.takt/agents/`にMarkdownファイルを置くだけ
- `.claude/`配下のSkillファイルもそのままエージェントとして使用可能

### 4. ステップ間のコンテキスト受け渡し

| 変数 | 用途 |
|------|------|
| `{previous_response}` | 前ステップの出力 |
| `{task}` | 元のタスク内容 |
| `{git_diff}` | 未コミットの変更差分 |
| `{iteration}` | 現在のイテレーション回数 |

### 5. Claude CodeとOpenAI Codex両対応

- プロバイダーの違いは抽象化済み
- ステップごとにモデルを変更可能（例：設計はOpus、実装はSonnet）

### 6. タスクのバッチ実行

```bash
takt /run-tasks
```

- `.takt/tasks/`内のタスクを順次処理
- 番号プレフィックスで実行順序を制御
- 実行中でもタスク追加可能

### 7. 監視モード

```bash
takt /watch
```

- ディレクトリを監視し、タスク追加を自動検出・実行
- CI/CDパイプライン連携に適用

### 8. 実行レポート自動生成

- `.takt/reports/`にMarkdown形式で記録
- 各ステップの処理内容を振り返り可能

## チュートリアル

### 前提条件

- Node.js 18以上
- Claude CodeまたはOpenAI Codexがインストール・設定済み

### インストール

```bash
npm install -g takt
```

### 初期設定

初回実行時に言語（日本語/英語）とプロバイダー（Claude Code/Codex）を選択。`~/.takt/config.yaml`が作成される。

### 主要コマンド

| コマンド | 説明 |
|---------|------|
| `takt "タスク内容"` | タスク実行 |
| `takt /switch` | デフォルトワークフロー切替 |
| `takt /add-task` | タスク追加 |
| `takt /run-tasks` | バッチ実行 |
| `takt /watch` | 監視モード |
| `takt /refresh-builtin` | ビルトイン更新 |

## 他のオーケストレーションとの違い

### taktの思想

- 多くのシステムはAIに自由度を与える方向
- **taktは逆**：AIの自由度をあえて排除し、定義されたワークフローに従わせる
- 「AIを信頼しつつ、仕組みで担保する」アプローチ

### Claude Code Swarmとの違い

| 項目 | Swarm | takt |
|------|-------|------|
| 重点 | エージェント間の動的協調 | 事前定義ワークフローの確実な実行 |
| 適用領域 | 探索的・創造的作業 | 定型的な開発フロー |

## おまけ：MAGIシステム

エヴァンゲリオンのMAGIにインスパイアされた審議システム。3つのペルソナが異なる視点から分析・投票：

- **MELCHIOR-1（Scientist）**: 論理的・データ駆動の視点
- **BALTHASAR-2（Nurturer）**: チーム・人間中心の視点
- **CASPER-3（Pragmatist）**: 実用的・現実的な視点

## 著者の使用体験

- 3つのプロジェクトを並行して、各プロジェクトにAIエージェントチームを割り当て
- タスクを投げて最終成果物を確認するだけ
- 途中の「どうしますか？」というやり取りが大幅に減少
- この記事自体もtaktを使って執筆（著者エージェント→専門知識レビュアー→編集エージェントのワークフロー）

## 制限事項

- ワークフロー設計を間違えると期待どおりの結果にならないことがある
- 最終的な人間によるレビューは自動化できていない

## 著者情報

**nrs** - プログラマ。ソフトウェア設計を得意領域とし、YouTubeチャンネル「なるセミ」で講演活動を行う。著書『ドメイン駆動設計入門 ボトムアップでわかる！ドメイン駆動設計の基本』
