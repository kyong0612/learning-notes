---
title: "なぜ、Claude Codeは、RAGを捨ててAgentic Searchを選んだのか？"
source: "https://zenn.dev/karamage/articles/2514cf04e0d1ac"
author:
  - "[[karamage]]"
published: 2026-02-07
created: 2026-02-10
description: "Claude Code開発者Boris Cherny氏の発言を起点に、Claude Codeが従来の王道RAG（Embedding＋ベクトルDB＋セマンティック検索）を捨ててAgentic Searchを採用した理由を解説。精度・セキュリティ・鮮度の観点から両者の違いと使い分けを整理した記事。"
tags:
  - "clippings"
  - "Claude Code"
  - "RAG"
  - "Agentic Search"
  - "LLM"
  - "AI"
---

## 要約

### 背景：Boris Cherny氏の発言

Claude Codeの創設者でありAnthropicのエンジニアであるBoris Cherny氏が、**「初期のClaude CodeではRAG＋ローカルベクターDBを使っていたが、最終的にAgentic Searchの方が圧倒的に良いと分かった」**と発言した。彼は『Programming TypeScript』の著者でもあり、この発言はAnthropicの1stエンジニアによるプロダクト設計哲学と言える。

---

### そもそもRAGとは何か

**RAG（Retrieval Augmented Generation）** = 検索強化生成。以下の3ステップで構成される「王道RAG」が一般的：

1. **Embedding**：文章を意味を表す数値の並び（ベクトル）に変換。似た意味の文章は「意味空間」上で近くに配置される
2. **ベクトルDB**：Embeddingした数値データを専用データベースに保存（「IDと意味ベクトル」を管理）
3. **セマンティック検索**：ユーザーの質問もEmbeddingし、ベクトルDB内で距離が最も近い（＝意味が似ている）文書を検索

> たとえるなら「巨大な電子書庫を持ったAI」。質問に沿った参考書を取り出して要約してくれる仕組み。

---

### Agentic Searchとは何か

**Agentic Search** = AIが自分で考えて検索行動を組み立てる方式。事前のデータ保存やインデックス構築を必ずしも必要としない。

**動作の特徴：**

- **目的分解と計画形成**：問題を小さなタスクに分解し、解決計画を立てる
- **マルチステップ探索と修正**：情報不足や矛盾があれば別の検索・検証を繰り返す
- **動的ツール統合**：`grep`、`glob`、Web Searchなど状況に応じて最適なツールを使い分ける
- **サブエージェントによる要約・整理**：大きなファイルや複雑なデータを効率的に処理

> 人間のエンジニアがコードを調査するときの行動を、そのままAIにやらせているイメージ。

---

### RAGとAgentic Searchの違い

| 観点 | 王道RAG | Agentic Search |
|---|---|---|
| 方式 | 質問→ベクトル検索→関連文書取得→回答生成（1サイクル完結） | AI自身が探索計画を組み立て、何度もツールを呼び出しながら探索 |
| 前処理 | 必須（Embedding＋ベクトルDB構築） | 不要（または最小限） |
| 検索手法 | セマンティック検索（意味的類似度） | grep、glob、ファイル構造探索など複合的 |
| 構造理解 | テキストの意味的類似性のみ | ファイル・ディレクトリ構造や依存関係も文脈として活用 |
| インデックス管理 | 必要（鮮度維持のコスト大） | 不要 |

**試験勉強に例えると：**
- **RAG** = 「積読準備して後でまとめ読み型（秀才タイプ）」。大量の参考書を事前に買い込むが、情報が古くなるリスクあり
- **Agentic Search** = 「ゼロからはじめる調査型（天才本能型アドリブタイプ）」。その場で調べて考えて繰り返す

---

### 「RAG」という言葉の2つの意味

議論が混乱する最大の理由は「RAG」の多義性にある：

1. **広い意味のRAG**：「外部情報を取得して生成に使う仕組み」全般。Agentic Searchもここに含まれる
2. **一般的な意味のRAG（王道RAG）**：「Embedding＋ベクトルDB＋類似検索」という特定の構成

> **Claude Codeが捨てたのは「王道RAG」であって、「情報を取得して使う設計」そのものではない。**

---

### なぜ王道RAGが問題になるのか

著者自身の実体験から：

- **ノイズの混入**：運用が進むと仕様変更前のドキュメント、廃止済みAPIの説明など古い情報がヒットする
- **ハルシネーションの助長**：LLMはノイズを区別できず、「それっぽいけど間違っている回答」が量産される
- **コンテキスト汚染**：ハズレを引くたびに検索し直す「当たりを引くまで引き直す」構造がコンテキストを汚し、トークン消費・コスト増大を招く

---

### Claude Codeが王道RAGを捨てた4つの理由

1. **精度**：コード検索では「意味的に近い」より「正確に一致する」ことが重要。RAGの意味検索はノイズになりやすい
2. **セキュリティ**：コードをベクターDBに保存しない設計でシンプルに。企業向けで極めて重要
3. **プライバシー**：RAGの埋め込みデータ自体が情報漏洩・データポイゾニングのリスクになり得る
4. **鮮度と信頼性**：インデックスは必ず古くなる。コードが頻繁に変わる現場では致命的

---

### Agentic Searchが優位になった背景

- **LLMの性能向上**：モデル自身が文脈を広く深く理解できるようになった
- **運用のシンプルさ**：前処理やインデックス管理という見えないコストが不要
- **トークン単価の低下**：grepを多用してトークンが増えてもコスト問題は年々緩和

---

### 結論：王道RAGは死んでいない

- **ドキュメント検索・ナレッジ管理**では今でも王道RAGが最強
- **コードのように構造化された世界**ではAgentic Searchが向いている
- 実務では**両者を組み合わせるハイブリッドが最も現実的**

> Claude Codeの判断は「コード探索」という限定された領域において最適解を選んだ結果であり、RAGを否定したのではなく**RAGを進化させた**。

---

### 追記：著者の考察

> 「AIに何を持たせるか」よりも「人間がAIに対してどんな環境を用意するか」の方がずっと重要。

- フォルダ構成を整える、命名を揃える、不要なファイルを消す、ドキュメントを放置しない、`CLAUDE.md`を書く——こうした**地味で面倒な作業こそがAIの賢さを決めている**
- Agentic Searchは魔法ではなく「ちゃんと整理された現場でこそ力を発揮する仕組み」
- 散らかったコードベースではどんなAIを入れても賢くはならない
- **AI時代でもエンジニアの仕事の本質は変わらない**：読みやすいコードを書き、分かりやすく整理し、後から来た人のことを考えること
