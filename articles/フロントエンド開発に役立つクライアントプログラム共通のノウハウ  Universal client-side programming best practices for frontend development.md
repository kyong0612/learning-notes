---
title: "フロントエンド開発に役立つクライアントプログラム共通のノウハウ / Universal client-side programming best practices for frontend development"
source: "https://speakerdeck.com/nrslib/universal-client-side-programming-best-practices-for-frontend-development"
author:
  - "成瀬 允宣"
published: 2025-09-21
created: 2025-09-22
description: "フロントエンドカンファレンス東京2025における発表資料。GUIクライアント開発のノウハウのうち、フロントエンド開発にも活かせる普遍的なベストプラクティスについて解説されています。"
tags:
  - "clippings"
  - "Frontend"
  - "GUI"
  - "SoftwareDesign"
  - "GameDevelopment"
---

本資料は、nrs（成瀬 允宣）氏による、フロントエンド開発に応用可能なクライアントサイドプログラミングの普遍的なノウハウを解説した発表です。Windowsアプリ開発からゲーム開発（Flash/ActionScript）、各種JavaScriptフレームワークまで、多岐にわたる開発経験から得られた知見がまとめられています。

## イントロダクション (スライド 1-14)

- **発表者**: nrs (成瀬 允宣) 氏、株式会社コドモン CTO。
- **背景**: 発表者は、Windowsアプリケーション、Flash/ActionScriptを用いたゲーム開発、そして多様なJavaScriptフレームワーク（Backbone.js, Knockout.js, Angular, React, Vue）に携わってきました。これらの異なるプラットフォームや技術スタックを通じて、クライアントサイド開発における共通の課題や普遍的な解決策が存在することを示します。

[![スライド 1](https://files.speakerdeck.com/presentations/6800415386f048de8afe6f2fd080343d/slide_0.jpg)](https://speakerdeck.com/nrslib/universal-client-side-programming-best-practices-for-frontend-development?slide=1)

### イントロダクションのスライド概要

> - **Slide 1:** フロントエンド開発に役立つクライアントプログラム共通のノウハウ nrs
> - **Slide 2:** Profile nrs（成瀬 允宣） @nrslib コドモンのCTO 趣味：カンファレンス講演 学生支援 小学校支援 写真
> - **Slide 3:** フロントエンドカンファレンス北海道2024で喋ったりするぐらいは好き。カメラマンもしてました。
> - **Slides 4-12:** （発表者のフロントエンド技術遍歴を図解）
> - **Slide 13:** 基本は一緒
> - **Slide 14:** つらみも一緒

## ゲーム開発現場の過酷な実態 (スライド 15-52)

ゲーム開発の現場、特にコンシューマゲームやソーシャルゲーム黎明期の過酷な開発スタイルを振り返り、そこから得られた教訓の重要性を強調します。

- **朝令暮改は日常茶飯事**: ディレクターの指示が「おはよう」の一言から始まり、夕方には「なんか思ったんと違うなー」、翌日には「一晩考えたんだけどさー」といった具合に頻繁に変わります。このような状況下で、迅速な仕様変更への対応力が鍛えられました。
- **保守性の欠如**: かつてのコンシューマゲームは一度リリースすると更新が困難でした。そのため、そもそも「保守」という概念が希薄な文化で開発が行われていました。その後ソーシャルゲームが登場し、運用・更新が前提となりましたが、開発者の多くはコンシューマゲーム出身者であったため、初期のコードは保守性に課題を抱えることが少なくありませんでした。
- **テスト文化の不在**: ゲーム開発ではロジックの正しさよりも「見た目」が重視されるため、自動テストよりもデバッガーによる手動テストが主流でした。「このボタン、連打するとおかしくなるだろう」「なんか1フレーム描画がずれてるぞ」といった、開発者の意図を汲んだ職人芸的なデバッグが行われていました。

[![スライド 15](https://files.speakerdeck.com/presentations/6800415386f048de8afe6f2fd080343d/slide_14.jpg)](https://speakerdeck.com/nrslib/universal-client-side-programming-best-practices-for-frontend-development?slide=15)

### ゲーム開発現場の過酷な実態：スライド概要

> - **Slide 15:** たのしいゲーム開発
> - **Slides 16-28:** （ディレクターの指示が二転三転する「朝令暮改」の様子を会話形式で紹介）
> - **Slide 29:** たのしいゲーム開発・その２
> - **Slides 30-42:** 「保守？ ねぇよそんなもん」- コンシューマゲームは一度リリースすると更新が困難だったため、保守の概念が希薄だった。ソーシャルゲーム時代になっても、開発者の多くはコンシューマ出身だったため、その文化が引き継がれた。
> - **Slide 43:** たのしいゲーム開発・その３
> - **Slides 44-52:** 「テスト？ ねぇよそんなもん」- ゲーム開発ではロジックより見た目が重視され、自動テストより職人芸的なデバッガーが重宝された。「このボタン連打するとおかしくなるだろう」「なんか1Fおかしいぞ」といったデバッグが行われていた。

## 現場経験から得られた教訓 (スライド 53-186)

過酷な現場で培われた、現代のフロントエンド開発にも通じる設計原則やパターンについて詳述します。

- **Single Source of Truth (SSOT)**: データを操作する箇所を一つに限定する原則。複数のコンポーネントが同じデータを個別に保持・更新すると、更新漏れや不整合が発生しやすくなります。信頼できる唯一の情報源（SSOT）を定め、そこから各コンポーネントにデータを流すことで、状態管理を堅牢にします。これはReactの`props down, events up`の考え方にも通じます。
- **使われるコンポーネントの条件**:
    1. **めんどくさくないこと (Progressive Disclosure)**: HTMLの`<button>`のように、最も一般的なユースケース（80%）を簡単（20%の労力）に実現できるべきです。プロパティが膨大で複雑なコンポーネントは、結局「めんどくさい」という理由で誰も使わなくなり、車輪の再発明を招きます。
    2. **見つけられること (Discoverability)**: 便利なコンポーネントも、存在に気づかれなければ使われません。StorybookやPlaygroundなどを開発プロセスに組み込み、チームメンバーが「とりあえずカタログを見てみよう」と自然に発見できる仕組みを整えることが重要です。
- **StateMachineの実装**: ゲーム開発では「プレイヤーは走ると同時にガードはできない」といった排他的な状態遷移が頻出します。このような複雑な状態遷移を管理し、イベントの優先順位付けや処理の散在を防ぐためにStateMachineは有効なパターンです。
- **Mediatorパターン**: 複数のコンポーネントが相互に参照しあうと、その依存関係はコンポーネント数の二乗（O(n^2)）で複雑化します。親コンポーネントなどが仲介役（Mediator）となり、各コンポーネントの状態を一元管理することで、依存関係を線形（O(n)）に低減させ、見通しを良くします。
- **イベントヘルの回避**: イベントハンドラから無秩序に別のイベントを連鎖させていくと、処理の流れが追跡不能な「イベントヘル」に陥ります。特にActionScript 3.0のような自由度の高いイベントシステムでは、グローバルなイベントが飛び交い、デバッグを極度に困難にしました。イベントの発行は、その責務を持つ適切なスコープに限定することが重要です。
- **グローバル変数の危険性**: `static`やグローバル変数の多用は、状態の変更箇所が不明瞭になり、コードベースを脆くします。発表者はこれを「緻密に編み込まれたジェンガ」と表現し、一見動いているように見えても、少しの変更で全体が崩壊する危険性を指摘しています。Fluxアーキテクチャも、グローバルな状態を秩序立てて管理したいという課題意識から生まれたものです。
- **ページ遷移の責務の分離**: ヘッダーのロゴクリックなど、常に遷移先が固定的なナビゲーションはコンポーネントに責務を持たせます。一方で、注文履歴の詳細画面への遷移のように、文脈に依存する遷移はページレベルのコンポーネントが責務を持つことで、「このページからどこに遷移するのか」という関心事が一箇所にまとまり、見通しが良くなります。

[![スライド 56](https://files.speakerdeck.com/presentations/6800415386f048de8afe6f2fd080343d/slide_55.jpg)](https://speakerdeck.com/nrslib/universal-client-side-programming-best-practices-for-frontend-development?slide=56)

### 現場経験からの教訓：スライド概要

> - **Slides 53-55:** そんな楽しい現場経験から得られたもの。データを操作するのは一箇所のみ、コンポーネントはめんどくさい/気づかれないと使われない、StateMachine、Mediatorパターン、イベントヘル、グローバル変数の問題など。
> - **Slides 56-81 (データを操作するのは一箇所のみ):** Single Source of Truth (SSOT)の重要性を解説。複数のコンポーネントが各々状態を持つと更新漏れや不整合が起きる。Reactの`props down, events up`にも通じる考え方。
> - **Slides 82-91 (コンポーネントはめんどくさいと使われない):** 複雑すぎるコンポーネントは結局使われず、車輪の再発明を招く。「めんどくさかったから」作ってしまう。Progressive Disclosure（段階的開示）や80/20ルールを意識し、「簡単なことは簡単に、複雑なことも可能に」するべき。
> - **Slides 92-103 (コンポーネントは気づかれないと使われない):** 便利なコンポーネントも存在を知られなければ使われない。「え？ あったの？」となる。StorybookやPlaygroundを用意し、開発プロセスの中で自然に発見できる（Discoverability）仕組みが重要。
> - **Slides 104-114 (StateMachine実装):** ゲームでは「走る」「ガード」「ポーズ」など排他的な状態が多く、StateMachineで管理することで、イベントの優先順位付けや状態遷移のロジックがシンプルになる。
> - **Slides 115-130 (Mediatorパターン):** コンポーネント間の相互参照は、コンポーネント数の二乗で複雑性が増す（O(n^2)）。親コンポーネントなどが仲介役（Mediator）となることで、依存関係を線形（O(n)）に保ち、見通しを良くする。
> - **Slides 131-160 (イベントヘル):** ActionScript 3.0のような自由なイベントモデルでは、イベントハンドラからイベントが連鎖し、処理が追跡不能な「イベントヘル」に陥りがち。イベントの送出は責務を持つスコープに限定すべき。
> - **Slides 161-180 (グローバルやめよ):** `public static`などのグローバル変数の多用は、どこで値が変更されたか追跡困難な「緻密に編み込まれたジェンガ」のようなコードを生む。Fluxアーキテクチャもグローバルな状態を秩序立てて管理する試みの一つ。
> - **Slides 181-186 (ページ遷移はどこでする？):** グローバルナビゲーションのような常に遷移先が固定的なものはコンポーネントに責務を持たせ、文脈に依存する遷移はページレベルのコンポーネントで制御することで、そのページからの遷移の見通しが良くなる。

## GUIとデザインパターン (スライド 187-209)

GUIアーキテクチャの変遷（MVC, MVP, MVVM）を振り返り、その中心にあるObserverパターンの重要性を解説します。

- **MV* パターンの本質**: これらのパターンの目的は、すべてデータ(Model)とUI(View)を分離し、両者の同期を取ることにあります。歴史的経緯や実装の違いはあれど、関心の分離という根本思想は共通しています。
- **Observerパターンによる柔軟な対応**: 頻繁な仕様変更（朝令暮改）に対して、`IObservable<T>`のような仕組み（Observerパターン）を用いることで、変更への対応を劇的に高速化できます。データをObservableとして公開し、そのデータを表示したいコンポーネントはそれを購読（Subscribe）するだけ。新たなコンポーネントで同じデータを表示する必要が出ても、購読するコードを一行追加するだけで済み、驚異的な速度で要求に応えることができます。

[![スライド 196](https://files.speakerdeck.com/presentations/6800415386f048de8afe6f2fd080343d/slide_195.jpg)](https://speakerdeck.com/nrslib/universal-client-side-programming-best-practices-for-frontend-development?slide=196)

### GUIとデザインパターン：スライド概要

> - **Slide 187:** GUIとオブザーバーパターン
> - **Slides 188-194 (MV* パターン):** MVC, MVC2, MVP (Supervising Controller/Passive View), MVVMといったGUIアーキテクチャを紹介。これらはすべてデータ(Model)とUI(View)を分離し、同期を取るという目的で共通している。
> - **Slide 195:** GUIとObserverパターンはなかよし。データとViewを分離し、複数のViewが同じデータを表示したいという要求に応える。
> - **Slides 196-209 (Observerパターンで朝令暮改に対応する):** `IObservable<T>`のような仕組みを使えば、仕様変更に爆速で対応できる。データを監視（Subscribe）するコンポーネントを追加するだけで、新たな表示要件を満たせる。「おはよう」の指示に1時間で「できました」と返し、ディレクターを驚かせることができる。

## まとめ (スライド 210-214)

- **朝令暮改を朝礼朝改で返す**: 優れた設計は、仕様変更への対応速度を劇的に向上させます。急な変更要求に即座に応えることで、エンジニアリングの価値を示し、相手を「怖がらせる」ほどのインパクトを与えることができます。これがエンジニアリングの醍醐味の一つです。
- **普遍的なノウハウの価値**: 特定のフレームワークに依存しないGUI開発の基本原則を学ぶことで、技術の流行り廃りに左右されない、堅牢なアプリケーションを構築する力が身につきます。たとえjQueryしか使えない環境であっても、秩序だったコードを書くことが可能です。

[![スライド 210](https://files.speakerdeck.com/presentations/6800415386f048de8afe6f2fd080343d/slide_209.jpg)](https://speakerdeck.com/nrslib/universal-client-side-programming-best-practices-for-frontend-development?slide=210)

### まとめ：スライド概要

> - **Slide 210:** まとめ
> - **Slide 211:** 朝令暮改を朝礼朝改で返して怖がらせましょう！
> - **Slide 212:** エンジニアリングの醍醐味は、相手の予想を超える楽しさにある。
> - **Slide 213:** GUIの普遍的なノウハウを学べば、ライブラリが滅んでも、jQueryしか使えない環境でも、秩序だったコードを書くことができる。
> - **Slide 214:** （採用情報）
