---
title: "エージェントAIシステムを構築するためのベストプラクティス：実際に本番で機能するもの"
source: "https://userjot.com/blog/best-practices-building-agentic-ai-systems"
author:
  - "[[Shayan]]"
published: 2025-08-14
created: 2025-08-19
description: "崩壊しないAIエージェントシステムを構築するための実践的なパターン。2層アーキテクチャ、ステートレス設計、オーケストレーション戦略、そしてUserJotのエージェントインフラストラクチャを構築して学んだこと。"
tags:
  - "clippings"
  - "翻訳"
---
私は、フィードバック、ロードマップ、チェンジログのプラットフォームである[UserJot](https://userjot.com/)にAIエージェントを追加する実験をしてきました。単純な「1つのプロンプト、1つの応答」のようなものではありません。複数の専門エージェントが通信し、タスクを委任し、互いに衝突することなく連携する、本物のエージェントシステムです。

![UserJot Dashboard](https://userjot.com/assets/hero/dashboard-light.webp)

目標は、顧客からのフィードバックを大規模に分析し、何百もの投稿からパターンを見つけ、チェンジログのエントリを自動生成することでした。私はGemini CLIやOpenCodeのようなツールをリバースエンジニアリングし、実験を繰り返し、壊しては直し、また壊すという数週間を過ごしました。基本的なバージョンをベータ版として本番環境にプッシュしたところ、ほとんど機能しています。

ここでは、実際に使われているものを研究し、自分でテストすることから学んだ、エージェントシステムの構築に関する知見を紹介します。

## 実際に機能する2層エージェントモデル

複雑な階層は忘れてください。必要なのは正確に2つのレベルです。

**プライマリエージェント**が対話を処理します。彼らはコンテキストを理解し、タスクを分解し、ユーザーと対話します。コードを書かないプロジェクトマネージャーだと考えてください。

**サブエージェント**は1つのことをうまくやります。タスクを受け取り、それを完了し、結果を返します。メモリもコンテキストもありません。純粋な関数実行です。

私は3層システム、4層システム、エージェントがエージェントに話し、さらにエージェントに話すようなシステムを試しました。すべてが破綻します。2層が最も効果的です。

私がたどり着いたのはこれです：

```plaintext
ユーザー → プライマリエージェント（コンテキストを維持）

         ├─→ リサーチエージェント（関連するフィードバックを見つける）

         ├─→ 分析エージェント（感情を処理する）

         └─→ 要約エージェント（レポートを作成する）
```

各サブエージェントは完全に独立して実行され、プライマリエージェントがすべてのオーケストレーションを処理します。

## ステートレスなサブエージェント：最も重要なルール

すべてのサブエージェント呼び出しは、同じ入力が同じ出力を生成する純粋な関数を呼び出すようなものであるべきです。共有メモリ、会話履歴、状態はありません。

これは制限的に聞こえるかもしれませんが、それによって得られるものを考えれば納得がいくはずです：

- **並列実行**：10個のサブエージェントを互いに干渉させることなく同時に実行できる
- **予測可能な動作**：同じプロンプトは常に同様の結果を生成する
- **簡単なテスト**：各エージェントを個別にテストできる
- **シンプルなキャッシング**：プロンプトのハッシュで結果をキャッシュできる

サブエージェントの通信は次のように構成しています：

```json
// プライマリ → サブエージェント

{

  "task": "この50件のフィードバックアイテムの感情を分析せよ",

  "context": "モバイルアプリに関する機能リクエストに焦点を当てる",

  "data": [...],

  "constraints": {

    "max_processing_time": 5000,

    "output_format": "structured_json"

  }

}

// サブエージェント → プライマリ

{

  "status": "complete",

  "result": {

    "positive": 32,

    "negative": 8,

    "neutral": 10,

    "top_themes": ["navigation", "performance", "offline_mode"]

  },

  "confidence": 0.92,

  "processing_time": 3200

}
```

会話履歴や状態はなく、ただタスクを入力し、結果を出力するだけです。

## タスクの分解：物事を分解する方法

機能する2つの戦略があります：

**垂直分解**（シーケンシャルなタスク向け）：

```plaintext
"競合他社の価格を分析する" →

  1. 価格設定ページを収集する

  2. 価格帯を抽出する

  3. ユーザーあたりのコストを計算する

  4. 自社の価格と比較する
```

**水平分解**（並列作業向け）：

```plaintext
"上位5社の競合他社を調査する" →

  ├─ 競合Aを調査

  ├─ 競合Bを調査

  ├─ 競合Cを調査

  ├─ 競合Dを調査

  └─ 競合Eを調査

  （すべて同時に実行）
```

どちらをいつ使うかを知るのがコツです：依存関係がある場合はシーケンシャル、タスクが独立している場合はパラレル、そして必要に応じてこれらを組み合わせます。

私はフィードバック処理に混合分解を使用しています：

1. **フェーズ1（パラレル）**：フィードバックの分類、感情の抽出、ユーザーの特定
2. **フェーズ2（シーケンシャル）**：テーマごとにグループ化 → 影響度で優先順位付け → レポート生成

これは毎回うまくいきます。

## ダメにならない通信プロトコル

エージェントには構造化された通信が必要です。「時間があるときにこれを分析してください」といった曖昧なものではなく、実際の構造化されたプロトコルです。

プライマリからサブエージェNTへのすべてのタスクには以下が必要です：

- 明確な目的（「'読み込みが遅い'に言及しているすべてのフィードバックを見つける」）
- 限定されたコンテキスト（「過去30日間から」）
- 出力仕様（「id、text、userフィールドを持つJSONとして返す」）
- 制約（「最大100件、5秒後にタイムアウト」）

サブエージェントからプライマリへのすべての応答には以下が必要です：

- ステータス（完了/部分的/失敗）
- 結果（実際のデータ）
- メタデータ（処理時間、信頼度、行われた決定）
- 推奨事項（フォローアップタスク、警告、制限）

すべてが明確な仕様を持つ構造化データ交換を使用します。

## エージェントの専門化パターン

OpenCodeや他のシステムを研究した結果、意味のあるエージェントの専門化方法は3つあることがわかりました：

**能力別**：リサーチエージェントは情報を見つけます。分析エージェントはそれを処理します。クリエイティブエージェントはコンテンツを生成します。検証エージェントは品質をチェックします。

**ドメイン別**：リーガルエージェントは契約を理解します。フィナンシャルエージェントは数値を扱います。テクニカルエージェントはコードを読みます。

**モデル別**：高速エージェントはHaikuを使用して迅速な応答をします。ディープエージェントはOpusを使用して複雑な推論をします。マルチモーダルエージェントは画像を扱います。

専門化しすぎないでください。私は最初15種類の異なるエージェントタイプで始めましたが、今では6種類に落ち着き、それぞれが1つのことを非常によくこなしています。

## 実際に使用しているオーケストレーションパターン

95%のケースを処理する4つのパターンを以下に示します：

### シーケンシャルパイプライン

各出力が次の入力になります。多段階のプロセスに適しています。

```plaintext
エージェントA → エージェントB → エージェントC → 結果
```

私はレポート生成にこれを使用しています：データ収集 → 分析 → フォーマット → 提供。

### MapReduceパターン

複数のエージェントに作業を分割し、結果を結合します。大規模な分析に適しています。

```plaintext
┌→ エージェント1 ─┐

入力 ─┼→ エージェント2 ─┼→ リデューサー → 結果

       └→ エージェント3 ─┘
```

これはUserJotでのフィードバック分析における私の頼みの綱です。誰かのフィードバックボードに何百もの投稿が寄せられた場合（思ったより頻繁に起こります）、それらを10のエージェントに分割し、それぞれが100件を処理し、結果を結合します。これにより5分かかっていた作業が30秒になり、ユーザーは顧客が本当に何を望んでいるのかについて即座に洞察を得ることができます。

### コンセンサスパターン

複数のエージェントが同じ問題を解決し、答えを比較します。重要な決定に適しています。

```plaintext
┌→ エージェント1 ─┐

タスク ─┼→ エージェント2 ─┼→ 投票/マージ → 結果

      └→ エージェント3 ─┘
```

重要なフィードバックの感情分析にこれを使用しています。3つのエージェントが独立して分析し、多数決を取ることで、単一のエージェントが見逃すエッジケースを捉えることができます。

### 階層的委任

プライマリがサブエージェントに委任し、サブエージェントはさらにサブサブエージェントに委任できます。複雑なドメインに適しています。

```plaintext
プライマリエージェント

  ├─ サブエージェントA

  │   ├─ サブサブエージェントA1

  │   └─ サブサブエージェントA2

  └─ サブエージェントB
```

正直なところ、私はこれをほとんど使いません。理論上は良さそうですが、実際にはデバッグの悪夢になるため、最大でも2階層に留めています。

ベータ版では、主にフィードバック分析にMapReduceを、レポート生成にシーケンシャルを使用しています。派手なものはめったに使いません。

## 散らからないコンテキスト管理

サブエージェントはどれくらいのコンテキストを持つべきでしょうか？思っているよりも少ないです。

**レベル1：完全な分離**：サブエージェントは特定のタスクのみを受け取ります。80%のケースでこれを使用します。

**レベル2：フィルタリングされたコンテキスト**：サブエージェントは厳選された関連背景情報を受け取ります。タスクに何らかの履歴が必要な場合に使用します。

**レベル3：ウィンドウ化されたコンテキスト**：サブエージェントは最後のN件のメッセージを受け取ります。慎重に使用してください。通常は問題を引き起こします。

私は3つの方法でコンテキストを渡しています：

```python
# 明示的な要約

"以前の分析で3つの重大なバグが見つかりました。v2.1で修正されているか確認してください"

# 構造化されたコンテキスト

{

  "background": "Q3のフィードバックを分析中",

  "previous_findings": ["slow_loading", "login_issues"],

  "current_task": "Q4で関連する問題を見つける"

}

# 参照渡し

"document_xyzの品質問題を分析してください"

# サブエージェントが独立してドキュメントを取得
```

コンテキストが少ないほど、予測可能な動作になります。

エージェントは頻繁に失敗するため、私は次のように対処しています：

**段階的な機能低下チェーン**：

1. サブエージェントが失敗 → プライマリエージェントがタスクを試行
2. それでも失敗 → 別のサブエージェントを試す
3. それでも失敗 → 部分的な結果を返す
4. それでも失敗 → ユーザーに明確化を求める

**機能する再試行戦略**：

- ネットワーク障害の場合は即時再試行
- 不明瞭なタスクの場合はプロンプトを言い換えて再試行
- 機能の問題の場合は別のモデルで再試行
- レート制限の場合は指数関数的バックオフ

**失敗時のコミュニケーション**：

```json
{

  "status": "failed",

  "error_type": "timeout",

  "partial_result": {

    "processed": 45,

    "total": 100

  },

  "suggested_action": "retry_with_smaller_batch"

}
```

失敗したときでも、常に何か役立つものを返します。

## 考えすぎないパフォーマンス最適化

**モデル選択**：単純なタスクにはHaiku。複雑な推論にはSonnet。重要な分析にはOpus。すべてにOpusを使用しないでください。

**並列実行**：独立したタスクを特定します。それらを同時に起動します。私は定期的に5〜10のエージェントを並列で実行しています。

**キャッシング**：プロンプトのハッシュでキャッシュします。動的コンテンツは1時間後、静的コンテンツは24時間後に無効化します。API呼び出しの40%を節約できます。

**バッチ処理**：50件のフィードバック項目を50回の個別呼び出しではなく、1回のエージェント呼び出しで処理します。当たり前ですが、見落とされがちです。

## モニタリング：実際に追跡すべきこと

以下の4つを追跡してください：

- タスク成功率（エージェントはタスクを完了しているか？）
- 応答品質（信頼度スコア、検証率）
- パフォーマンス（レイテンシ、トークン使用量、コスト）
- エラーパターン（何がなぜ失敗しているのか？）

私の実行トレースのフォーマットは次のとおりです：

```plaintext
プライマリエージェント開始 [12:34:56]

  ├─ フィードバックアナライザー呼び出し

  │   ├─ 時間: 2.3s

  │   ├─ トークン: 1,250

  │   └─ ステータス: 成功

  ├─ 感情プロセッサー呼び出し

  │   ├─ 時間: 1.8s

  │   ├─ トークン: 890

  │   └─ ステータス: 成功

  └─ 合計時間: 4.5s, 合計コスト: $0.03
```

シンプルで、読みやすく、実用的なものにしてください。

## UserJotでこれを構築して学んだこと

![UserJot Dashboard](https://userjot.com/assets/hero/dashboard-changelog-chat.webp)

私はこのアーキテクチャを、フィードバックボードからの実際のフィードバックデータでテストしてきました。機能リクエストからバグレポート、「こうだったらクールじゃない？」という投稿まで、あらゆるものです。驚いたことは次のとおりです：

**ステートレスは交渉の余地がない**。「今回だけ」と状態を追加するたびに、数日以内に何かが壊れました。

**2層で十分**。複雑な階層を試しましたが、価値を付加することなく複雑さが増すだけでした。

**ほとんどのタスクは単純なエージェントで事足りる**。私のエージェント呼び出しの90%は、最もシンプルで高速なモデルを使用しています。

**暗黙的より明示的**。明確なタスク定義。構造化された応答。魔法はありません。

**並列実行がすべてを変える**。10のエージェントを同時に実行することで、5分かかっていたタスクが30秒になりました。

## 重要となる原則

このシステムを実験し、ベータ版にまで到達させた結果、本当に重要となる原則は以下の通りです：

1. **デフォルトでステートレス**：サブエージェントは純粋な関数である
2. **明確な境界**：明示的なタスク定義と成功基準
3. **迅速な失敗**：素早い失敗検出と回復
4. **観測可能な実行**：すべてを追跡し、何が起こっているかを理解する
5. **構成可能な設計**：うまく組み合わせることができる、小さく焦点を絞ったエージェント

## 私が陥った（そしてあなたが避けるべき）よくある落とし穴

**「スマートエージェント」の罠**：何をすべきかを「見つけ出す」ことができるエージェントを作ろうとしました。彼らにはできませんでした。明示的に指示してください。

**状態の忍び寄り**：「この1つの状態だけ」。そしてまた1つ。そしてまた1つ。そしてすべてが壊れます。

**深い階層**：4レベルのエージェントは論理的に見えました。それはデバッグの悪夢でした。

**コンテキストの爆発**：すべてのエージェントに会話履歴全体を渡すこと。トークンは無料ではありません。

**完璧なエージェント**：1つのエージェントですべてのエッジケースを処理しようとすること。もっと専門的なエージェントを作ればよいだけです。

## これを実際に実装する

まず1つのプライマリエージェントと2つのサブエージェントでシンプルに始め、それを機能させてから、必要に応じてエージェントを追加してください。できるからといって追加するのではなく。

初日からモニタリングを構築してください。必要になります。

サブエージェントは個別にテストしてください。動作するためにコンテキストが必要な場合、それらは十分に分離されていません。

積極的にキャッシュしてください。同じプロンプト=同じ応答=なぜAPIを2回呼び出すのですか？

そして覚えておいてください：エージェントはツールであり、魔法ではありません。彼らは特定のタスクには非常に優れていますが、それらのタスクが何であるべきかを見つけ出すのは苦手です。それはあなたの仕事です。

*追伸：私たちがこれらのパターンをどのように使用して大規模なユーザーフィードバックを分析しているかに興味がある場合は、[UserJot](https://userjot.com/)に無料プランがあります。エージェント機能はまだベータ版ですが、中心となるフィードバック/ロードマップ/チェンジログ機能は堅牢です。私たちは自分たちのドッグフードを食べています。私たちのすべての製品決定は、これらのエージェントが私たちのフィードバックで見つけたパターンから来ています。*

## FAQ

### 最低限実行可能なエージェントシステムとは？

コンテキストを維持する1つのプライマリエージェントと、実際の作業を行う1つのサブエージェント。そこから始めて、必要な場合にのみ複雑さを追加してください。

### サブエージェントは本当にメモリをゼロにすべきですか？

はい。メモリを追加すると状態が追加され、状態を追加するとバグが追加されるため、ステートレスに保ってください。

### 並列エージェントでレート制限をどのように処理しますか？

トークンバケットレートリミッターを実装して、上限までエージェントを起動し、残りをキューに入れ、トークンが利用可能になったらキューに入れられたタスクを処理します。

### プライマリエージェントとサブエージェントに最適なモデルは？

プライマリエージェントは推論能力が必要なため、SonnetまたはOpusを使用し、単純なタスクを実行するサブエージェントはHaikuを使用できます。タスクの複雑さに合わせてモデルを選択してください。

### エージェントシステムをどのようにテストしますか？

固定の入力と期待される出力でサブエージェントをテストし、モックされたサブエージェントの応答でオーケストレーションをテストし、実際のデータ（ただし限定的）で完全なシステムをテストします。

### エージェントは他のエージェントを直接呼び出すことができますか？

できますが、すべきではありません。すべての通信は、制御と可視性を維持するためにプライマリエージェントを介して行われるべきです。

### 会話の状態を維持する必要があるエージェントについてはどうですか？

それはプライマリエージェントの仕事です。状態を維持し、必要に応じてステートレスなサブエージェントに関連するコンテキストを渡します。

### 長時間実行されるエージェントタスクをどのように処理しますか？

30秒以上実行されるエージェントタスクはないはずなので、より小さなチャンクに分割してください。もしそうなる場合は、さらに分解する必要があります。

### マルチエージェント操作の一般的なレイテンシは？

並列実行では、ほとんどの操作は2〜5秒かかり、シーケンシャルな操作はステップごとに1〜2秒追加され、キャッシュヒットはほぼ瞬時です。

### このアーキテクチャは単純なユースケースには過剰ですか？

はい。プロンプト付きのAPI呼び出しが1つ必要なだけなら、それを使用してください。このアーキテクチャは、複数の専門エージェントが連携して作業する必要がある場合のためのものです。

UserJotを無料で始めましょう

## ユーザーに次に何を構築すべきかを正確に教えてもらいましょう

フィードバックを収集し、ユーザーに投票してもらい、本当に重要なものを出荷します。すべてが数分でセットアップできるシンプルなツール1つで。

クレジットカード不要 14日間無料トライアル いつでもキャンセル可能
