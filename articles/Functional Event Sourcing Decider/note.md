# Functional Event Sourcing Decider

ref: <https://thinkbeforecoding.com/post/2021/12/17/functional-event-sourcing-decider>

この記事は、Functional Event Sourcing（関数型イベントソーシング）とその主要パターンであるDecider（決定者）について解説しています。以下に主要なポイントをまとめます：

## システムの解剖学

1. システムは入力と出力を持ち、時間の経過とともに変化します[1][2]。

2. システムは状態（state）を持ち、これは過去のアクションの効果を記録します[1][2]。

3. ヘキサゴナルアーキテクチャの概念が紹介され、ビジネスロジック（ドメイン）とアプリケーション層が分離されています[1][2]。

## 関数型コア

1. システムは純粋関数として実装できます[1][2]。

2. 入力（アクション）、状態、出力を関数のパラメータとして扱います[1][2]。

## アクションとコマンド

1. アクションはコマンドとイベントに分類されます[1][2]。

2. コマンドはシステムを変更する意図を持ち、イベントは外部で発生したことを表します[1][2]。

## 決定（Decision）

1. 決定プロセスと状態変更を分離することの重要性が強調されています[1][2]。

2. イベントを使用して決定の結果を明示的に表現します[1][2]。

3. 決定関数（decide）は純粋関数として実装され、コマンドと現在の状態を入力とし、イベントのリストを出力します[1][2]。

## 進化（Evolution）

1. evolve関数は、現在の状態とイベントを入力とし、新しい状態を返します[1][2]。

2. 初期状態（Initial State）の重要性が説明されています[1][2]。

## Decider（決定者）パターン

1. Deciderは、Command型、Event型、State型、初期状態、decide関数、evolve関数、isTerminal関数から構成されます[1][2]。

2. Deciderはアプリケーション層とドメインコード間のインターフェースとして機能します[1][2]。

## 実装方法

1. メモリ内での実装[1][2]。

2. データベースを使用した実装（楽観的ロック付き）[1][2]。

3. イベントストアを使用した実装[1][2]。

4. スナップショットを使用したパフォーマンス最適化[1][2]。

この記事は、関数型プログラミングの原則を適用しながら、イベントソーシングシステムを設計・実装する方法を詳細に説明しています。純粋関数、不変性、副作用の分離などの概念が強調されており、これらの原則を適用することで、より理解しやすく、テストしやすく、保守しやすいシステムを構築できることを示しています。

Sources
[1] functional-event-sourcing-decider <https://thinkbeforecoding.com/post/2021/12/17/functional-event-sourcing-decider>
[2] // thinkbeforecoding <https://thinkbeforecoding.com/post/2021/12/17/functional-event-sourcing-decider>
