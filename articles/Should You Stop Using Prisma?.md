---
title: "Should You Stop Using Prisma?"
source: "https://medium.com/@sohail_saifi/should-you-stop-using-prisma-421aba045846"
author:
  - "[[Sohail Saifi]]"
published: 2025-07-18
created: 2025-11-14
description: |
  Prismaを含むORMがバックエンド開発にもたらす問題点を、3年間の本番環境での使用経験に基づいて詳細に分析。パフォーマンス問題、サーバーレス環境での課題、開発者体験の落とし穴、セキュリティリスクなどを指摘し、DrizzleやKyselyなどの代替手段、または生のSQLへの回帰を推奨。ORMの抽象化が隠す複雑さと、実際のコストについて考察。
tags:
  - "Prisma"
  - "ORM"
  - "Database"
  - "Backend Development"
  - "Performance"
  - "Serverless"
  - "TypeScript"
---

## はじめに

著者は3年間のPrisma本番環境での使用経験から、Prismaがアプリケーションのボトルネックになっていることに気づいた。ORMは生産性と型安全性を約束したが、代わりに複雑さとパフォーマンス問題をもたらした。

## Prismaの約束（そしてなぜ皆がそれに惹かれたのか）

Prismaのマーケティングは優秀で、以下の点を強調している：

- 型安全なデータベースアクセス
- 自動マイグレーション
- SQL不要
- 単一のスキーマファイルで必要なすべてを生成

しかし、これらの利便性の裏には重大な問題が隠れている。

## パフォーマンスの現実

### バンドルサイズの問題

- **Drizzle**: 約1.5MB
- **Prisma**: 約6.5MB

サーバーレス環境では、この差が大きな影響を与える。

### N+1問題の深刻化

一見無害に見えるクエリが、実際には数十のデータベースラウンドトリップを生成する。著者のアプリケーションでは、単一のJOINクエリが47個の別々のSQL文を生成していた。

```typescript
// 見た目はシンプルなクエリ
const users = await prisma.user.findMany({
  where: { email: { contains: 'john' } },
  include: { posts: { select: { title: true, createdAt: true } } }
})

// 実際には以下のような複数のクエリが実行される
// SELECT * FROM users WHERE email LIKE '%john%';
// SELECT * FROM posts WHERE userId = 1;
// SELECT * FROM posts WHERE userId = 2;
// ... など
```

### サーバーレス環境での問題

AWS Lambdaのコールドスタートが200msから2.5秒に増加。理由は：

1. Rustベースのクエリエンジンバイナリの読み込み
2. 内部GraphQLサーバーの起動
3. 接続プールの初期化
4. クライアントインターフェースの生成

これらがすべて、リクエスト処理を開始する前に実行される必要がある。

## 開発者体験の幻影

### スキーマのロックイン

すべてが`schema.prisma`ファイルを中心に回る。しかし、PrismaのDSLに収まらないことを行う必要がある場合：

- PostgreSQLのJSONB演算子のようなデータベース固有機能の使用が困難
- CTEを含む複雑なクエリが必要な場合、生のSQLに戻る必要があり、型安全性を失う

### 生成のダンス

スキーマを変更するたびに`prisma generate`を実行する必要がある。これにより：

- 数千行のTypeScriptコードが再生成される
- IDEがフリーズする
- ビルドプロセスが遅くなる
- 実行を忘れると型がデータベースと同期しなくなる

Drizzleでは、スキーマの変更が即座に反映される（すべてがTypeScriptのため）。

### マイグレーションの悪夢

#### 設計によるデータ損失

カラム名を変更した際、Prismaのマイグレーションシステムはリネームとして検出せず、古いカラムの削除と新しいカラムの作成として扱った。**そのカラムのすべてのデータが失われた。**

Drizzleは、可能なリネームを検出すると対話モードに入り、意図を選択できる。

#### ブラックボックス問題

Prismaが生成するSQLマイグレーションは、手動で書くものとは異なる。冗長で、時には非効率的で、レビューが困難。カスタマイズが必要な場合、ツールと戦うことになる。

## 抽象化の真のコスト

Ted Newardは2008年にORMを「コンピュータサイエンスのベトナム戦争」と呼んだ。ORMは以下の問題を隠すだけで、解決しない：

- オブジェクト指向コードとリレーショナルデータベース間の「インピーダンスミスマッチ」

抽象化が漏れると（それは常に起こる）、ORMの癖とそれが生成するSQLの両方を理解する必要があり、開始時よりも悪い状況になる。

## 賢い開発者が使用している代替手段

### Drizzle: TypeScriptネイティブアプローチ

「SQLを知っていれば、Drizzleを知っている」というキャッチフレーズの通り：

```typescript
const users = await db
  .select()
  .from(usersTable)
  .where(like(usersTable.email, '%john%'))
  .leftJoin(postsTable, eq(usersTable.id, postsTable.userId));
```

- SQLだが、完全なTypeScript安全性を持つ
- コード生成なし
- バイナリなし
- マジックなし
- パフォーマンス: Prismaより桁違いに高速
- バンドルサイズ: 1.5MB vs Prismaの6.5MB

### 型安全性を持つ生のSQL

RustのSQLxのようなツールは、コンパイル時にチェックされるSQLクエリをゼロランタイムオーバーヘッドで提供する。

TypeScriptでは、Kyselyが同様の利点を提供：

```typescript
const users = await db
  .selectFrom('users')
  .leftJoin('posts', 'users.id', 'posts.userId')
  .select(['users.name', 'posts.title'])
  .where('users.email', 'like', '%john%')
  .execute();
```

### 「生のSQLが実際には優れている」運動

多くの開発者が生のSQLに戻っている理由：

1. **より透明性が高い** - 実行されるクエリを正確に知ることができる
2. **より高性能** - 抽象化のオーバーヘッドがない
3. **より移植性が高い** - SQLの知識はプロジェクト間で転移する
4. **より安全** - インジェクションリスクを認識し、より注意深くなる

20行のSQLクエリは、ORMのメソッドチェーンが何を生成するかを理解しようとするよりも理解しやすい。さらに、SQLは標準化されているため、どの開発者でも読める。

## 誰も語らないセキュリティへの影響

### 一括代入の脆弱性

以下のPrismaコードは安全に見える：

```typescript
app.post('/users', async (req, res) => {
  const user = await prisma.user.create({
    data: req.body
  });
});
```

しかし、リクエストボディに予期しない`role: 'admin'`フィールドが含まれていた場合、管理者ユーザーが作成されてしまう。

生のSQLでは、更新するフィールドを明示的に指定するため、このパターンは起こりにくい。

### 過剰なデータベース権限

ORMは機能するために、より広範なデータベース権限を必要とする。テーブルスキーマ情報のクエリ、メタデータへのアクセス、リフレクションの実行が必要。これは最小権限の原則に違反する。

### セキュリティにおけるバンドルサイズの影響

2024年、バンドルサイズは重要。AstroやSvelteKitなどのフレームワークは最小限のJavaScriptを強調しているが、バックエンドに6.5MBのORMを追加している。

エッジコンピューティングやサーバーレス関数では、すべてのキロバイトが重要。Cloudflareの無料プランには3MBの制限がある。Prismaは、ビジネスロジックを1行も書く前に、その半分以上を消費する。

## ORMがまだ意味を持つ場合

ORMが適切な場合もある：

- **迅速なプロトタイピング**: 迅速に動作するものが必要で、パフォーマンスが重要でない場合
- **ジュニアチーム**: チームに強いSQLスキルがない場合、ORMはガードレールを提供できる
- **シンプルなCRUDアプリケーション**: 複雑な関係性のない基本的な作成/読み取り/更新/削除操作
- **エンタープライズ要件**: コンプライアンスや標準化の理由でORMを義務付けている組織

しかし、ほとんどの本番アプリケーションでは、コストが利益を上回る。

## 前進への道

ORMから離れることを考えている場合の移行戦略：

### 1. 新機能から始める

一度にすべてを書き直さない。選択した代替手段（Drizzle、Kysely、または生のSQL）で新機能を構築し、感覚を掴む。

### 2. パフォーマンスボトルネックを特定

プロファイリングを使用して、最も遅いデータベース操作を見つける。これらは移行の良い候補（即座に改善が見られるため）。

### 3. ドメインごとに移行

アプリケーション内の境界付きコンテキストを選択し、そのデータベースアクセスをすべて一緒に移行する。これにより、ドメイン内の一貫性が維持される。

### 4. ツールに投資

適切なデータベースマイグレーションツール、クエリビルダー、型生成を設定する。初期設定には時間がかかるが、長期的にはより生産的になる。

## 結論

Prismaは本質的に悪ではない。実際の問題を解決する、よく設計されたツールである。しかし、多くのチームが予期しない新しい問題も作成する。

問題は、Prismaが良いか悪いかではない。Prismaが解決する問題が、**あなたのアプリケーション**のために作成する問題の価値があるかどうかである。

著者の場合、答えは「いいえ」だった。Prismaから離れることで：

- サーバーレスコストを40%削減
- パフォーマンスを3倍改善
- コードベースをより保守しやすく

さらに重要なのは、データベースをよりよく理解することを強制されたこと。データベースを単なるストレージレイヤーとして扱うのをやめ、その力を活用し始めた。クエリはより効率的になり、データモデルはよりクリーンになり、デバッグセッションはより短くなった。

ORMは複雑さを隠すことで生産性を高めると約束した。しかし、結局のところ、**複雑さは決して隠されていなかった — 手遅れになるまで見えない場所に移動されただけだった。**

データベースから隠れるのをやめ、それらを受け入れる時が来たのかもしれない。
