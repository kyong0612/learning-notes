---
title: "関数型ドメインモデリングの著者、Scott Wlaschinさんの出たポッドキャストが良すぎたので和訳した(2)-3"
source: "https://zenn.dev/jtechjapan_pub/articles/13850e51d2b05a"
author:
  - tomohisa
published: 2025-09-27
created: 2025-10-06
description: |
  Compiled Conversation #8, #9の和訳記事(Part 2-3)。Scott Wlaschin氏とEd Mann氏が、関数型プログラミングとドメイン駆動設計(DDD)の組み合わせ、パイプライン指向プログラミング、エンティティ・値オブジェクト・集約のモデリング、リポジトリパターン、イベント駆動アーキテクチャ、サガパターン、そしてAIの台頭と学習方法について深く議論。関数型アプローチがビジネスワークフローのモデリングにどう役立つか、実践的な視点から解説。
tags:
  - 関数型プログラミング
  - F#
  - DDD
  - ドメインモデリング
  - パイプライン指向
  - イベント駆動
  - サガパターン
  - AI
  - ポッドキャスト
---

## 概要

この記事は、Compiled Conversation ポッドキャスト #8, #9「Domain Modeling Made Functional Part 2 with Scott Wlaschin」の和訳記事の第3部（Part 2-3）です。『関数型ドメインモデリング』の著者Scott Wlaschin氏と、ホストのEd Mann氏による対談の文字起こし翻訳です。

本記事では以下のトピックについて詳しく議論されています:

- **関数型プログラミングとDDDの組み合わせ**: 代数的データ型の組み合わせ可能性と透過的な型システムの利点
- **パイプライン指向プログラミング**: データが一方向に流れるワークフローの設計手法とその利点
- **DDDの戦術的パターン**: エンティティ、値オブジェクト、集約を関数型言語でどうモデリングするか
- **リポジトリパターンの再考**: 関数型アプローチにおける永続化戦略とワークフロー指向の設計
- **イベント駆動アーキテクチャ**: コマンドとイベント、非同期連携、サガパターンによる長時間処理の扱い方
- **AI時代の開発**: AIツールの位置づけ、バブルの可能性、開発者の役割の変化
- **効果的な学習方法**: 複数のアプローチを組み合わせた学習戦略

## 登場人物

- **Ed Mann（ホスト）**: ポッドキャストの司会者
- **Scott Wlaschin（ゲスト）**: 『関数型ドメインモデリング』著者、F# for Fun and Profit ブログ執筆者

---

## 関数型プログラミングとDDDの組み合わせ

### 代数的データ型の力

**Ed**: F#のような関数型プログラミング言語は、ドメイン概念のモデリングにどのように役立ちますか？

**Scott**: 主に2つの利点があります。まず、**組み合わせ可能なデータ型**です。代数的データ型は、接着したり、and/orで組み合わせたりできます。これが可能なのは、データ型に振る舞いがなく、文字通りデータ構造だけだからです。

オブジェクト指向では、データと振る舞いが1つのオブジェクトにカプセル化されているため、組み合わせが難しくなります。関数型プログラミングでは、**データは透明**で、不変性のおかげで内部が見えても問題ありません。フィールドを変更できないので、見えても安全なのです。

### 透過的な型システム

関数型言語では厳密に型付けされた代数的データ型があり、これが大きな利点です。そして2番目の利点が、**パイプライン指向プログラミング**です。

---

## パイプライン指向プログラミング

### データフローの明確性

**Scott**: パイプライン指向プログラミングとは、データがワークフローを1ステップずつ通過するという考え方です。一端から入り、一連の小さなパイプを通って、他端から変換されて出てきます。

これは新しい概念ではありません。Unixシェルスクリプトが全く同じように動作します。何かをパイプし、別のものにパイプし、出力を得る。多くの小さな部品を組み合わせてデータをパイプする——これがUnixの優れている理由の1つです。

関数型プログラミングも全く同じアイデアを持っています。小さな部品を接続し、**1方向のパイプライン**でデータが流れます。これは一般的なビジネスプロセスの動作により適したモデルだと思います。

### オブジェクト指向との比較

オブジェクト指向設計では、通常、あるオブジェクトが別のオブジェクトと通信し、それがまた別のオブジェクトと通信し、すべてが前後に話し合います。誰が誰と話しているかわからなくなり、ループやサイクルができることがあります。

理論的には良いアイデアですが、実際にはオブジェクト指向で複雑になりすぎるのは簡単です。単一責任原則、インターフェース分離原則など、多くのルールがあります。しかし関数型プログラミングでは、**最初からそれを許可しない**設計になっています。

関数は1つのことをします。単一責任原則は不要です。関数型プログラミングにはSOLIDという概念すらありません——それ自体がSOLIDだからです。

### モジュラリティと再利用性

プログラミングでは常に「モジュラーコンポーネントを構築し、それらを接続して構成すべきだ」と言います。関数でそれが実現できます。**各関数は1つのことをうまく行い**、それらを接着して完全なワークフローを作ります。

良い設計で努力していることの多くを、関数型プログラミングでは無料で得られます。データが入ってデータが出ていく実用的なビジネスワークフローには、関数型プログラミングが非常によく機能します。

---

## DDDの戦術的パターンの実装

### エンティティと値オブジェクト

**Ed**: エンティティや値オブジェクトのようなDDD概念は、関数型言語でどうモデル化されますか？

**Scott**: DDDの多くの概念はオブジェクト指向由来ですが、関数型でも実装できます。

**エンティティ**は、部分が変わってもアイデンティティが変わらないものです。例えば顧客は、名前や住所やメールを変更しても同じ人です。通常は顧客IDがあり、他が変わってもそれが続きます。

関数型プログラミングでは、**カスタムIDフィールドを保持**するだけです。変更するたびに、IDフィールドは維持されます。その意味では全く同じです。

**値オブジェクト**は、一部を変更すると異なるものになります。住所の番地を変更すれば異なる住所です。メールを変更すれば異なるメールです。

関数型言語で**不変なデータ構造**を持っていれば、自然にこれを得られます。一部を変更すると構造的に異なるオブジェクトになります。心配する必要はありません。

これらの概念は依然として価値がありますが、実装の観点からは、両方とも関数型プログラミングでは完全に些細なことです。

### 集約（Aggregate）

**Ed**: 集約はどうモデル化しますか？

**Scott**: DDDにおける集約は、特に多くのエンティティを1つのものとしてグループ化したオブジェクトです。典型例は**注文**です。

注文には多くの注文行が含まれます。各注文行は個別のものですが、全体が束になっていて、通常は制約や不変条件があります。例えば:

- アイテムの価格を変更すると、注文の総価格も変わる
- アイテムの数量を変更すると、全体が変わる

一つの部分を変更すると全体も変わります。だから**トップレベルでのみ作業する**必要があります。

関数型プログラミングではこれは簡単です。常にトップレベルのものを渡すだけです。カプセル化された可変状態を持つのではなく、アイテムの数量を変更する関数を持ちます。ただし、それを行うには**注文全体を渡さなければなりません**。注文の総価格も変更されるからです。

皮肉にも、**不変性**がこれをより明らかにします。小さな部分の一つを変更するには、全体を変更しなければならないのです。

---

## リポジトリパターンの再考

### 従来のリポジトリパターン

**Ed**: リポジトリパターンは関数型で適用できますか？

**Scott**: オブジェクト指向のDDDでは、リポジトリパターンはデータベースとの対話方法です。コレクションを表すオブジェクトを持ち、追加、検索、削除を行うと、それがデータベース操作に変換されます:

- 検索 → クエリ
- 追加 → 挿入
- 削除 → 削除

これは**永続化の等価性**であり、実際のデータベースを気にせずにデータベースをモデリングする方法です。

### 関数型アプローチ

関数型プログラミングでは、**非決定的なコードを避けたい**ので、コアコードでデータベースをいじりたくありません。

代わりに、データベースに追加する必要があるすべてのオブジェクトを構造で追跡し、ワークフローを終えたら、**直接SQLを使って**データベースに追加します。ORMすら不要です。文字通り、データベースに追加するSQLを書くだけです。

### ワークフロー指向の利点

これは簡単です。**この特定のワークフローに必要な最小限のこと**だけを行えばいいからです。データベースで行いたい数万のことを表すインターフェースは不要です。

例えば、メールアドレスを変更するワークフローがあれば、それだけです。メールアドレスを更新するだけ。パスワードを変更したい場合は別のワークフローです。

数千の異なるメソッドを持つインターフェースや、巨大な神オブジェクトを持つ必要はありません。**各ワークフローは独立**しており、1つのことを行います。ワークフロー指向の方法で作業することで、多くの問題が消えていきます。

---

## イベント駆動アーキテクチャとサガパターン

### コマンドとイベント

**Ed**: 本では、コマンドが入力として来て、出力は通常イベントだと言及されていますね。

**Scott**: そうです。例えばECサイトで、フロントエンドのボタンをクリックすると注文オブジェクトが作られ、バックエンドに送られてデータベースに保存されます。

その結果として:

1. フルフィルメント側に「この注文を処理して配送して」というイベントを投げる
2. 請求部門に「この人のクレジットカードからお金を引き落として」というイベントを送る

APIを直接呼ぶこともできますが、相手のシステムがダウンしていたら注文自体が保存されず、エラーハンドリングが問題になります。

そこで、**まず注文を保存し、キューにイベントを積んで**おけば、相手のシステムがあとで処理できます。こうしてドメイン同士を疎結合にできます。

### イベントによるテスト容易性

このようにコードを書くと、**テストが非常に簡単**になります。

例えば、「この商品を購入したらこの金額を請求する」というテストでは:

- **入力**: 購入情報
- **期待される出力**: 「このカードから10ポンド引き落とせ」というイベント

実際に決済を走らせる必要はなく、入力と出力だけをテストすればワークフロー全体を確認できます。モックに頼らず、入力と出力だけで済めば、テストは驚くほど楽になります。

### サガパターンと長時間ワークフロー

**Ed**: サガパターンや、依存関係のある複数の保存が失敗した場合はどうなりますか？

**Scott**: サガパターンは要するに**長時間にわたるワークフロー**です。いま自分がどの段階にいるのかを保存しておく必要があります。

例えば、外部の課金サービスに呼び出しを投げて戻り値を受け取り、それに応じて状態を変える必要が出てきます:

- クレジットカードが拒否された → 注文を「保留中」の状態に戻す
- お客様に「情報を更新してください」とメールを送る

長時間動作し依存関係が多いワークフローでは、**どこまで進んでいるのかを追跡する永続化が必要**になりますが、各ステップ自体は意外とシンプルです。

### 補償トランザクション

**Scott**: ワークフロー自体は成功したけれど、後続の処理でカードからお金を引き落とせなかった場合、「この注文をキャンセルする必要がある」というイベントを再度発行する必要があります。

面白いことに、これは昔からある問題です。コンピュータ登場以前に人々がどう対処していたかを見れば、大いに学べます。

会計士や銀行がよく使う対処法に**補償取引**というものがあります:

1. まずこちらにお金を渡す
2. 後になって資金が無いとわかれば、請求し直して差し引く

現実世界では、多くのことが解決までに何日も、時には数週間もかかります。その前提でシステムを設計しなければなりません。すべてを元に戻せるとは限らない。常にツーフェーズコミットで処理できるわけでもないのです。

### スターバックスの例

有名な記事に「**スターバックスはツーフェーズコミットを使わない**」というものがあります。まさにこの話です。

コーヒーを作っても、お客さんが代金を払わなかったらどうするか:

- 受け渡しと同時に必ず課金するわけではない
- 場合によっては損失として諦めたり
- その客を出入り禁止にしたり

ツーフェーズコミットという技術に頼らない解決策はいくらでもあります。

**Ed**: 現金とカード決済の違いを例に挙げると、現金払いなら、その場で完全に整合しますが、クレジットカードは**最終的な整合性**です。

**Scott**: そうです。ビジネス側は「不正利用で5%は損をするかも」と割り切っているかもしれません。それが事業コストなのです。あるいは保険で損失を補填するかもしれません。

コンピュータで必ずしも解決できるとは限りません。コンピュータ以前から存在していた対処法を学ぶべきです。

---

## AIの台頭と開発者の未来

### AIの位置づけ

**Ed**: AIが開発の風景をどう変えていると思いますか？

**Scott**: AIは確かにコーディングのスピードを上げられます。しかし、**曖昧さなく望む動きを説明する行為こそがプログラミング**です。

コミットストリップの漫画にもありましたが、「曖昧さなく望む動きを説明できれば、あとはAIがコードを書いてくれるからプログラマーはいらない」という話があります。でも、その説明する行為がプログラミングなのです。レベルが高くなるだけで、本質的には変わりません。

### プロンプトとDSL

英語でプロンプトを書けば十分と言う人もいますが、**英語はプログラムを記述するには曖昧すぎる**と私は思います。いずれAI向けのDSLが生まれて、今よりずっと曖昧さが少ない言語で指示するようになるかもしれません。それってSQLのようなプログラミング言語ですよね。

### AIは専門家を置き換えられるか

「お客さんがAIと直接話せば開発者はいらない」という話も聞きますが、それは昔から同じです。専門家が不要になるわけではありません。専門家は:

- セキュリティ
- パフォーマンス
- スケーリング
など、多くの観点を考慮します。

無計画にAIにコードを書かせれば悲惨な結果になるかもしれません。実際、**データベース全体をtruncateしてしまうような事故**も起きています。

非プログラマーの言葉をコンピュータが理解できる要求に翻訳できる人材は不可欠です。これは今後も価値があるスキルです。

### ジュニア開発者の育成問題

心配なのは、**ジュニア開発者の育成が難しくなること**です。AIは学びませんが、人を育てれば2年、5年で優れた開発者になります。その芽を摘んでしまうと、将来的にシニア開発者が不足する恐れがあります。シニアは突然現れるわけではありません。

### AIは道具である

AIは道具です。何をしているか理解しているなら、技能を増幅してくれます。鉛筆ではなくワープロで文章を書くようなものです。

ただし、**スペルチェッカーが役に立つのは、自分が綴りを理解している場合だけ**です。綴りを知らない人が使えば、とんでもない結果になります。つまり、基本を理解したうえで使えばスピードアップできるということです。

資本主義の仕組みを考えると、人を補強するのではなく**置き換える方向に使われがち**なのが心配です。それは良いことだとは思いませんし、きっと痛い目を見る人が出るでしょう。

### AIバブルの可能性

**Ed**: 今は巨大なバブルの最中だと思いますか？

**Scott**: はい。現状のAIを動かすには**膨大な計算資源が必要**ですし、多くのAI企業が赤字です。状況は変わるかもしれませんが、今のところはそうです。

私は過去のハイプを何度も経験しているので少し懐疑的です。電信、鉄道、テレビ、電子機器、ドットコムなど、歴史的にもバブルは何度もありました。

バブルは弾けますが、**後には有用なものが残ります**:

- 鉄道バブル → 線路
- ドットコムバブル → 高速インターネット

AIも便利な道具を残すでしょうが、専門家を置き換えるほど信頼できるものはまだ見ていません。

### AIの個人的な利用

**Ed**: 実際にAIを使っていますか？

**Scott**: ほとんど使っていません。理由は:

1. **有料プランに引き込まれたくない**
2. 自分が使いたいフレームワークがあるなら、**自分で学びたい**

AIがコードを生成しても、それが良いコードか判断できなければ意味がありません。判断できないならゴミかもしれないし、そもそも**自分が何を知らないのかも分からない**。

助けが役に立つかを判断するには、**自分自身がある程度習熟していなければならない**のです。もちろん、一度身につけてしまえば、その後は補助として使うのは大いにアリだと思います。

思考そのものを置き換えるために使うのでなければ問題ありません。

---

## 効果的な学習方法

### 複数のアプローチの組み合わせ

**Ed**: 最も効果的に学ぶ方法は何ですか？

**Scott**: 私は**複数のアプローチを組み合わせて、真ん中で落ち合う**のが好きです。

例えば新しいプログラミング言語を学ぶなら:

1. **プロトタイプを作る**: 小さなプロジェクトを設計して実際に何かを作り始める
2. **ドキュメントを読む**: 公式ドキュメントや仕様を読む
3. **他の人の例を見る**: ほかの人がどう書いているかを調べる

### 外国語学習のアナロジー

外国語を学ぶときと同じです。会話を練習するだけでなく:

- ラジオを聞く
- 新聞を読む
- 文法書で語彙を覚える

**どれか一つだけでは不十分**で、複数のアプローチを組み合わせるのが最速で最良の方法だと考えています。

### 多角的なアプローチの重要性

プログラミングでも他の学びでも同じです:

- **実践**の積み重ね
- **読書**
- **他者からのフィードバック**

一つのやり方だけで済むとは思えません。**いろいろな角度から攻めるほど学びは深くなる**と思います。アプローチが多いほど良いのです。

---

## まとめ

このエピソードでは、関数型アプローチでドメインを扱う際の具体的なテーマを掘り下げました。主なポイント:

### 技術的な洞察

1. **関数型プログラミングの基本姿勢**: 小さな純粋関数を合成し、パイプラインで思考の流れをそのままコード化する方法

2. **型システムによる表現力**: 代数的データ型を用いてルールを型に閉じ込め、バリデーションやエラー防止を強化する手法

3. **ドメイン要素のモデル化**: エンティティと値オブジェクト、集約を不変データで表し、ユビキタス言語と整合させる工夫

4. **ワークフロー指向設計**: コマンド入力からイベント出力までを直列化し、コンポジションと差分変更を容易にする考え方

5. **イベント駆動とサガ**: キューを使った非同期連携や補償トランザクションで長時間処理と失敗を取り扱う戦略

6. **永続化戦略の再考**: リポジトリパターンを必須とせず、ワークフローごとに必要な永続化操作だけを集約する関数型的なアプローチ

7. **テスト容易性**: 純粋関数として設計することで、副作用を切り離し、入出力の検証だけでワークフロー全体を確認できる利点

### 開発者の未来とAI

- AIは**補助ツール**として有用だが、専門家の判断を置き換えることはできない
- **基本を理解したうえで**AIを使うことで、生産性が向上する
- ジュニア開発者の育成が困難になる可能性への懸念
- AIバブルの可能性と、それでも有用な遺産が残るという見通し

### 学習への示唆

- **複数の学習方法を組み合わせる**ことが最も効果的
- 実践、読書、フィードバックの三位一体
- いろいろな角度から攻めるほど学びは深くなる

テクノロジーよりも、**明確な境界づけとプロセス理解を重視する姿勢**が一貫しており、関数型プログラミングがDDDの実践をどのように後押しするかを具体的に示す内容でした。

---

## 関連リンク

- [Compiled Conversations ポッドキャスト](https://compiledconversations.com/9/)
- [Ed Mann氏のX](https://x.com/edd_mann/)
- [Scott Wlaschin氏のX](https://x.com/ScottWlaschin/)

### シリーズ記事

- [(1)-1](https://zenn.dev/jtechjapan_pub/articles/b0ab091b9d1946)
- [(1)-2](https://zenn.dev/jtechjapan_pub/articles/788dea679049cb)
- [(1)-3](https://zenn.dev/jtechjapan_pub/articles/17675dd2adf7a8)
- [(2)-1](https://zenn.dev/jtechjapan_pub/articles/8c1c7c88f216bd)
- [(2)-2](https://zenn.dev/jtechjapan_pub/articles/41a5cd66900e36)
- **(2)-3** (本記事)
