---
title: "ソースコードブランチ管理のパターン - Martin Fowler's Bliki (ja)"
source: "https://bliki-ja.github.io/PatternsForManagingSourceCodeBranches/"
author:
  - Martin Fowler
  - "@yuichielectric (翻訳)"
published: 2020
created: 2025-10-06
description: |
  最新のソース管理システムはブランチを簡単に作成できるが、マージは困難を伴う。本記事では、複数開発者の作業統合と本番リリースまでの道筋を効率化するためのブランチ管理パターンを解説。メインラインインテグレーション、フィーチャーブランチ、継続的インテグレーション、リリースブランチなど、様々なパターンのトレードオフと適用場面を詳述する。
tags:
  - "ソースコード管理"
  - "ブランチ戦略"
  - "継続的インテグレーション"
  - "Git"
  - "開発プロセス"
  - "マージ戦略"
  - "リリース管理"
---

## 概要

ソースコード管理システムは、ブランチを簡単に作成できる強力なツールを提供しているが、最終的にはこれらのブランチをマージする必要があり、多くのチームが混雑したブランチへの対処に膨大な時間を費やしている。本記事では、複数の開発者の作業を効率的に統合し、本番リリースまでの道筋を整理するための様々なブランチ管理パターンを解説する。

**中心的なテーマ**: ブランチを頻繁にインテグレーションし、最小限の労力で本番環境に展開できる健全なメインラインを作ることに注力すべきである。

## ベースパターン

### ソースブランチング ✣

コードベースのコピーを作成し、そのコピーへのすべての変更を記録する基本的なパターン。ブランチを切ることは簡単だが、マージは困難である。

**重要な概念**:

- **ブランチ**: コードベースへの一連のコミット
- **テキストの衝突**: ソース管理システムが検出できる衝突
- **意味的衝突**: テキストは問題なくマージされるが、システムが動作しない衝突（例：関数名の変更と旧名での呼び出し）

**課題**: 並行コンピューティングと同様の問題。開発者が共有状態（コードベース）に対して並列に更新を行い、これらを結合する必要がある。

### メインライン ✣

プロダクトの現在の状態を表す単一の共有ブランチ。新しい作業を始める際の出発点であり、変更を共有する際の統合先となる。

**利点**:

- チームの誰もが現在のコードベースの状態を簡単に把握できる
- 他のパターンの基礎となる
- インテグレーションが簡単になる

**命名**: gitでは"master"、subversionでは"trunk"と呼ばれることが多い。

### 健全なブランチ ✣

各コミットで自動チェック（通常はビルドとテスト）を実行し、ブランチに不具合がないことを確認する。

**実現方法**:

- **自己テストコード**: 本番コードと共に包括的な自動テストを作成
- **コミットスイート**: 10分以内に実行される迅速なテスト群
- **デプロイメントパイプライン**: 複数のステージに分けられたテスト

**重要性**: 健全なメインラインがあれば、開発者は常に安定した基盤から作業を開始でき、新しいプロダクション候補をいつでも構築できる。

## インテグレーションパターン

### メインラインインテグレーション ✣

開発者がメインラインからプルし、マージし、メインラインにプッシュすることで自分の作業をインテグレーションする。

**プロセス**:

1. メインラインをローカルにプル
2. 自分の変更とマージ
3. ビルド・テストで健全性を確認
4. メインラインにプッシュ（**これで初めてインテグレーション完了**）

**重要**: プルだけではインテグレーションではない。プッシュして初めて、チーム全体とインテグレーションされる。

### フィーチャーブランチ ✣

ある機能のためのすべての作業を専用のブランチに置き、機能が完成したらメインラインにインテグレーションする。

**特徴**:

- 機能ごとに独立したブランチを作成
- 作業中はメインラインから定期的にプル
- 機能完成後にメインラインインテグレーションを実行

### インテグレーションの頻度

**低頻度インテグレーションの問題**:

- 大規模で複雑なマージ
- 衝突の発見が遅れる
- マージの不確実性が高い（インテグレーションへの恐怖）

**高頻度インテグレーションの利点**:

- 小さく管理しやすいマージ
- 衝突の早期発見
- リスクと不確実性の軽減
- リファクタリングの促進

**重要な原則**: 「痛みがあることはもっとやれ」（頻度は難易度を下げる）

### 継続的インテグレーション ✣

開発者が共有可能で健全なコミット（大抵は一日の作業より小さい単位）ですぐにメインラインにインテグレーションする。

**特徴**:

- インテグレーションのトリガー: 機能完成ではなく、健全な進捗があればいつでも
- 経験則: 「誰もが毎日メインラインにコミットする」
- 部分的に構築された機能の管理が必要（Keystone Interface、機能フラグなど）

**メリット**:

- 機能開発期間より高頻度なインテグレーション
- 衝突の早期発見
- より小さなマージ
- リファクタリングの奨励
- ソフトウェアデリバリパフォーマンスの向上（State of DevOps Reportで実証）

**前提条件**: 強力なテスト体制、健全なブランチを維持するスキル

### フィーチャーブランチと継続的インテグレーションの比較

**フィーチャーブランチ**:

- ✔ 機能内のすべてのコードを一つの単位として評価可能
- ✔ 機能完了時のみプロダクトに追加
- ☓ マージの頻度が低い

**継続的インテグレーション**:

- ✔ 機能開発期間より高頻度なインテグレーション
- ✔ 衝突の早期発見、より小さなマージ
- ✔ リファクタリングを奨励
- ☓ ブランチを健全に保つ能力が必要

**オープンソースとの違い**: オープンソースではフィーチャーブランチが理にかなうが、商用チーム（フルタイムスタッフ、高い信頼度）では継続的インテグレーションがより適している場合が多い。

### レビュー済みコミット ✣

メインラインへのすべてのコミットを受け入れる前にレビューを行う。

**利点**:

- コードの品質向上
- メンテナ/コントリビュータモデルに適合

**欠点**:

- インテグレーションプロセスに時間追加（インテグレーション頻度の低下）
- レビューが遅れると価値が低下

**代替案**:

- ペアプログラミング（継続的なコードレビュー）
- コミット後のレビュー
- リファクタリング文化

**適用場面**: チームの社会構造に依存。信頼度の高いチームでは必須ではない。

### インテグレーションへの摩擦

インテグレーションを難しくしたり時間をかけさせる活動。摩擦が多いほど、インテグレーション頻度は下がる。

**摩擦の原因**:

- マニュアルプロセス
- 組織間の調整
- 複雑な承認フロー
- 文化的要因（信頼の欠如）

**対策**: 自動化、教育改善、プロセスの後段階への移動

### モジュール性の重要さ

**Bodartの法則**: 「フィーチャーブランチは貧者のためのモジュラーアーキテクチャである」

**相互関係**:

- 優れたモジュール性 → 衝突の減少、インテグレーションの容易化
- 高頻度インテグレーション → リファクタリングの促進 → モジュール性の向上

**教訓**: 乱雑なマージが発生した場合、それはモジュール性を改善する重要な手がかり。

## メインラインから本番リリースへの道のり

### リリースブランチ ✣

リリース準備の整ったバージョンを安定させるためのコミットのみを受け入れるブランチ。

**プロセス**:

1. 現在のメインラインからコピー
2. 新機能の追加は禁止（メインラインで継続）
3. リリースを妨げる不具合の修正のみ実施
4. 修正はメインラインにマージ

**修正の方向**:

- リリースブランチで修正 → メインラインにマージ
- または、メインラインで修正 → リリースブランチにチェリーピック

**複数バージョンの運用**: 顧客のキット上で動作するソフトウェアでは、バージョンごとにリリースブランチを維持。

**使用場面**:

- メインラインを健全に保てないチーム
- 本番環境で複数のバージョンを運用する製品（必須）
- リリースプロセスに大きな摩擦がある場合

### 成熟度ブランチ ✣

ヘッドがコードベースの成熟度が異なるそれぞれの最新バージョンを指すブランチ。

**目的**: リリースワークフローの各段階（QA、ステージング、本番など）に到達したコードの最新バージョンを追跡。

**代替案**: タグの命名規則（例: qa-762, prod-762）

**評価**: 強いメリットもコストもない。デプロイメントパイプラインの不備を示す兆候かもしれない。

### 環境ブランチ ✣（アンチパターン）

異なる環境で動作するようにソースコードに適用されるコミットを含むブランチ。

**問題点**:

- 環境ごとの挙動の違いやバグを引き起こす
- 本番環境でのみ現れるバグのリスク
- 柔軟性が逆に危険性を生む

**推奨アプローチ**:

- 一度コンパイルされた実行ファイルはすべての環境で同じものを使用
- 環境依存の設定は明示的な設定ファイルや環境変数で管理
- 環境ブランチは一時しのぎであり、将来的には削除すべき

### ホットフィックスブランチ ✣

本番環境の緊急の欠陥を直す作業を行うためのブランチ。

**プロセス**:

1. 最新のリリースされたバージョンからブランチを切る
2. 修正を実施
3. 本番環境に適用
4. メインラインにマージ（次のバージョンでのリグレッション防止）

**リリースブランチとの組み合わせ**: リリースブランチをホットフィックスブランチとして再利用可能。

**継続的デリバリーの場合**: メインラインから直接ホットフィックスをリリース可能。特別な扱いは不要。

### リリーストレイン ✣

定期的に発車する列車のように、設定された時間間隔でリリースを行う。

**メカニズム**:

- 定期的なリリーススケジュール（例: 毎月）
- 各リリースのためにリリースブランチを切る日付を設定
- 開発者は機能をどの列車に乗せるか決定
- 列車出発後、そのブランチは修正のみ受け入れる

**ソフトフリーズとハードフリーズ**: 出発数日前にソフトフリーズ、その後ハードフリーズ。

**利点**:

- リリースプロセスの規則性
- リリース摩擦が大きい場合に有効
- 機能完成時期の予測可能性向上

**欠点**: 早期に完成した機能が出発を待つ間の待ち時間。

**改善パス**: リリースプロセス改善の第一歩として有用。頻度を徐々に上げ、最終的には継続的デリバリーへ移行。

### リリース可能なメインライン ✣

メインラインの先頭が常に本番にデプロイできるように、メインラインを十分に健全に保つ。

**特徴**:

- リリースブランチ不要
- タグでリリースを記録
- 継続的デリバリーの中心的な考え方

**継続的デリバリー vs 継続的デプロイメント**:

- 継続的デリバリー: すべての変更はリリース可能だが、リリースするかはビジネス判断
- 継続的デプロイメント: すべての変更を自動的にリリース

**適用条件**:

- 高頻度インテグレーション（継続的インテグレーション）
- 強力なデプロイメントパイプライン
- 自己テストコード

**利点**:

- シンプルさ
- ブランチの複雑さの排除
- 価値ある規律の奨励
- チームのストレス軽減

**注意**: 低頻度インテグレーションのチームには不適切な場合あり。まずインテグレーション頻度を上げることが優先。

## その他のブランチパターン

### 実験的ブランチ ✣

製品にマージされることを期待されていない、コードベース上の実験的な作業を行う場所。

**目的**: 新しいライブラリやアプローチの評価。コードの貢献ではなく学習が目的。

**作業後**: タグを追加してブランチを削除（"exp"で始まるタグ名など）。

### 未来ブランチ ✣

他のアプローチでは対応できないような侵襲性の高い変更に使用される単一のブランチ。

**特徴**:

- 継続的インテグレーションを使用しているチームの稀なパターン
- 未来ブランチで作業する人は継続的インテグレーションを実施
- メインラインから定期的にプル

**使用場面**: 最後の手段。抽象化によるブランチなどの代替策が見つからない場合のみ。

### コラボレーションブランチ ✣

正式なインテグレーションを行わずに、開発者がチームの他のメンバーと作業を共有するために作成されたブランチ。

**使用場面**:

- インテグレーション頻度が低い場合により有用
- 実験的ブランチでの共同作業
- 継続的インテグレーションのチームではあまり必要ない

### チームインテグレーションブランチ ✣

メインラインとインテグレーションする前に、サブチームがお互いにインテグレーションできるようにする。

**使用理由**:

- 期待するインテグレーション頻度の違い
- 健全さの基準の違い
- プロジェクト全体とサブチームの組織構造

**評価**: 大抵の場合、同じメインラインで作業可能。チームインテグレーションブランチの必要性を慎重に検討すべき。

## ブランチポリシー

### Git-flow

**構成**:

- メインライン（"develop"）
- フィーチャーブランチ
- リリースブランチ
- 本番用成熟度ブランチ（"master"）
- ホットフィックスブランチ

**対象**: 複数のバージョンが本番でリリースされているプロジェクト（顧客環境へのインストール型ソフトウェア）。

**問題**: 単一バージョン運用のウェブアプリケーションには過度に複雑。

### GitHub Flow

**構成**:

- メインライン（"master"）
- フィーチャーブランチ

**特徴**:

- リリース可能なメインライン
- 高頻度インテグレーション
- プルリクエスト（レビュー済みコミット）

**対象**: 運用バージョンが一つだけで、高頻度でリリースする製品。

**Git-flowとの違い**: 単一バージョン運用のため、リリースブランチとホットフィックスブランチが不要。

### トランクベース開発

**中心概念**: すべての作業をメインライン（"トランク"）上で行い、生存期間の長いブランチを避ける。

**アプローチ**:

- 小規模チーム: メインラインに直接コミット
- 大規模チーム: 数日以内のフィーチャーブランチ
- 実質的に継続的インテグレーション

**リリース**: リリースブランチ（"リリースのためのブランチ"）またはリリース可能なメインライン（"トランクからのリリース"）。

## 最終的な感想とおすすめ

### 重要な原則

1. **「ブランチは簡単、マージは難しい」**: ブランチ使用時は常にマージ方法を考慮すべき。

2. **代替手段の検討**: ブランチの代わりにモジュール性の改善、デプロイメントパイプラインの改善、タグの使用などを検討。

3. **インテグレーション頻度の向上**: インテグレーション頻度を2倍にすることを目指す。障壁は開発プロセス改善のための重要な指標。

4. **マージの困難さへの注目**: マージを難しくしている原因（プロセス、アーキテクチャ）に注意を払い、改善の道しるべとする。

5. **コンテキストの重要性**: パターンの価値はコンテキスト次第。一概に良い悪いはない。

### 著者の個人的見解

Martin Fowlerは継続的インテグレーションを実践するチームで仕事をする方が好ましいと述べている。ただし、コンテキストが重要であり、状況によってはリリースブランチなど他のアプローチが適切な場合もある。重要なのは、チームが変化するビジネスニーズに迅速に対応できる環境を作ることである。

### 継続的インテグレーションへの道

低頻度インテグレーションのチームは、まずインテグレーション頻度を上げることが優先。場合によってはリリース可能なメインラインを一時的に諦め、リリースブランチを使用しながら、徐々にデプロイメントパイプラインを改善していくアプローチが有効。

## 参考文献

- **Steve Berczuk**: [Software Configuration Management Patterns](https://www.amazon.co.jp/dp/4798112593/)
- **State of DevOps Report**: 高頻度インテグレーションがソフトウェアデリバリパフォーマンス向上に貢献することを実証
- **Paul Hammant**: [trunkbaseddevelopment.com](https://trunkbaseddevelopment.com/) - 継続的インテグレーションのテクニック満載のウェブサイト

---

**原著者**: Martin Fowler  
**翻訳**: [@yuichielectric](https://github.com/yuichielectric), [bliki-ja](https://github.com/bliki-ja)チーム  
**原文**: <https://martinfowler.com/articles/branching-patterns.html>
