---
title: "ポリモーフィズムが1種類しかないと思ってたエンジニアの備忘録"
source: "https://zenn.dev/loglass/articles/3883eb1fa6607e"
author:
  - "Ryoya (福土)"
  - "株式会社ログラス"
published: 2025-01-03
created: 2025-10-17
description: |
  ポリモーフィズムには複数の種類が存在することを学んだエンジニアの備忘録。一般的なサブタイピングだけでなく、パラメトリック多相（ジェネリクス）やアドホック多相（オーバーロード）も含まれることを、Kotlinのコード例を交えて解説。
tags:
  - "Kotlin"
  - "ポリモーフィズム"
  - "サブタイピング"
  - "パラメトリック多相"
  - "アドホック多相"
  - "ジェネリクス"
  - "オーバーロード"
  - "オブジェクト指向"
  - "型システム"
---

## はじめに

株式会社ログラスのソフトウェアエンジニア福土氏による技術記事。社内Slackでの会話から、ジェネリクスもポリモーフィズムの一種であることを知り、ポリモーフィズムの概念について整理した備忘録。

## ポリモーフィズムの定義

ポリモーフィズム（polymorphism）は、生物学における「多型」という概念からの借用語。プログラミングの文脈では、**さまざまな振る舞いをするクラスや関数を単一のインターフェースで使いまわせるようにすること**を指す。

### 特徴

- 異なる型に一元アクセスできる共通接点の提供
- 異なる型の多重定義を一括表現できる共通記号の提供

### メリット

- コードの再利用性が高まる
- コードの柔軟性が上がる
- コードの可読性が上がる

## ポリモーフィズムの3つの種類

### 1. サブタイピング（Subtyping / Inclusion Polymorphism）

**ある型が別の型の1種である（is-a関係）という関係を利用し、スーパータイプとしてサブタイプのオブジェクトを扱えるようにするポリモーフィズム**。

#### 基本概念

- スーパータイプ：共通のプロパティやメソッドを定義
- サブタイプ：スーパータイプを継承または実装し、より具体的な型を作成
- リスコフの置換原則を満たす

#### 実装例（Kotlin）

```kotlin
interface Animal {
    fun cry()
}

class Dog : Animal {
    override fun cry() {
        println("ワンワン！")
    }
}

class Cat : Animal {
    override fun cry() {
        println("ニャンニャン！")
    }
}

fun makeAnimalCry(animal: Animal) {
    animal.cry()
}

val dog = Dog()
val cat = Cat()
makeAnimalCry(dog)  // 出力: ワンワン！
makeAnimalCry(cat)  // 出力: ニャンニャン！
```

#### 利点

- 不要なif文やswitch文を書かずにコードを実装できる
- 単一のインターフェースから異なる型のオブジェクトを扱える
- 呼び出し元で型の違いを意識する必要がない

### 2. パラメトリック多相（Parametric Polymorphism）

**型パラメータを使用して、特定の型に依存せずに汎用的な関数やデータ型を定義し、任意の型に対して同一の実装を適用できるポリモーフィズム**。ジェネリクスとも呼ばれる。

#### 基本概念

- 型をパラメータとして扱う
- 型安全性を担保しつつコードの再利用性を高める
- 呼び出し側が柔軟に異なる型を扱える

#### 関数の実装例

```kotlin
fun <T> printList(items: List<T>) {
    for (item in items) {
        println(item)
    }
}

val intList: List<Int> = listOf(1, 2, 3)
val stringList: List<String> = listOf("Apple", "Banana", "Cherry")

printList(intList)      // 出力: 1 2 3
printList(stringList)   // 出力: Apple Banana Cherry
```

#### クラスの実装例

```kotlin
class Stack<T> {
    private val elements: MutableList<T> = mutableListOf()

    fun push(item: T) {
        elements.add(item)
    }

    fun pop(): T? {
        if (elements.isEmpty()) return null
        return elements.removeAt(elements.size - 1)
    }
}

val intStack = Stack<Int>()
intStack.push(1)
intStack.push(2)

val personStack = Stack<Person>()
personStack.push(Person("Alice", 29))
```

#### 特徴

- 型パラメータ（T）により、同じコードで異なる型を扱える
- コンパイル時に型チェックが行われ、型安全性が保証される
- 同一の型のみをコレクションに追加可能

### 3. アドホック多相（Ad Hoc Polymorphism）

**同じ関数名や演算子が異なる型に対して異なる実装を持ち、特定の型ごとに異なる動作を提供するポリモーフィズム**。オーバーロード（オーバーローディング）とも呼ばれる。

#### 基本概念

- 型システムの基本的な機能ではない（言語の追加機能）
- 特定の型について個別の実装を提供
- 開発者が各型に対する実装を明示的に定義する必要がある

#### 名前の由来

「アドホック」は「このために」という意味で、**特定のデータ型に特に関連している**ことを示す。パラメトリック多相が型に依存しないのに対し、アドホック多相は型に基づく。

#### 関数のオーバーロード例

```kotlin
class Calculator {
    fun add(a: Int): Int {
        return a + 10
    }
    
    fun add(a: Int, b: Int): Int {
        return a + b
    }
}

val calculator = Calculator()
println(calculator.add(5))      // 出力: 15
println(calculator.add(5, 1))   // 出力: 6
```

#### 演算子のオーバーロード例

```kotlin
data class Vector(val x: Double, val y: Double) {
    operator fun plus(v: Vector): Vector = 
        Vector(this.x + v.x, this.y + v.y)
}

val vector1 = Vector(1.0, 1.0)
val vector2 = Vector(2.0, 3.0)
println(vector1 + vector2)  // 出力: Vector(x=3.0, y=4.0)
```

#### 特徴

- 同じメソッド名でも引数の個数や型が異なれば異なるメソッドとして扱われる
- `operator`キーワードにより演算子を独自定義可能
- 特定の型に対して個別の振る舞いを実装

## ポリモーフィズムの分類

```
ポリモーフィズム
├── Universal Polymorphism（型に依存しない）
│   ├── サブタイピング（Inclusion Polymorphism）
│   └── パラメトリック多相（Parametric Polymorphism）
└── Ad Hoc Polymorphism（型に基づく）
    ├── 関数のオーバーロード
    └── 演算子のオーバーロード
```

## まとめ

ポリモーフィズムはサブタイピングだけでなく、ジェネリクス（パラメトリック多相）やオーバーロード（アドホック多相）も含む広い概念である。これらを適切に活用することで：

- コードの冗長性を削減
- SLAP（Single Level of Abstraction Principle）を満たす
- コードの保守性が向上

単一インターフェースから様々な派生型や振る舞いを呼び出せることで、より柔軟で再利用可能なコードを実現できる。

## 補足

著者は共変性・反変性の概念についても続編で扱う予定としている。本記事は株式会社ログラスの技術ブログ「Loglass Tech Blog Sprint」の72週目の記事として公開された。
