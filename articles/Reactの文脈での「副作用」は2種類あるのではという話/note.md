# Reactの文脈での「副作用」は2種類あるのではという話

ref: <https://zenn.dev/uhyo/articles/react-two-side-effects>

## 問題提起: `useEffect`と`fetch`

React開発において「副作用」という言葉は頻繁に使われますが、実は異なる2つの意味合いで用いられている可能性があります。この混同が、例えば「`useEffect`の中で`fetch`（ネットワークリクエスト）を実行するのは適切か？」といった議論で混乱を生んでいると考えられます。

* **一方の意見:** `useEffect`は副作用を扱うフックであり、`fetch`は副作用なのだから、`useEffect`内での`fetch`は自然である。
* **筆者の意見:** これは2種類の「副作用」を混同した誤解である可能性が高い。以下の2文で使われる「副作用」は、異なる概念を指している。
  * 「`useEffect`はコンポーネントの**副作用**を記述するためのフックである。」
  * 「Reactではコンポーネントは純粋に保つべきであり、コンポーネント内に直接**副作用**を記述してはいけない。」

**注意:** この記事は筆者の考察であり、Reactの公式見解ではありません。

## `useEffect`の"副作用" (副作用①: コンポーネントの作用の一部)

* **定義:** コンポーネントの**主たる作用**（レンダリング結果としてDOMを表示すること）**以外**の、「コンポーネントが表示されていることによる追加の作用」。コンポーネントの存在に紐づく、レンダリング以外の影響。
* **例:** コンポーネントが表示されている間、`document`全体にスクロールイベントハンドラを登録する。

    ```javascript
    useEffect(() => {
      const controller = new AbortController();
      document.addEventListener("scroll", () => { /* ... */ }, {
        passive: true,
        signal: controller.signal,
      });
      // クリーンアップ関数: アンマウント時にイベントハンドラを削除
      return () => {
        controller.abort();
      };
    }, []);
    ```

* **重要な原則:** この副作用①は、**あくまでコンポーネントの作用の一部**であり、以下の原則に従う必要がある。
    1. **コンポーネントのライフサイクルとの同期:** 副作用はコンポーネントがマウントされている間だけ有効であり、アンマウント時には消える（クリーンアップされる）必要がある。
    2. **純粋な計算に基づく決定:** 主作用（表示内容）と同様に、副作用の内容もコンポーネントのpropsやstateを入力とする純粋な計算によって決定されるべきである。propsやstateが変われば、副作用もそれに応じて変化（再実行やクリーンアップ）する必要がある。
* **`useEffect`の役割:** この副作用①を、コンポーネントのライフサイクル（マウント、アンマウント、props/stateの変更）に合わせて、上記の原則通りに正しく実装・管理するためのAPI。

## プログラムの一般的な概念としての副作用 (副作用②: 純粋性を壊すもの)

* **定義:** 関数型プログラミングなどで一般的に使われる用語。関数の主な仕事（入力に基づき計算し、値を返すこと）**以外**に、外部の状態を変更したり、外部とやり取りしたりする**あらゆる影響**のこと。これを持つ関数は「純粋関数」ではない。
* **例:**
  * ネットワークリクエスト (`fetch`)
  * コンソールへのログ出力 (`console.log`)
  * 外部変数の変更
  * DOMの直接操作
* **Reactにおける位置づけ:**
  * Reactはコンポーネントの**レンダリングロジック**を純粋に保つことを推奨している（同じprops/stateなら常に同じJSXを返す）。レンダリング中に副作用②を起こすべきではない。
  * `useState`の更新関数なども純粋関数であるべきとされる。
  * 副作用②は、レンダリングとは切り離された場所、**主にイベントハンドラ内**で発生させることが推奨される。

## 2つの副作用の関係と`useEffect`の誤用可能性

* **副作用① (コンポーネント作用)** と **副作用② (純粋性破壊)** は異なる概念だが、関連性はある。
* React公式ドキュメント ([Keeping Components Pure](https://ja.react.dev/learn/keeping-components-pure#where-you-can-cause-side-effects)) では、副作用②について次のように述べている（要約）:
    > * 副作用（データの変更など）は必要だが、レンダー中には起こすべきではない。
    > * Reactでは、**副作用は通常、イベントハンドラの中に属する。**
    > * 適切なイベントハンドラが見つからない場合、**最終手段として** `useEffect` を使い、レンダー後に副作用を実行させることができる。
* **筆者の解釈:**
  * この公式ドキュメントの記述は、「副作用②を発生させる手段として`useEffect`を**使うこともできる**（ただし最終手段）」という意味合いである。
  * これは、本来副作用①（コンポーネントの作用）のために設計された`useEffect`が、副作用②（一般的な副作用）を実行するためにも**転用できてしまう**ことを示唆している。
  * しかし、「レンダー時に何か副作用②を発生させたい」という理由だけで`useEffect`を使うのは、多くの場合**`useEffect`の意図された使い方ではない**。なぜなら、その副作用②がコンポーネントのライフサイクル（副作用①の原則）と同期する必要があるとは限らないから。
  * 「`useEffect`は副作用のためのフックだから、どんな副作用②でも自由に起こしてよい」という考え方は、これら2つの副作用概念を混同している可能性がある。

## まとめ

* Reactの文脈で「副作用」という言葉を聞いたときは、それが以下のどちらの意味で使われているかを意識することが重要。
    1. **副作用①:** `useEffect`で管理されるべき、コンポーネントの存在とライフサイクルに同期した**作用**。
    2. **副作用②:** プログラム一般で言われる、純粋性を壊す可能性のある**外部への影響**。
* `useEffect`は基本的に**副作用①**を正しく実装するためのフックである。
* 副作用②を行いたい場合は、まず**イベントハンドラ**内での実行を検討すべき。
* 副作用②のために`useEffect`を使うのは、他に適切な方法がない場合の**最終手段**と考えるべきであり、乱用は避けるべき。

## 余談 (筆者の本来のスタンス)

* 筆者個人としては、`useEffect`で扱うものを「副作用 (side effect)」と呼ぶこと自体が、この混乱の一因だと考えている。
* `useEffect`という名前が示す通り、これはコンポーネントの「作用 (effect)」の一部を定義するAPIであり、「副作用」ではなく単に「**エフェクト**」と呼ぶ方が、その役割をより正確に表しているのではないか。エフェクトはコンポーネントの主作用ではないが、コンポーネントの責務の一部である、という考え方。
* この記事では、一般的に「副作用」という用語が広く使われている現状を踏まえ、読者に伝わりやすいようにあえてその用語法に則って議論を展開した。

---
