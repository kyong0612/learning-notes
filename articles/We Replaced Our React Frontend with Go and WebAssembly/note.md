# We Replaced Our React Frontend with Go and WebAssembly

ref: <https://dagger.io/blog/replaced-react-with-go>

[![](https://framerusercontent.com/images/AIo0hREWPqWBR5BOWE99wfiL7o.png?scale-down-to=1024)](https://dagger.io/)

数週間前、私たちは [Dagger Cloud v3](https://dagger.io/blog/dagger-cloud-v3) をリリースしました。これは、[Dagger Cloud](https://dagger.cloud/) の全く新しいユーザーインターフェースです。v3 とその前身である v2 との大きな違いのひとつは、新しい UI が Go を用いて [WebAssembly (WASM)](https://en.wikipedia.org/wiki/WebAssembly) で書かれている点です。一見すると、Web UI のプログラミング言語として Go を選ぶのは奇妙に思えるかもしれません。なぜなら、通常 Web UI を実装する際にまず思い浮かぶ言語は Go ではないからです。しかし、私たちにはその選択に十分な理由がありました。このブログ記事では、なぜ WebAssembly を選んだのか、実装時に直面した課題（およびその回避策）、そしてその結果について説明します。

### 2 つのコードベース = 作業量増加、機能は少なく

Dagger は操作の DAG（有向非巡回グラフ）を構築し、それを並行して評価することで動作します。そもそも、これを表示するのは非常に難しい課題です。ユーザーが理解しやすいように、私たちは [2 つのリアルタイム可視化インターフェース](https://docs.dagger.io/features/visualization) を提供しています。ひとつは Dagger CLI に含まれる Dagger のターミナル UI（TUI）、もうひとつはオンラインの Web ダッシュボードである Dagger Cloud です。Dagger TUI は Go で実装されており、従来の Dagger Cloud（v3 以前）は React で書かれていました。

もちろん、どちらのユーザーインターフェースもできる限り互いに近い体験となることを望んでいます。しかし、Dagger のイベントストリームをリアルタイムに解釈して UI を生成するという実作業は非常に複雑です。特に、複雑なイベントストリームでは、数十万件の OpenTelemetry のスパンが発生し、それらを管理するためのデータ構造があっという間に複雑になってしまいます。Web UI は、処理すべき膨大なデータ量に追いつかず、ラグが発生し動作が遅くなることがしばしばありました。このパフォーマンス上のボトルネックを解消するため、React アプリケーションでは別の実装モデルを採用せざるを得なかったのです。

結果として、同じ目的を達成しようとする 2 つのインターフェースが存在することになりました。ひとつは TypeScript/React という言語・エコシステム、もうひとつは全く異なる言語・エコシステムである Go で書かれており、両者でビジネスロジックを容易に共有することができませんでした。小規模なチームとしては、迅速にリリースを行う必要があり、各機能を 2 回実装するのは、私たちの開発スピードにとって非常に大きな負担となっていました。

そこで、Dagger Cloud の新たなアプローチについて検討するようになりました。主な目的は 2 つです。

- コードベースを統一し、重複をなくすことで、新機能のリリースを効率化する
- ターミナル UI と同等の高速で快適な Web UI を実現する

### Go + WebAssembly の選択

最初の目標は、Dagger Cloud と TUI の両方で 1 つのコードベースを再利用できるようにすることでした。私たちは、早い段階でそのコードベースを Go で書くことに決めました。技術的には、TUI を TypeScript で実装するという選択肢もありました。しかし、私たちは主に Go エンジニアで構成されているため、Go を選ぶことでチーム内の他のメンバーが機能追加やバグ修正に短時間でも参加しやすくなります。単一の言語に統一することで柔軟性が増し、チーム内のサイロ化も解消されました。

ブラウザ上で Go のコードを直接実行するという決断を下した時、次に自然な選択肢となったのが WebAssembly でした。しかし、いくつかの課題も残っていました。

- Go と WebAssembly の組み合わせは、React やその他の JavaScript フレームワークほど成熟していません。既製のコンポーネントライブラリがなく、開発ツールも充実していないため、ほとんどの UI コンポーネントをゼロから作成する必要がありました。
- 多くのブラウザでは、WebAssembly アプリケーションのメモリ使用量に厳格な 2GB の制限があります。大規模なトレースを表示する際にこの制限が問題となることが予想され、UI を安定させるためにメモリ使用量を最小限に抑えるための最適化が必要だと認識していました。しかし、この制約のおかげで、WebAssembly UI のメモリ使用量を改善すれば、コードベースを共有しているため TUI ユーザーにも恩恵がもたらされるという側面もありました。

### プロジェクトのリスク低減

決定を下した後、次に「どのようにしてこれを実装するか」という疑問が浮上しました。そこで、私たちは新しい WebAssembly ベースの UI を [Go-app フレームワーク](https://go-app.dev/) で構築することに決めました。Go-app は、WebAssembly 上で動作する [プログレッシブ・ウェブ・アプリ (PWA)](https://en.wikipedia.org/wiki/Progressive_web_app) のための高レベルなフレームワークです。高速なコンパイルやネイティブの静的型付けといった Go の主要な利点を享受でき、React のようなコンポーネントベースの UI モデルも採用しているため、移行がスムーズに進みました。

Go と WebAssembly の組み合わせはまだ主流ではないため、Dagger チーム内ではその実現性に対して健全な懐疑的意見もありました。たとえば、Go-app 用の UI コンポーネントのエコシステムは整っておらず、自前で作成する必要があること、また、他のサービス（Tailwind、Auth0、Intercom、PostHog）との統合や、数百にも及ぶライブアップデートされるコンポーネントのレンダリングに関しても不安がありました。

これらの疑問に答え、プロジェクトのリスクを低減するために、私はほぼ 1 ヶ月間かけてプロトタイピングを行い、既存の UI のできる限り多くを Go-app で再実装することを目標としました。結果として、ブロッカーはそれほど多くはなく、WebAssembly は既に [十分に文書化されたオープンスタンダード](https://webassembly.org/specs/)であり、多くの疑問は [Go-app のドキュメント](https://go-app.dev/reference) で解決されました。予想通り、最大の課題はメモリ使用量の制限であり、これに対しては慎重な設計と最適化が必要でした。

### プロトタイプからプロダクションへ

実証実験が成功したことで、チーム内の安心感が大幅に向上し、「awesome wasm」というプロジェクトを立ち上げ、本番環境向けの実装に着手しました。ここで、この道のりで得た知見をいくつか紹介します。

- メモリ使用量はプロジェクト成功の上で最も大きな脅威でした。20 万行以上のログ出力をクラッシュせずにレンダリングする方法を模索するのに多くの時間を費やしました。結果として、[仮想ターミナルレンダリングライブラリ](https://github.com/vito/midterm) の内部で大幅な最適化を実施し、TUI のメモリ使用量も劇的に削減することができました。（すでに述べたように、コードベースを共有しているおかげで、あるインターフェースでの重要な最適化が他方にも「無料」で反映されるのです。）
- Go WASM は大量の JSON をパースする際に非常に遅いことが判明したため、アーキテクチャの大幅な変更を余儀なくされ、Go のあまり使われない [encoding/gob フォーマット](https://pkg.go.dev/encoding/gob) を利用して、WebSocket を介したインクリメンタルなデータ読み込みを行う「スマートバックエンド」を構築しました。
- 初期状態では WASM ファイルは約 32 MB ありましたが、[Brotli 圧縮](https://github.com/google/brotli) を適用することで、約 4.6 MB にまで圧縮することができました。当初は CDN 上で Brotli 圧縮をオンザフライで行おうとしましたが、ファイルサイズが大きすぎたため、最終的にはビルドプロセスに圧縮工程を組み込みました。
- メモリの課題以外では、初期の懸念のほとんどは杞憂に終わりました。UI コンポーネントの実装自体はそれほど困難ではなく、他サービスとの統合も順調に進み、リアルタイムなコンポーネントの更新に関しても有効な手法を見出すことができました。
- いくつかの有用な NPM パッケージも見つけたため、それらを Go と組み合わせて使えないかと考えました。WebAssembly は Go と JavaScript の両方に対してシンプルなインターフェースを持っているため、[Browserify を使って NPM パッケージを読み込む Dagger モジュール](https://daggerverse.dev/mod/github.com/vito/daggerverse/browserify@d368836636284116d090e271742904fea369cf72) を作成しました。このモジュールにより、Go アプリケーションに組み込むことができる JavaScript ファイルを生成することが可能となりました。つまり、基本的には Go で作業を進めながら、必要に応じてネイティブ JavaScript で実装されたヘルパーを読み込む方法が確保されたのです。
- なお、私は React のプロフェッショナルではないため、その点を踏まえると…React はコンポーネントの実装方法が非常に厳格に決まっているのに対し、Go-app ははるかに柔軟です。Go-app では、任意のタイミングでコンポーネントを更新できるため、最適化のための自由度が大きく向上します。たとえば、15 万行以上の出力をレンダリングするコンポーネントの最適化が必要な際、いくつかのアプローチを試し、最も効果的な方法を選択できたことで、全体の作業が大幅に楽になりました。
- Go-app には React のようなブラウザ内蔵のデベロッパーツールはありませんが、Go 標準のツール（pprof）とブラウザに内蔵されたデフォルトのプロファイラを併用することで、プロファイリングやデバッグを行うことができました。これにより、関数呼び出しの検査、CPU やメモリ使用量の追跡、各種最適化手法の有効性評価が非常に容易になりました。
- Go-app を使用することで、もうひとつの副次的なメリットを発見しました。Dagger Cloud は PWA として構築されているため、デスクトップやモバイルアプリケーションとしてインストールすることが可能です。これにより、ブラウザを立ち上げることなくネイティブアプリのように全画面表示で利用できたり、デスクトップのタスクバーやドックに専用のアイコンを配置したりすることができます。

数週間前に、私たちは [Dagger Commanders](https://dagger.io/commanders) に向けて Dagger Cloud v3 をソフトローンチし、フィードバックを収集した後、すぐに全ユーザーに公開しました。

### 利点

React から WASM への切り替えにより、全ての Dagger インターフェースにおいて一貫性のあるユーザー体験が実現され、特に大規模かつ複雑なトレースのレンダリング時に、全体的なパフォーマンス向上とメモリ使用量の低減が達成されました。

エンジニアリングの観点からも、チームにとって大きなメリットがありました。最適化は新機能の実装と同等、あるいはそれ以上の作業を要することが多いです。したがって、Web UI の最適化に時間をかけ、その後さらに TUI の最適化に時間を費やすのではなく、新機能の提供に集中できるのは大変有意義です。

### これを採用すべきか？

Dagger Cloud v3 は Dagger コミュニティ内で大きな話題となっており、最近よく寄せられる質問のひとつに、「誰がこれを検討すべきで、誰がそうすべきでないのか」というものがあります。

ここで明確にしておきたいのは、フロントエンドを Go で実装することを一般的に推奨しているわけではない、ということです。私たちがこの選択をした背景には、優秀な Go エンジニアが揃っていること、TypeScript/React ではスケールしにくい複雑な UI の存在、2 つのコードベース間での標準化と再利用の必要性、そして会社全体での開発スピード向上の要求という、非常に特定の状況がありました。もしあなたの状況がこれらに近いのであれば、この選択肢は検討に値するかもしれませんが、そうでなければ、まずは他のツールや標準を検討するべきでしょう。

現在、Dagger Cloud v3 はベータ版ですが、ぜひ [試してみて](https://v3.dagger.cloud/) ください。新 UI の実装についてもっと知りたい、またはフィードバックを寄せたい方は、Discord に参加して [ご意見をお聞かせ](https://discord.com/invite/dagger-io) いただければ幸いです。
