---
title: "Go 1.26連載：インデックス＋SIMD"
source: "https://future-architect.github.io/articles/20260127a/"
author:
  - "[[澁川喜規]]"
published: 2026-01-27
created: 2026-01-30
description: "Go 1.26で追加された実験的なsimd/archsimdパッケージの紹介。SIMDを使ったベクトル内積計算で従来比6.6倍の高速化を実現。ollamaを使ったembeddingベクトルの類似検索の実装例も解説。"
tags:
  - "Go"
  - "Go1.26"
  - "SIMD"
  - "ベクトル検索"
  - "パフォーマンス最適化"
---

## Go 1.26連載の概要

Go 1.26のリリースに向けて、新機能を有志で紹介していく連載記事。本記事はその第1回として「インデックス＋SIMD」を扱う。

| 日付 | タイトル | 著者 |
|------|----------|------|
| 1/27 | インデックス+SIMD（本記事） | 渋川 |
| 1/28 | goroutine leak profiler | 武田さん |
| 1/29 | go fix | 真野さん |
| 1/30 | runtime/secret | 島ノ江さん |
| 2/2 | GCの改善 | 棚井さん |
| 2/3 | new(プリミティブ) | 辻さん |
| 2/4 | CGo呼び出し高速化 | 宮崎さん |

## Go 1.26の新機能ダイジェスト

Go 1.26は久々に大きめな変更が多いリリース。全体的に高速化が行われており、アップデートするだけで恩恵がある。

### 主な新機能

- **暗号アルゴリズムの更新**（多数）
- **testing.ArtifactDir**: テスト中間生成物の置き場を提供
- **log/slog**: 複数出力先に一気に出力できる`MultiHandler`追加
- **io.ReadAll**: 消費メモリ削減
- **image/jpeg**: 高速化
- **runtime/secret**: 機密情報を扱う実験的パッケージ
- **simd/archsimd**: SIMD命令を扱う実験的パッケージ（AMD64のみ）
- **compiler改善**: スライスをよりスタックに割り当てられるように
- **goroutine leak profiler**
- **cgo, memory allocate**: 高速化
- **GC**: 1.25で導入されたGCが有効化
- **new(プリミティブ)**

## SIMD（simd/archsimd）パッケージ

### SIMDとは

1つの命令で複数のデータをまとめて処理する命令セット。行列計算などを高速に行うのに使用される。

### Intel系SIMDの世代とレジスタサイズ

| 命令セット | レジスタサイズ |
|------------|----------------|
| AVX512 | 512ビット |
| AVX | 256ビット |
| SSE | 128ビット |
| MMX | 64ビット |

> **注意**: AVX512は10th/11th Gen Core CPUで対応していたが、Eコア・Pコアに分かれた以降のチップからは除去された。使用頻度が限られるため、その分通常コア数増加に充てる方針。

### simd/archsimdパッケージの特徴

- **実験的機能**: コンパイル時に環境変数の設定が必要
- **対応アーキテクチャ**: AMD64のみ（ARM NEONなども将来対応期待）
- 型名は`Float32x8`のように「データ型 x 要素数」の形式
- 合計ビット数は128/256/512ビット
- 演算はメソッドで提供（型によって使えるメソッドに差異あり）

### 歴史的経緯

- Go 1.24で導入されたmapの新アルゴリズム「[Swiss Table](https://go.dev/blog/swisstable)」はSIMDを活用した高速検索
- 従来もアセンブラ（.sファイル）でSIMD命令は使用可能だった
- サードパーティライブラリでSIMD活用の行列演算ライブラリは存在
- 今回、公式サポートとして追加

## ベクトル内積計算の実装例

### ユースケース：類似文書検索

- embeddingで作成したドキュメントベクトルと検索用語ベクトルの内積で類似度を数値化
- 例：「猫」の説明文章に対し、「動物」や「トラ」といった近い言葉で検索可能
- 転置インデックスの全文検索と異なり、意味的に近い内容も検索可能

### 実験環境

- **モデル**: ollama + nomic-embed-text（軽量モデル）
- **出力**: 768次元のベクトル
- **テストデータ**: Real World HTTPの原稿（「クッキーのセキュリティ」で検索）

### パフォーマンス結果

| 実装 | 処理方式 |
|------|----------|
| 通常 | ループで各項の積→和を計算 |
| SIMD（128ビット） | 16ビット要素の積を8つ同時処理 |

**結果: SIMDで約6.6倍の高速化を達成**

### 注意点

- M3 MacBook AirでのテストはRosetta2経由（AMD64エミュレーション）
- Rosettaは公式には128ビットまで対応（非公式に256ビットも動作）
- 256ビット実行時は128ビットの約2倍の時間がかかる（128ビット演算器でエミュレーション）

### データ構造

- SIMDは`[8]int16`などの固定長配列を前提
- `[][8]int16`という二重配列構造でベクトルを計算単位でまとめて渡す
- 積計算はint16、データ自体は8ビットベクトル

## コンパイラの内部処理（1/29追記）

### Intrinsics関数

- 各メソッドに対応するCPU命令がドキュメントに記載
- 1つの関数が1つのアセンブラ命令に対応する「Intrinsics」として実装
- Intelの[C言語リファレンス](https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html)と同様の構造

### Go処理系での実装

- `math/bits`や`sync/atomic`パッケージなどで以前からIntrinsics関数が存在
- 今回のSIMDメソッドも同様の手法で実装
- Go 1.7で導入されたSSA形式により、このような最適化が可能に

## まとめと今後の展望

- **AI界隈で頻出の計算（類似検索、ベクトルDB）がGoで簡単に実現可能に**
- 対応アーキテクチャの拡大に期待（ARM NEON、WASMなど）
- ベクトルデータベースの実装増加に期待

## 制限事項

- 現時点ではAMD64アーキテクチャのみサポート
- 実験的機能のためコンパイル時に環境変数設定が必要
- Apple Siliconではネイティブ未対応（Rosetta2経由でのみ動作）
