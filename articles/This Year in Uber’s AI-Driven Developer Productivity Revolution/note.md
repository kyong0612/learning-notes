# This Year in Uber’s AI-Driven Developer Productivity Revolution

ref:

    - <https://dpe.org/wp-content/uploads/2024/06/Adam-Huda-and-Ty-Smith-Uber-AI.pptx.pdf>
    - <https://www.youtube.com/watch?v=jp-fBw07r7c>

## Uberの規模（ページ2）

- **年間換算総予約額**: 1,600億ドル
- **月間アクティブユーザー**: 1億5,600万人
- **サービス提供都市**: 10,000以上
- **サービス提供国**: 70カ国
- **1日あたりの配車数**: 3,000万件
- **月間アクティブドライバー・配達員**: 740万人
- データは2024年6月20日終了四半期の公式数字に基づく

## プラットフォーム構造（ページ3）

- **機能エンジニア**: 4,500人
- **Developer Platformエンジニア**: 200人（サポート比率 22:1）
- **エンジニアリング拠点**: 3ヶ所以上
- **構成**: Rider App Platform、Earner App Platform、Eats App Platformとこれらをサポートするアンブレラ的なDeveloper Platform

## 開発者体験の現状（ページ4）

- **マイクロサービス**: 5,000以上
- **主要モバイルアプリ**: 3つ
- **マイナーモバイルアプリ**: 6つ
- **モノレポ**: Swift、Kotlin、TypeScript、Go、Java、Pythonの6つ
- **Net Promoter Score**: +8
- **開発者体験の階層**: IDEs & Tools、Training & Documentation、App & Service Frameworks、Internal Libraries & Guardrails、Monorepo Tooling & Build System

## 技術的課題（ページ5-6）

- **コード行数**: 全モノレポにわたり1億行以上
- **技術的負債**: 更新の積み残し、断片化、不十分なテストカバレッジ
- **マクロトレンド**: 人員の横ばい、欠員補充の保証なし
- **核心的課題**: コードベースの成長と保守のニーズに人員増で対応できない状況

## 組織的アプローチ（ページ8）

組織構造を再編し、SDLCにAIを適用する専門チームを設立：

- **Platform Engineering**
  - **Quality & Productivity Engineering**
    - **Developer Platform**
      - Programming Systems
      - Code Infra
      - IDE
      - Mobile Platform
      - Backend Platform
      - Testing Automation
      - **AI Foundations & Developer Experience** (新設専門チーム)
  - **ML Infrastructure**

## AIツール開発タイムライン（ページ9）

- **2022年10月**: 初のAIハッカソン「Hackdayz」開催
- **2022年11月**: ChatGPTの登場（「ChatGPTモーメント」）
- **2023年夏**: 生成型AIの探索ハッカソン
- **2024年冬**: 自動化とAI駆動への移行に焦点
- **2024年夏**: エージェントシステムに注力

## エージェントシステム（ページ10）

- LLMと対話するための多段階システム
- 問題空間を管理可能なタスクに分解
- LangChainとLangGraphのフレームワークを活用
- 体系的な問題解決アプローチを可能に

## 3つの主要AI適用事例（ページ11）

1. **コーディングアシスタント** (開発段階 - DEVELOP)
2. **テスト生成** (リリース段階 - RELEASE)
3. **JavaからKotlinへの移行** (保守段階 - MAINTAIN)

## 1. コーディングアシスタント詳細（ページ12-19）

### 内製コーディングアシスタント試行（ページ17）

- **目標**:
  - 受け入れ率を10%向上
  - 100トークンあたりのレイテンシーを1秒未満に
- **アーキテクチャ**:
  - IDE内のコードコンテキスト収集
  - アシスタントプロキシ
  - 微調整されたLLM（Python、TypeScript、Java、Go、Kotlin、Swiftに対応）
  - モノレポコーパス

### 内製アプローチの課題（ページ18）

- 6ヶ月の長い開発期間
- 資金不足
- 常に市場の動きを追いかける状態

### 教訓（ページ19）

- MVPは容易だが本番環境化は難しい
- レイテンシー要件はツールによって異なる
- ユーザー体験が重要
- UI表面の共食いリスク存在
- エコシステム原則を尊重すべき
- 継続的に状況を評価する必要がある

### GitHubコパイロット採用へのシフト（ページ19-24）

- GitHubコパイロットの採用と啓発活動に焦点
- `@genie`などのチャット参加者機能を通じたモノレポ知識ベースクエリの拡張
- 月1回のハンズオンワークショップ開催
- 内部エバンジェリズムコンテンツの作成：
  - チャット参加者: @workspace, @vscode
  - チャットコマンド: /doc, /explain, /fix, /tests
  - コンテキスト: #codebase, #editor, #file, #selection

### 将来展望（ページ25）

- プラットフォームネイティブ統合
- ベンダー微調整
- 拡張性向上
- オープンソースクライアント
- マルチベンダー環境対応
- エンタープライズ要件対応

## 2. テスト生成（AutoCover）詳細（ページ26-35）

### 従来のテスト戦略（ページ27）

階層構造：

- 手動テスト（トップ）
- エンドツーエンドテスト
- 機能UI
- コンポーネント統合
- 単体テスト（ボトム）
- 上に行くほど相互接続性が高く、遅く、テスト数が少ない
- 下に行くほど分離性が高く、速く、テスト数が多い

### テストの課題（ページ28）

- 良質なテスト作成の難しさ
- 多様なテストタイプの維持は煩雑
- 言語、都市、実験、プラットフォームの膨大な組み合わせ

### AI駆動テストピラミッド（ページ29）

- 単体テストのAI駆動コード生成
- UIバリデータ（タイポグラフィ、ローカリゼーション、配置などの検証）
- エンドツーエンドAIテストエージェント
- テスト品質分析
- 予測的テスト選択

### AutoCoverの要件（ページ30）

- 開発者中心のアプローチ
- 回帰テストに焦点
- カバレッジの向上

### AutoCover実装 v1（ページ32）

- 問題分解アプローチ
- 人間のヒューリスティックの模倣
- LangGraphで構築されたエージェント設計
- プロセス：
  1. ファイルとモックの準備（決定論的）
  2. テストコード生成（確率的）
  3. テストのビルドと実行（決定論的）
  4. 障害の修正（確率的）

### AutoCover強化 v2（ページ34）

- 検証ステップ：意図に対するアサーションのチェック
- リファクタリングステップ：テーブルパターンなどのベストプラクティス採用
- プロセス拡張：
  1. ファイルとモックの準備
  2. テストコード生成
  3. テストのビルドと実行
  4. テスト障害の修正
  5. テスト品質の検証
  6. テーブルテストへのリファクタリング

### 次のステップ（ページ35）

- **IDE/CLI向け改良**:
  - テーブルテストリファクタリング
  - テスト品質検証
- **ヘッドレスモード**:
  - CI上での実行
  - 既存テストコードの品質向上
- **ミューテーションテスト**:
  - ソースコードにバグ（「ミュータント」）を注入
  - テストがバグを発見できるか確認
  - AIによるミュータント生成

## 3. JavaからKotlinへの移行（ページ36-55）

### Uberでのkotlin導入歴史（ページ37）

- **2017**: 最小限のプラットフォーム使用、Googleが標準化
- **2018-2019**: 評価結果公開、限られた製品サポート
- **2020-2022**: 完全な製品サポート、有機的採用
- **2023**: 手動移行、混合ソース
- **2024**: 支援移行、JavaのBan、Kotlin財団への参加

### 現在の移行プロセス（ページ39）

- **ReKtifyプリプロセッサ**: Javaコードの前処理
- **IntelliJ J2K**: Kotlinドラフトへの変換
- **ReKtifyプロセッサ**: ポスト処理
- **Git履歴保存**: 履歴情報の保持
- **手動検証**: 人間によるレビュー
- **CI & コードレビュー**: 品質確認

### ReKtifyプロセッサの例（ページ40）

- **プリプロセッサ**: Nullable Annotations
- **ポストプロセッサ**:
  - AndroidTextUtilsRule
  - CaptorAnnotationRule
  - GuavaStringUtilsRule
  - LambdaExpressionRule
  - MockAnnotationRule
  - RemoveInitMocksRule
  - AutoDisposeRule

### 自動化されたKotlin移行（ページ42-47）

UberJ2Kと呼ばれる自動化ツールチェーン:

1. BuildKite: CI/CDパイプライン開始
2. ヘッドレスIntelliJ: IDE自動実行
3. UberJ2K: 変換ロジック
4. CI: テスト実行
5. コードレビュー: 人間による確認
6. AST（抽象構文木）ルールの作成: フィードバックループ

### LLM+AST結合アプローチ（ページ48-53）

- **ポジティブ**:
  - 既存の技術基盤活用
  - 決定論的処理
  - 人間が作成するルールより速い
- **ネガティブ**:
  - LLMのみよりは遅い
- **プロセス**:
  1. データセット、ReKtifyソース、プロンプトからLLMがルール草案を生成
  2. ドラフトがUberJ2Kを通して処理
  3. CIでテスト
  4. LLMが結果分析、人間がレビュー
  5. 最終的なReKtifyルールが作成される

### 成果（ページ54）

- LLM+ASTアプローチにより50%高速化
- 完了予想期間を3年から18ヶ月に短縮

## AIインパクト測定（ページ57-59）

### 定量的指標（ページ57）

- PR速度約10%向上
- 受け入れ率約30%向上
- 採用率約60%
- 開発者の63%が生産性の大幅増加を報告
- 技術的負債自動化の潜在的インパクト: 1000年以上の開発時間

### 課題とリスク（ページ58）

- **課題**:
  - 断片化
  - 組織的コスト
- **リスク**:
  - 副作用
  - 誤った投資
  - 見逃された投資

### 測定哲学（ページ59）

- 質的評価を優先
- 節約された開発時間に基づいて定量的影響を正規化し投資を優先順位付け

## 今後の機会と展望（ページ60-62）

### 機会マトリックス（ページ60）

- **品質と速度の軸**:
  - 迅速な成果（コーディングアシスタント）
  - 変革的な賭け（AutoCover）
  - レガシーワールド
  - 加速度的ユースケース（Java→Kotlin）

### AI-人間の協働モデル（ページ62）

- **AIの役割**:
  - 移行作業の労力削減
  - テストカバレッジの向上
  - 人間により多くの選択肢を提供
  - 問題思考のサポート
- **人間の役割**:
  - より多くの構築時間確保
  - ソフトウェアエンジニアリングの技術に集中
  - 複雑な問題の分解
  - アーキテクチャの定義
  - ベストプラクティスの設定

Uberのビジョンでは、「良いソフトウェアへの需要は無限に近い」との認識のもと、AIと人間の強みを組み合わせて最大の生産性を実現することを目指しています。
