---
title: "AI時代の3層アーキテクチャ：関数型コア・決定的シェル・非決定的エッジ"
source: "https://zenn.dev/loglass/articles/7e40d2a253bfd3"
author:
  - "knih"
  - "[[Zenn]]"
published: 2025-10-23
created: 2025-10-31
description: "AIシステムを基幹システムに組み込む際の設計パターン。LLMの非決定性をシステムの確定性と安全に統合するための3層アーキテクチャ（Non-deterministic Edge、Deterministic Shell、Functional Core）を詳細に解説。不変条件の検証、監査可能性、テスト容易性を実現する実践的なアプローチを提案。"
tags:
  - "clippings"
  - "AI"
  - "アーキテクチャ"
  - "関数型プログラミング"
  - "AIエージェント"
  - "システム設計"
---

## 概要

この記事は、株式会社ログラスのknihによる、AIシステムを基幹システムに統合する際の設計パターンに関する技術記事です。LLM（大規模言語モデル）の非決定性を、確定的なシステムと安全に統合するための3層アーキテクチャを提案しています。

## 問題提起：AIの非決定性がもたらすリスク

### 在庫管理システムの失敗シナリオ

記事は、在庫管理システムでAIが提案した操作を未検証で実行し、在庫が「-400個」という不可能な状態になるシナリオから始まります。この問題は以下の要因によって発生します：

- **AIモデルのサイレントアップデート**：予告なしにモデルが更新され、動作が変化
- **再現性の喪失**：同じ入力でも異なる出力が生成される
- **不変条件の検証不足**：在庫数が負にならないなどの基本的な制約が守られない

この例は、AIを組み込んだシステムが直面する本質的な課題を浮き彫りにしています。

## 3つの「世界」の概念

アーキテクチャを理解するための前提として、システムを3つの異なる「世界」に分類します。

### 1. 非決定的な世界（Non-deterministic World）

- **特徴**：AIや外部APIによる予測不可能な出力
- **性質**：確率的、同じ入力でも異なる結果を返す可能性
- **概念**：「可能性の空間」として捉える
- **例**：LLM、外部API、ユーザー入力

### 2. 決定的な世界（Deterministic World）

- **特徴**：データベース書き込み、イベントログ
- **要求**：同じ入力に対して常に同じ結果が必須
- **目的**：監査可能性、再現性の確保
- **例**：データベース操作、ファイル書き込み

### 3. 純粋な世界（Pure World）

- **特徴**：副作用なしの数学関数的ロジック
- **役割**：不変条件の検証、ビジネスルールの適用
- **利点**：完全な予測可能性、テストの容易性
- **例**：計算ロジック、バリデーション

## 3層アーキテクチャの詳細

### Layer 1: Non-deterministic Edge（エッジ層）

**役割**：AIや外部世界との接点

**主な機能**：
- LLMやAPIとの接続
- 複数の提案候補を生成（確定はしない）
- **証跡（Provenance）の記録**
  - モデルバージョン
  - プロンプトテンプレート
  - 温度パラメータ
  - タイムスタンプ
- **プライバシー保護**：PIIを含まない決定トレースのみ保存

**重要な原則**：
- 「可能性」を生成するが「確定」はしない
- 提案を複数生成し、選択は次の層に委ねる

### Layer 2: Deterministic Shell（シェル層）

**役割**：非決定性を確定性に変換する境界

**主な機能**：

#### Stabilize機能
- **目的**：AIの「揺らぎ」を監査可能な「事実」に固定化
- **実装**：
  - 提案をスナップショット化
  - JSON正規化（RFC 8785 JCS）によるハッシュID生成
  - BLAKE3ハッシュによる重複実行防止
  - 同一内容は必ず同じIDを生成

#### スナップショット正規化プロセス
1. JSONキーをアルファベット順にソート
2. BLAKE3ハッシュを計算
3. ハッシュそのものをIDとして使用
4. 同じ提案の重複実行を自動的に防止

#### Human-in-the-Loop検証
- ユーザーによる承認プロセス
- 提案の選択と確定
- 承認ログの記録

#### データベース操作の管理
- トランザクション管理
- イベントソーシング
- 監査ログの保存

### Layer 3: Functional Core（コア層）

**役割**：純粋なビジネスロジックの実装

**主な特徴**：
- データベース未アクセス
- API呼び出しなし
- 外部依存性ゼロ
- 完全な純粋関数

**実装内容**：
- **不変条件検証**：
  - 例：`stock >= 0`（在庫数は非負）
  - ビジネスルールの強制
- **型システムによる強制**：Effect型などを使用
- **時刻情報の扱い**：引数として受け取る（`Clock.currentTimeMillis`などは使用しない）

**利点**：
- テストが極めて容易
- バグの局所化が容易
- 並行実行が安全
- リファクタリングが容易

## 重要な境界変換

### Stabilize境界（Edge → Shell）

**目的**：AIの「揺らぎ」を監査可能な「事実」に固定化

**メカニズム**：
- 複数の提案候補からの選択
- スナップショット化による固定
- ハッシュIDによる一意性保証
- 証跡情報の記録

### Purify境界（Shell → Core）

**目的**：副作用をShellに隔離し、純粋データのみをCoreへ

**実装**：
- データベースアクセスの禁止
- 外部API呼び出しの禁止
- 型システムによる強制
- 純粋な値の受け渡しのみ

## 安全性の二重防止機構

### ベルト・アンド・サスペンダー（Belt and Suspenders）

システムの安全性を確保するために、2つのレベルで保護を実装します：

1. **アプリケーションレベル**：Functional Coreでの検証
   - `stock >= 0`などの不変条件チェック
   - エラー時は例外をthrow

2. **データベースレベル**：制約による強制
   - `CHECK (stock >= 0)`などのDB制約
   - 物理的な不正データの防止

**利点**：
- 一方が失敗しても他方が防ぐ
- デバッグが容易（どちらで引っかかったかが明確）
- 信頼性の向上

## 技術的詳細

### JSON正規化とハッシュ生成

**RFC 8785 JCS（JSON Canonicalization Scheme）**：
- JSONを一意の正規形に変換
- キーのソート
- 空白の正規化
- 数値表現の統一

**BLAKE3ハッシュ**：
- 高速で安全な暗号学的ハッシュ関数
- 同じ内容から常に同じハッシュを生成
- 衝突の可能性が極めて低い

### イベントソーシングの活用

**利点**：
- すべての状態変更を記録
- 監査証跡の自動生成
- タイムトラベルデバッグが可能
- 再現性の確保

**実装ポイント**：
- 提案の受理をイベントとして記録
- 承認プロセスもイベント化
- コマンドとイベントの分離

### 型システムによる境界強制

**Effect型システムの利用**：
- 副作用を型で表現
- Pure関数とImpure関数を明確に区別
- コンパイル時に境界違反を検出

```typescript
// 例：Effect型による強制
type Pure<A> = A
type Effect<A> = () => Promise<A>

// Coreは Pure<A> のみを扱う
// Shellは Effect<A> を扱える
```

## 実装の段階的アプローチ

### Step 1: 既存ロジックの純粋化

**アクション**：
- データベースアクセスをCoreから除去
- 外部API呼び出しをShellに移動
- 純粋な計算ロジックを抽出

**目標**：
- Functional Coreの確立
- テスト可能性の向上

### Step 2: イベントソーシングの実装

**アクション**：
- 状態変更をイベントとして記録
- イベントログの設計
- リプレイ機能の実装

**目標**：
- 監査証跡の確保
- 再現性の獲得

### Step 3: LLM呼び出しの隔離

**アクション**：
- LLM呼び出しをEdge層に移動
- Stabilize機能の実装
- 証跡情報の記録

**目標**：
- 非決定性の封じ込め
- トレーサビリティの確保

### Step 4: 型システムによる境界強制

**アクション**：
- Effect型の導入
- 境界違反の検出自動化
- 静的解析の活用

**目標**：
- コンパイル時の安全性保証
- 人為的ミスの防止

## 応用分野と適用例

### 適用が推奨される領域

1. **チャットボット**：
   - ユーザー入力の検証
   - 応答の承認プロセス
   - 会話履歴の監査

2. **コンテンツ生成システム**：
   - 生成物のレビュー
   - 品質チェック
   - バージョン管理

3. **異常検知システム**：
   - アラートの検証
   - False Positiveの削減
   - 判断根拠の記録

4. **自動意思決定システム**：
   - 高リスク判断のHuman-in-the-Loop
   - 監査要件の充足
   - 説明可能性の確保

### 適用が必須の条件

- **高信頼性が必要**：金融、医療、法務など
- **監査要件がある**：コンプライアンス、規制対応
- **再現性が重要**：デバッグ、トラブルシューティング
- **責任の所在を明確化**：承認プロセス、決裁権限

## 主要な利点

### 1. 監査可能性（Auditability）

- すべての決定に証跡が残る
- 「なぜその判断がなされたか」が追跡可能
- コンプライアンス要件の充足

### 2. テスト容易性（Testability）

- Functional Coreは純粋関数なので単体テストが容易
- モックやスタブが不要
- 高速なテスト実行

### 3. 安全性（Safety）

- 不変条件の強制
- 二重防止機構
- 型システムによる保証

### 4. 保守性（Maintainability）

- 関心の分離が明確
- 変更の影響範囲が限定的
- リファクタリングが安全

### 5. スケーラビリティ

- Functional Coreは並行実行が安全
- 状態管理が明確
- 水平スケールが容易

## 技術的課題と考慮事項

### パフォーマンス

- スナップショット化のオーバーヘッド
- ハッシュ計算のコスト
- イベントログのストレージ

**対策**：
- 非同期処理の活用
- キャッシング戦略
- ストレージの最適化

### 複雑性

- 3層アーキテクチャの学習コスト
- チーム全体の理解が必要
- 初期実装のコスト

**対策**：
- 段階的な導入
- ドキュメンテーション
- サンプルコードの提供

### レガシーシステムとの統合

- 既存システムの改修コスト
- 互換性の維持
- 移行期間の管理

**対策**：
- Strangler Figパターン
- アダプター層の実装
- 漸進的な移行

## まとめ

この3層アーキテクチャは、AIの非決定性と基幹システムの確定性を安全に統合するための実践的なフレームワークを提供します。

**核心的な洞察**：

1. **明確な境界の設定**：非決定性、決定性、純粋性を明確に分離
2. **Stabilize機能**：「可能性」を「事実」に変換する重要な境界
3. **二重防止機構**：アプリケーションとDBの両レベルでの保護
4. **監査可能性**：すべての決定に証跡を残す
5. **段階的な導入**：既存システムへの適用が可能

この設計パターンは、AI時代において高信頼性システムを構築するための重要な指針となります。特に、規制産業や高リスク領域でのAI活用において、必須のアプローチと言えるでしょう。
