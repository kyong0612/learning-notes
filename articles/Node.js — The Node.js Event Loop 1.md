---
title: "Node.js — The Node.js Event Loop"
source: "https://nodejs.org/ja/learn/asynchronous-work/event-loop-timers-and-nexttick"
author:
  - "[[@nodejs]]"
published:
created: 2025-07-13
description: |
  Node.jsがノンブロッキングI/O操作を実行するための中心的な仕組みであるイベントループについて解説します。イベントループの各フェーズ、タイマー、`setImmediate()`、`process.nextTick()` の動作と相互作用を詳述します。
tags:
  - "clippings"
  - "nodejs"
  - "event-loop"
  - "asynchronous"
  - "timers"
  - "nextTick"
---

## イベントループとは？

イベントループは、Node.jsがシングルスレッドであるにもかかわらず、可能な限りシステムカーネルに操作をオフロードすることで、ノンブロッキングI/O操作を実行できるようにするものです。

現代のカーネルはマルチスレッド対応であり、バックグラウンドで複数の操作を実行できます。これらの操作が完了すると、カーネルはNode.jsに通知し、適切なコールバックが **poll** キューに追加され、最終的に実行されます。

## イベントループの解説

Node.jsが起動すると、イベントループを初期化し、提供された入力スクリプトを処理します。このスクリプトは、非同期API呼び出し、タイマーのスケジュール、`process.nextTick()` の呼び出しなどを行うことができ、その後イベントループの処理が開始されます。

以下は、イベントループの動作順序を簡略化した図です。

```
   ┌───────────────────────────┐
┌─>│           timers          │
│  └─────────────┬─────────────┘
│  ┌─────────────┴─────────────┐
│  │     pending callbacks     │
│  └─────────────┬─────────────┘
│  ┌─────────────┴─────────────┐
│  │       idle, prepare       │
│  └─────────────┬─────────────┘      ┌───────────────┐
│  ┌─────────────┴─────────────┐      │   incoming:   │
│  │           poll            │<─────┤  connections, │
│  └─────────────┬─────────────┘      │   data, etc.  │
│  ┌─────────────┴─────────────┐      └───────────────┘
│  ┌─────────────┴─────────────┐
│  │           check           │
│  └─────────────┬─────────────┘
│  ┌─────────────┴─────────────┐
└──┤      close callbacks      │
   └───────────────────────────┘
```

> 各ボックスはイベントループの「フェーズ」と呼ばれます。

各フェーズには、実行すべきコールバックのFIFOキューがあります。イベントループが特定のフェーズに入ると、そのフェーズ固有の操作を実行し、キューが空になるか、最大コールバック数に達するまでキュー内のコールバックを実行します。その後、次のフェーズに移動します。

## フェーズの概要

* **timers**: `setTimeout()` と `setInterval()` によってスケジュールされたコールバックを実行します。
* **pending callbacks**: 次のループイテレーションに延期されたI/Oコールバックを実行します。
* **idle, prepare**: 内部的にのみ使用されます。
* **poll**: 新しいI/Oイベントを取得し、I/O関連のコールバック（クローズコールバック、タイマー、`setImmediate()`でスケジュールされたものを除くほぼすべて）を実行します。適切な場合、Node.jsはここでブロックします。
* **check**: `setImmediate()` のコールバックがここで呼び出されます。
* **close callbacks**: `socket.on('close', ...)` などの一部のクローズコールバック。

各イベントループの実行の合間に、Node.jsは非同期I/Oやタイマーを待機しているかどうかを確認し、何もなければクリーンにシャットダウンします。

## フェーズ詳細

### timers

タイマーは、コールバックが実行されるべき**正確な時間**ではなく、**その後に**実行される可能性のある**しきい値**を指定します。タイマーのコールバックは、指定された時間が経過した後、できるだけ早く実行されますが、OSのスケジューリングや他のコールバックの実行によって遅延することがあります。

### pending callbacks

TCPソケットが接続試行時に `ECONNREFUSED` を受け取った場合など、一部のシステム操作のコールバックを実行します。

### poll

**poll** フェーズには2つの主要な機能があります。

1. I/Oのためにどれだけブロックし、ポーリングすべきかを計算する。
2. **poll** キュー内のイベントを処理する。

**poll** キューが空の場合、`setImmediate()` でスクリプトがスケジュールされていれば **check** フェーズに移行し、そうでなければコールバックがキューに追加されるのを待ちます。

### check

**poll** フェーズが完了した直後にコールバックを実行できます。`setImmediate()` は、**poll** フェーズ完了後にコールバックを実行するようにスケジュールする特別なタイマーです。

### close callbacks

ソケットやハンドルが突然クローズされた場合（例：`socket.destroy()`）、`'close'` イベントはこのフェーズで発行されます。

## `setImmediate()` vs `setTimeout()`

これらは似ていますが、呼び出されるコンテキストによって動作が異なります。

* `setImmediate()`: 現在の **poll** フェーズが完了したらスクリプトを実行するように設計されています。
* `setTimeout()`: 最小しきい値（ミリ秒）が経過した後にスクリプトを実行するようにスケジュールします。

I/Oサイクル内で呼び出された場合、`setImmediate()` のコールバックは常に `setTimeout()`（たとえタイムアウトが0でも）より先に実行されます。

```javascript
// timeout_vs_immediate.js
const fs = require('node:fs');

fs.readFile(__filename, () => {
  setTimeout(() => {
    console.log('timeout');
  }, 0);
  setImmediate(() => {
    console.log('immediate');
  });
});
// 出力:
// immediate
// timeout
```

## `process.nextTick()`

### `process.nextTick()` の理解

`process.nextTick()` は厳密にはイベントループの一部ではありません。`nextTickQueue` は、イベントループの現在のフェーズに関係なく、現在の操作が完了した後に処理されます。

`process.nextTick()` で渡されたコールバックはすべて、イベントループが続行する前に解決されます。これにより、再帰的に `process.nextTick()` を呼び出すことでI/Oを「飢えさせる（starve）」危険な状況を生み出す可能性があります。これはイベントループが **poll** フェーズに到達するのを妨げるためです。

### なぜ `process.nextTick()` を使うのか？

主な理由は2つです。

1. ユーザーがエラーを処理したり、不要なリソースをクリーンアップしたり、イベントループが続行する前にリクエストを再試行できるようにするため。
2. コールスタックが巻き戻された後、イベントループが続行する前にコールバックを実行する必要がある場合。

例えば、イベントハンドラが設定される前にイベントが発行されるのを防ぐために使用されます。

```javascript
const EventEmitter = require('node:events');

class MyEmitter extends EventEmitter {
  constructor() {
    super();

    // ハンドラが割り当てられた後にイベントを発行するためにnextTickを使用
    process.nextTick(() => {
      this.emit('event');
    });
  }
}

const myEmitter = new MyEmitter();
myEmitter.on('event', () => {
  console.log('an event occurred!');
});
// 出力: an event occurred!
```

### `process.nextTick()` vs `setImmediate()`

* `process.nextTick()`: 同じフェーズで即座に発火します。
* `setImmediate()`: イベントループの次のイテレーションまたは「ティック」で発火します。

名前は紛らわしいですが、歴史的な経緯から変更される可能性は低いです。**開発者には、より推論しやすい `setImmediate()` をすべてのケースで使用することが推奨されています。**
