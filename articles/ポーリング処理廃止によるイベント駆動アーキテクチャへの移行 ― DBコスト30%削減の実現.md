---
title: "ポーリング処理廃止によるイベント駆動アーキテクチャへの移行 ― DBコスト30%削減の実現"
source: "https://developers.cyberagent.co.jp/blog/archives/60762/"
author:
  - "seitarof（藤垣）"
published: 2025-12-15
created: 2025-12-19
description: |
  ポーリング処理がデータベースに過大な負荷をかけていた予約管理システムにおいて、Cloud Pub/Sub・Firestore・Cloud Tasksを活用したイベント駆動アーキテクチャへ移行し、秒間リクエスト数50%削減・DBコスト30%削減を達成した事例の紹介。
tags:
  - event-driven-architecture
  - GCP
  - Cloud Pub/Sub
  - Firestore
  - Cloud Tasks
  - Golang
  - Kubernetes
  - コスト最適化
  - バックエンド
---

## 概要

MG-DXが運用する予約管理システムにおいて、フロントエンドからのポーリング処理がデータベースへ想定以上の負荷をかけていた。この課題を解決するため、ポーリング処理を廃止し、イベント駆動型アーキテクチャへ移行した。結果として、**秒間リクエスト数の50%削減**、**データベースコストの30%削減**を達成した。

---

## 背景と課題

### 既存アーキテクチャの問題

予約管理システムでは、薬剤師が最新の予約情報をリアルタイムで確認できることが重要な要件だった。この要件を満たすため、**フロントエンドから30秒間隔でAPIをポーリング**する実装を採用していた。

![既存アーキテクチャ](https://developers.cyberagent.co.jp/blog/wp-content/uploads/2025/12/5fbfdbbe3a3bcf00d1e1b671b8a8c0e4.png)

### 問題の規模（数値データ）

| 指標 | 数値 |
| --- | --- |
| ポーリング間隔 | 30秒 |
| 1回あたりのAPIコール数 | 9回 |
| 予約検索APIの秒間リクエスト数 | 約2,000リクエスト/秒 |

1回のポーリングで9回のAPIを呼び出していた理由：

- 予約一覧、予約詳細、ステータス情報など、画面表示に必要な情報を複数のエンドポイントから取得
- 多数の薬局クライアントが同時にポーリングを実行

### 問題の本質：「無駄な」リクエスト

ポーリング方式の根本的な問題は、**データに変更があってもなくても、定期的にリクエストが発生する**点にある。

実際の運用データを分析した結果、予約データに変更が発生する頻度はポーリング頻度と比較してかなり低く、大半のリクエストは「変更なし」という結果を返すだけだった。

```
時間軸で見たポーリングの様子

[00:00] ポーリング実行 → 変更なし（無駄）
[00:30] ポーリング実行 → 変更なし（無駄）
[01:00] ポーリング実行 → 変更あり ✓
[01:30] ポーリング実行 → 変更なし（無駄）
[02:00] ポーリング実行 → 変更なし（無駄）
...

→ 実際に意味のあるリクエストはごく一部
```

### 対処のトリガー

導入店舗数が倍増したことで、月次のインフラコストレビューでDBコストの上昇トレンドが明確になり、本格的な対策に着手。

---

## 解決策：イベント駆動アーキテクチャへの移行

### 設計思想

原点に立ち返り、「なぜポーリングしているのか？」を考えた。

**答え**：予約データに変更があったことを知りたいから

→ **変更があったときだけ通知を受け取れば良い**

この発想の転換により、従来の**プル型（ポーリング）からプッシュ型（イベント駆動）への転換**を決断。

### 新アーキテクチャの全体像

![新アーキテクチャ](https://developers.cyberagent.co.jp/blog/wp-content/uploads/2025/12/9fd73172e63ed88f0bfbacb3fff98dba.png)

**処理フロー**：

1. 予約データに変更が発生（イベント発火）
2. イベント伝播用マイクロサービスがサブスクライブ
3. マイクロサービスがFirestoreの薬局別ドキュメントを更新
4. フロントエンドがFirestoreの変更を検知
5. 必要な予約データをAPIから取得

### 各コンポーネントの役割

| コンポーネント | 役割 |
| --- | --- |
| **予約サービス** | 予約の作成・更新・キャンセルを検知し、イベントを発行 |
| **Cloud Pub/Sub** | イベントの非同期配信、システム間の疎結合を実現 |
| **イベント伝播サービス** | GKE上で稼働、Pub/Subからイベントを購読しFirestoreを更新 |
| **Firestore** | 薬局ごとのイベント状態を管理するリアルタイムDB |
| **フロントエンド** | Firestoreのリアルタイムリスナーで変更を監視 |

---

## 技術選定の根拠

### Firestoreを選んだ理由

| 選択肢 | メリット | デメリット |
| --- | --- | --- |
| WebSocket | リアルタイム性が高い | 接続管理が複雑、スケーリングが難しい |
| Server-Sent Events | 実装がシンプル | 同上 |
| **Firestore** | リアルタイム同期が標準、スケーラブル | 読み取りコストがかかる |

**採用理由**：

1. **リアルタイム同期機能が標準装備**：SDKを使うだけで接続管理なしにリアルタイム同期が実現
2. **スケーラビリティ**：フルマネージドで自動スケール
3. **薬局ごとのドキュメント分離**：各薬局が自身に関係するドキュメントのみを購読
4. **既存のGoogle Cloud環境との親和性**

### Pub/Subを介在させる理由

「予約システムからFirestoreへ直接書き込めばシンプルでは？」という意見に対して：

1. **システム間の疎結合化**：予約システムはFirestoreの存在を知らなくて良い
2. **信頼性の向上**：メッセージの永続化と再送機能
3. **監視のしやすさ**：未処理メッセージ数、処理時間などのメトリクス
4. **将来の拡張性**：分析基盤や通知サービスへの連携が容易

### Cloud Tasksを選んだ理由（スロットリング用）

| 選択肢 | 評価 |
| --- | --- |
| インメモリキャッシュ | Pod再起動で状態が失われる |
| Redis | 別途インフラ管理が必要 |
| Cloud Scheduler | 固定間隔のジョブ向けで、動的なスケジュールには不向き |
| **Cloud Tasks** | 動的なタスクスケジュールに最適、フルマネージド |

---

## 工夫ポイント①：Cloud Tasksによるスロットリング

### 課題：短時間に大量のイベントが発生するケース

予約の登録・更新・キャンセルが短時間に行われると多数のイベントが発生し、フロントエンドが変更を検知するたびにAPIを呼び出して大量のリクエストが発生してしまう。

### 解決策：一定時間内のイベントを1回の通知にまとめる

```
イベントの流れ（スロットリングなし）

[00:00.0] イベントA発生 → 即座にFirestore更新 → フロント検知 → API呼び出し
[00:00.1] イベントB発生 → 即座にFirestore更新 → フロント検知 → API呼び出し
[00:00.2] イベントC発生 → 即座にFirestore更新 → フロント検知 → API呼び出し
[00:00.3] イベントD発生 → 即座にFirestore更新 → フロント検知 → API呼び出し

→ 0.3秒で4回のAPI呼び出しが発生！

イベントの流れ（スロットリングあり：10秒間隔）

[00:00.0] イベントA発生 → 10秒後に実行するタスクを登録
[00:00.1] イベントB発生 → 既にタスクがあるのでスキップ
[00:00.2] イベントC発生 → 既にタスクがあるのでスキップ
[00:00.3] イベントD発生 → 既にタスクがあるのでスキップ
[00:10.0] タスク実行   → Firestore更新 → フロント検知 → API呼び出し

→ 1回のAPI呼び出しで済む！
```

### 実装例（Go）

```go
type counselingEventDispatcher struct {
 client *cloudtasks.Client
 cfg    config.CloudTasks
}

// Cloud Tasksに10秒後実行のタスクを登録
func (d *counselingEventDispatcher) Dispatch(ctx context.Context, event *domain.CounselingEvent, t time.Time) error {
 body := d.convert(event)
 httpRequest, err := d.client.CreateHttpRequest(taskspb.HttpMethod_POST, "/propagate", body, generateHeader(ctx, d.cfg))
 if err != nil {
  return errors.Wrap(err, "CreateHttpRequest")
 }
 task, err := d.newTask(event.PharmacyID, event.ChainID, d.dispatchTime(t), httpRequest)
 if err != nil {
  return errors.Wrap(err, "newTask")
 }
 if err = d.client.Dispatch(ctx, task); err != nil {
  if status.Code(err) == codes.AlreadyExists {
   return err
  }
  return err
 }
 return nil
}
```

### スロットリング間隔の調整

**10秒を採用した理由**：

- 通常の予約操作では、ユーザーが10秒以内に複数回更新することは稀
- 複数イベント発生時のイベント集約効果が十分に得られる
- ユーザーが体感する遅延として許容範囲内

---

## 工夫ポイント②：徹底したテスト戦略

### イベント発生ケースの網羅が重要な理由

イベント駆動アーキテクチャでは「イベントが正しく発火されること」がシステム全体の動作に直結する。発火漏れがあれば、フロントエンドに変更が伝わらず、ユーザーは古い情報を見続けることになる。

**ポーリング方式との違い**：

- ポーリング：最大30秒後には最新データが取得される
- イベント駆動：次のイベントが発生するまで更新されない

### ケースの洗い出し

| カテゴリ | 具体的なケース |
| --- | --- |
| 予約作成 | 処方箋事前送信予約、オンライン服薬指導予約、店頭受付 |
| 予約更新 | 日時変更、ステータス変更、患者情報変更、メモ追記 |
| 予約キャンセル | ユーザー操作、自動キャンセル、管理者操作 |

### 動作確認の観点

1. **イベントが正しく発火されるか**：Pub/Subにメッセージがパブリッシュされることを確認
2. **イベント内容が正しいか**：薬局ID、予約ID、イベントタイプが正確に設定されていることを確認
3. **Firestoreが更新されるか**：該当薬局のドキュメントが更新されることを確認
4. **フロントエンドが検知するか**：画面上で変更が反映されることを確認

### 結果

本番リリース後の**イベント発火漏れはゼロ**

---

## 導入結果

### 定量的効果

| 指標 | 改善前 | 改善後 | 削減率 |
| --- | --- | --- | --- |
| 予約検索APIの秒間リクエスト数 | 約2,000/秒 | 約1,000/秒 | **50%** |
| DBコスト | 100% | 70% | **30%** |
| ネットワークトラフィック | – | – | 大幅削減 |

### 定性的効果

| 効果 | 詳細 |
| --- | --- |
| **リアルタイム性の向上** | 最大30秒の遅延 → ほぼリアルタイムで画面に反映 |
| **システム安定性の向上** | ポーリングによる定期的な負荷スパイクがなくなり、DB負荷が平準化 |
| **開発者体験の改善** | 各コンポーネントの責務が明確で、デバッグや機能追加がしやすい |

---

## 運用上の考慮事項

### 成功要因

1. **段階的なリリース**：一部の薬局から段階的に展開し、影響範囲を限定
2. **監視体制の整備**：以下のメトリクスを監視
   - Pub/Subの未処理メッセージ数
   - Cloud Tasksの実行遅延
   - Firestoreの読み取り/書き込み数
   - フロントエンドからのAPI呼び出し数
3. **チーム内での知識共有**：設計の意図や運用方法をドキュメント化

### 留意すべき事項

| 注意点 | 対策 |
| --- | --- |
| **イベント欠損** | Pub/Subの再送機能を活用、デッドレターキューの設定 |
| **順序保証** | 今回のケースでは問題にならないが、順序が重要な処理では注意が必要 |
| **Firestoreコスト** | 導入前に試算し、トータルでコストメリットがあることを確認 |

---

## 今後の展望

- **スロットリング間隔の動的調整**：時間帯やイベント発生頻度に応じて動的に調整
- **他システムへの水平展開**：他のポーリング処理を行っているシステムにも展開

---

## 技術スタック

- Google Kubernetes Engine (GKE)
- Cloud Pub/Sub
- Cloud Tasks
- Firestore
- MySQL
- Go

---

## 重要な結論

「**変更が発生したときだけ処理を実行する**」というイベント駆動の原則に立ち返ることで、コスト最適化とシステム品質の向上を両立できた。ポーリング処理によるDB負荷やコスト増大に悩むシステムに対して、イベント駆動アーキテクチャへの移行は有効な選択肢となる。
