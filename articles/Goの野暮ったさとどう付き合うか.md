---
title: "Goの野暮ったさとどう付き合うか"
source: "https://www.docswell.com/s/Songmu/K6E6GM-How-to-get-along-well-with-Go"
author:
  - "[[Masayuki Matsuki]]"
published: 2025-08-24
created: 2025-08-25
description: "Goの「野暮ったさ」とどう付き合うか、文化圏の思想の違いと技術選定について解説するスライド。"
tags:
  - "clippings"
  - "Go"
  - "Golang"
  - "SoftwareDesign"
  - "Philosophy"
---

## TL;DR

本スライドは、Go言語の設計思想にある「野暮ったさ」の本質を解説し、それと上手く付き合うための考え方を提示します。Goは、完璧さよりも実装の単純さを重視する「Worse is Better」の哲学を持ち、Railsのような「Easy（手軽）」な全部入りフレームワーク文化とは対照的に、小さく単純なツールを組み合わせる「Simple（単純）」なコンポジット文化圏に属します。

この思想的背景を理解することで、インターフェース設計、エラー処理、パッケージ構成といったGo特有のプラクティスがなぜ存在するのかを深く理解できます。開発においては、Goの思想を受け入れ、標準ツールを積極的に活用し、「推測せずに計測する」ことで、言語の持つポテンシャルを最大限に引き出すことができます。

## はじめに

* **タイトル**: Goの「野暮ったさ」とどう付き合うか - 文化圏の思想の違いと技術選定
* **発表者**: Masayuki Matsuki (id: Songmu)
* **概要**: Ruby開発者が多い組織向けの社内勉強会の内容を公開版としたもの。Goという言語がどのようなもので、どう付き合っていくと良いのかを、その設計思想や文化圏の背景から解説する。

## Go概論

### Goという言語

* **名称**: 正式名称は「Go」。`golang` はドメイン名やSNSのタグ用途。
* **特徴**:
  * 「ベターC」と捉えると理解しやすい。
  * C/C++/Rustには劣るものの、十分なパフォーマンスを持つ。
  * 高速なコンパイルと省メモリなランタイムが特徴。
  * 並行処理が得意。
  * 言語の表現力は意図的に低く抑えられている。
  * 静的型付け言語の安全性と、動的型付け言語のような開発効率性の両立を目指している。

### 開発背景と主要人物

* Google社内の開発における生産性とスケーラビリティの課題を解決するために設計された。
* Rob Pike氏やKen Thompson氏といったUnix文化の重鎮が開発に携わっており、その思想が色濃く反映されている。

### 設計思想

1. **"Simplicity" (単純さ)**
    * 機能を絞り込み、シンタックスシュガーを避けることで、言語仕様を単純に保つ。
    * 「Less is exponentially more (少ないことは、指数関数的に豊かである)」という哲学。
    * 後方互換性を非常に重視するため、言語の変化は緩やか。

2. **"Readability" (可読性)**
    * 誰が書いても同じようなコードになることを目指し、可読性を最優先する。
    * `gofmt` などの強力なツールチェーンでコードスタイルを強制し、規約で統一感を保つ。
    * 暗黙的な処理よりも明示的なコードを好む。

### 文化圏の違い

* **"Worse is Better" (悪い方が良い)**
  * 完璧な正しさや一貫性（MITアプローチ）よりも、実装の単純さを優先する（New Jerseyアプローチ）という考え方。Goはこの後者に属する。
* **Simple vs Easy**
  * Goは **Simple（単純）** であり、**Easy（手軽）** ではない。
  * **フルスタック志向 (Easy)**: Railsのように「全部入り」で手軽に始められる。
  * **コンポジット志向 (Simple)**: Goのように、小さく単純なツールを組み合わせてシステムを構築する。
  * この文化圏の違いを理解することが、Goを使いこなす上で重要となる。

## Go開発に関する一般的なFAQ

* **インターフェースか具象型か**:
  * **「インターフェースを受け取り、具SONY体型を返す (Accept Interfaces, Return Concrete Types)」** が基本。
  * 利用側が必要な振る舞いをインターフェースとして定義することで、依存を疎に保つ。
  * 最初から完璧なインターフェースは設計できないため、まずは具象型から始めることが推奨される。
* **ポインタか値か**:
  * 一貫性が最も重要。既存のコードベースではポインタ (`*T`) が多く使われている。
  * 内部状態の変更や、`nil` を使って「存在しない」ことを明示したい場合にポインタが有用。
* **イミュータビリティ**:
  * 言語機能としてのイミュータビリティは提供されていない。
  * フィールドをprivateにし、コンストラクタとgetter経由でアクセスすることで実現可能だが、やり過ぎには注意が必要。
* **エラー処理**:
  * `if err != nil` を繰り返す定型文は、Goの文化として受け入れる必要がある。
  * 標準の `error` 型はスタックトレースを含まないため、必要であればサードパーティライブラリを利用する。
* **コレクション操作**:
  * `map` や `filter` といった関数は標準提供されていない。
  * ジェネリクスの導入により実装しやすくはなったが、基本的なループ処理が推奨される場面も多い。
* **パッケージ構成**:
  * 最初から複雑な構成は作らず、フラットな構成から始めて必要に応じて育てていくのが公式の推奨。

## レビュー編

* **ツールチェインの活用**:
  * `staticcheck` (linter), `goimports` (formatter), `gopls` (language server) といった公式提供のツールを積極的に導入し、コードの品質と一貫性を保つ。
* **非同期処理**:
  * `goroutine` と `channel` を用いたCSPモデルを理解する。
  * `sync.Mutex`, `sync.WaitGroup`, `errgroup` などを適切に使い分ける。
  * 並行処理においては **「同時アクセス」に常に敏感であること** が極めて重要。
* **エントリーポイント (`main`)**:
  * `main()` 関数は小さく保ち、`defer` が確実に呼ばれるように設計する。
  * `os.Exit` の直接呼び出しは避ける。
  * `signal.NotifyContext` でシグナルを適切にハンドリングする。
* **セキュリティ (SSRF)**:
  * 外部から受け取ったURLへHTTPリクエストを送る際は、SSRF (Server Side Request Forgery) 攻撃に注意し、プライベートIPへのアクセスを制限するライブラリを使用する。
* **パフォーマンス**:
  * **「推測するな、計測せよ」** が鉄則。
  * ボトルネックをプロファイリングツールで特定し、そこを重点的に改善する。

## GoとAI

* Goの言語仕様の単純さとコードの統一性は、AIによるコード生成や解析と非常に相性が良い。
* 可読性の高さは、AIが生成したコードを人間がレビューする際の負担を軽減する。

## まとめ

Goの「野暮ったさ」は、その裏にある「単純さ(Simplicity)」と「可読性(Readability)」という哲学の現れである。この思想を理解し、言語の文化に寄り添うことで、Goは大規模なシステム開発において強力な武器となる。
