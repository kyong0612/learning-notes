# Google の A2A プロトコルを理解する（および A2A と MCP の関係）

ref: <https://www.youtube.com/watch?v=WGeHYPLbXMk>

## GoogleのA2Aプロトコル解説：概要とMCPとの関連性

### 1. はじめに：GoogleによるAIエージェント関連発表 (00:00~)

Googleは、AIエージェントに関する複数の発表を行いました。

* **Agent Space:** 企業が様々なデータソースをAIエージェントに接続し、検索やAI支援による作業を可能にするハブ製品。
* **Agent Development Kit (ADK):** エージェントアプリケーションをコードで構築するためのPython SDK。LangGraphやLangChainの代替となりうる。
* **Firebase Studio:** AIを活用し、自然言語でWebアプリケーションを構築できるツール。v0やLovableの代替。
* **A2A (Agent to Agent) Protocol:** 本動画の主題。異なるAIエージェント間の連携を目的としたプロトコル。

### 2. A2Aプロトコルとは何か？ (01:24~)

* **目的:** 将来的に様々な場所に存在するであろう、特化した機能を持つ多数のAIエージェント（ドキュメント検索、要約、人間向けレポート作成など）を相互に接続し、連携させるための標準規格。
* **背景:**
  * 単一のエージェントでは対応できない複雑なタスクが存在する。
  * 特定のタスクに特化したアプリケーションが存在するように、エージェントも専門化する方が効率的（複雑性、セキュリティ、ロックイン回避）。
  * AIモデルも得意分野が異なるため、タスクごとに最適なモデル（例：コーディング特化、レポート作成特化）を利用する方が性能が良い。ファインチューニングも考慮される。
* **意義:** 異なる開発者や企業によって公開される独立したエージェント群を、標準化された通信規約によって接続し、一つの大きなシステムとして連携させることを可能にする。さらに、エージェント自身がタスクに最適な他のエージェントを選択し、自律的に利用できるようになる。

### 3. A2AプロトコルとMCP (Model Context Protocol) の関係 (05:01~)

* **Googleの見解:** A2Aは、Anthropicが提唱したMCPを**補完する**プロトコルである。両者が併存するか、どちらか一方になるか、あるいはどちらもなくなるかは現時点では不明。
* **役割分担:**
  * **A2A:** 異なるエージェント間の接続とタスク連携を担う。
  * **MCP:** 単一のエージェントに対して、ツール（機能）を標準化された方法で公開・追加することを容易にする。
* **共存シナリオ:** エージェントAが自身のツールで対応できないタスクに直面した場合、A2Aプロトコルを用いて、そのタスクに適したツールを持つエージェントBに連携を依頼する。
  * 例: 自作エージェントがGitHub関連タスクを行う際、GitHub MCP（ツール）を利用する代わりに、GitHub API操作や関連タスクにファインチューニングされたGitHubエージェント（別のエージェント）にA2Aで接続する方が効果的な場合がある。

### 4. A2Aプロトコルの仕組み (07:56~)

A2Aプロトコルは、以下の主要な構成要素から成り立ちます。

* **Discoverability (発見可能性):**
  * **Agent Card (JSON形式):** 各エージェントが自身の情報を公開するためのカード。以下の情報を含む。
    * エージェントの能力・機能
    * 認証の要否と、必要な場合の認証方法
    * 利用可能な追加の通信メカニズム（SSE、プッシュ通知など）
  * これにより、他のエージェントがそのエージェントの機能や連携方法を理解できる。
* **Authentication (認証):**
  * Agent Cardに基づき、必要であればクライアントエージェント（連携を求める側）が認証情報を取得し、相手エージェントに送信して認証を行う。
* **Task Description (タスク記述):**
  * クライアントエージェントは、相手エージェントにタスク内容を送信する。
  * メッセージは複数のパート（テキスト、ファイル、画像など）で構成される。
  * 受け取ったエージェントは、タスクを即時実行、後で実行、拒否などを判断する。
* **Communication Mechanisms (通信メカニズム):**
  * **同期処理:** 短時間で完了するタスクの場合、クライアントは応答を待機する。応答には完了したタスクの結果（生成されたテキストやファイルなど）が含まれる。
  * **非同期処理 (長時間タスク):**
    * タスクを送信後、相手エージェントは「スケジュール済み」と応答し、クライアントは一旦待機状態を終了する。
    * 進捗確認方法 (Agent Cardで指定):
      * **ポーリング:** クライアントが定期的にサーバーに問い合わせる。
      * **プッシュ通知:** サーバーがタスク完了時に、クライアントが指定したURLに通知を送信する。
      * **サーバーセントイベント (SSE):** サーバーがタスクの更新や完了をクライアントに自律的に送信する。
  * どの通信メカニズムをサポートするかは、各エージェントの開発者が決定する。プロトコルは、これらのメカニズムを記述する標準的な方法を提供する。

### 5. A2Aプロトコルの現状と将来性 (13:18~)

* **サンプル実装:** Googleは、クライアントエージェントとサーバーエージェントの構築・通信方法を示すサンプルアプリケーションをPythonとJavaScriptで公開している。
* **注意点:**
  * A2AプロトコルもMCPと同様に非常に新しく、**活発な開発下にある「ドラフト」段階**である。
  * 将来的にプロトコルやその利用方法が変更される可能性がある。
  * Googleも、これは議論の対象であり、将来的に進化・変化する可能性を認めている。
* **不確実性:** エージェント主導の未来が本当に訪れるか、そしてA2Aプロトコルがその中で標準となるかは、現時点では不明確。

### 6. 結論 (14:12~)

A2Aプロトコルは、異なるAIエージェント間の連携を標準化し、より複雑で高度なタスク実行を可能にする可能性を秘めた重要な取り組みです。しかし、まだ開発初期段階であり、今後の進化や普及の動向が注目されます。

---

**注記:** トランスクリプトのみに基づいているため、動画内の視覚的な要素（図表など）は反映されていません。
