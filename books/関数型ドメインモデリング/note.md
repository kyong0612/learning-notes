# 関数型ドメインモデリング(Domain Modeling Made Functional)

- 関数型の視点からドメインモデリングを解説した本

- [関数型ドメインモデリング(Domain Modeling Made Functional)](#関数型ドメインモデリングdomain-modeling-made-functional)
  - [訳者前書き](#訳者前書き)
  - [はじめに](#はじめに)
    - [本書の内容](#本書の内容)
    - [他の方法でドメインモデリングを行う](#他の方法でドメインモデリングを行う)
  - [第1部　ドメインの理解](#第1部ドメインの理解)
    - [第1章 ドメイン駆動設計の紹介](#第1章-ドメイン駆動設計の紹介)
      - [1.1 モデルを共有することの重要性](#11-モデルを共有することの重要性)
      - [1.2 ビジネスイベントによるドメインの理解](#12-ビジネスイベントによるドメインの理解)
      - [1.2.4 コマンドの文書化](#124-コマンドの文書化)
      - [1.3 ドメインをサブドメインに分割する](#13-ドメインをサブドメインに分割する)
      - [1.4 境界づけられたコンテキストを利用した解決手段の作成](#14-境界づけられたコンテキストを利用した解決手段の作成)
      - [1.4.1 コンテキストを正しく区別する](#141-コンテキストを正しく区別する)
      - [1.4.2 コンテキストマップの作成](#142-コンテキストマップの作成)
      - [1.6 ドメイン駆動設計の概念の要約](#16-ドメイン駆動設計の概念の要約)
      - [1.7 まとめ](#17-まとめ)
  - [第2章 ドメインの理解](#第2章-ドメインの理解)
    - [2.1 ドメインエキスパートへのインタビュー](#21-ドメインエキスパートへのインタビュー)
    - [2.2 データベース駆動設計をしたいという衝動との戦い](#22-データベース駆動設計をしたいという衝動との戦い)
    - [2.3 クラス駆動設計をしたいという衝動との戦い](#23-クラス駆動設計をしたいという衝動との戦い)
    - [2.4 ドメインの文章化](#24-ドメインの文章化)
    - [2.6 複雑さをドメイン モデリングを表現する](#26-複雑さをドメイン-モデリングを表現する)
  - [関数型アーキテクチャ](#関数型アーキテクチャ)
    - [3.1 自律的なソフトウェアコンポーネントとしての境界づけられたコンテキスト](#31-自律的なソフトウェアコンポーネントとしての境界づけられたコンテキスト)
    - [3.2 境界づけられたコンテキストのコミュニケーション](#32-境界づけられたコンテキストのコミュニケーション)
      - [3.2.1 境界づけられたコンテキスト間のデータ転送](#321-境界づけられたコンテキスト間のデータ転送)
      - [3.2.2 信頼の境界線と検証](#322-信頼の境界線と検証)
    - [3.3 境界づけられたコンテキスト間の契約](#33-境界づけられたコンテキスト間の契約)
      - [3.3.1 腐敗防止層](#331-腐敗防止層)
      - [3.3.2 関係を記述したコンテキストマップ](#332-関係を記述したコンテキストマップ)
    - [3.4 境界づけられたコンテキストでのワークフロー](#34-境界づけられたコンテキストでのワークフロー)
      - [3.4.1 ワークフローのインプットとアウトプット](#341-ワークフローのインプットとアウトプット)
      - [3.4.2 境界づけられたコンテキス内ではドメインイベントを避ける](#342-境界づけられたコンテキス内ではドメインイベントを避ける)
    - [3.5 境界づけられたコンテキストの中のコード構造](#35-境界づけられたコンテキストの中のコード構造)
      - [3.5.1 オニオンアーキテクチャ](#351-オニオンアーキテクチャ)
      - [3.5.2 I/Oを恥に追いやる](#352-ioを恥に追いやる)
    - [3.6 まとめ](#36-まとめ)
  - [第2部　ドメインのモデリング](#第2部ドメインのモデリング)
    - [第4章 型の理解](#第4章-型の理解)
      - [4.1 関数の理解](#41-関数の理解)
      - [4.1.1 型シグネチャ](#411-型シグネチャ)
    - [4.2 型と関数](#42-型と関数)
    - [4.3 型の合成](#43-型の合成)
      - [4.3.3 単純型](#433-単純型)
    - [4.5 型の合成によるドメインモデルの構築](#45-型の合成によるドメインモデルの構築)
  - [第5章 型によるドメインモデリング](#第5章-型によるドメインモデリング)
    - [5.6 アイデンティティの考察: 値オブジェクト](#56-アイデンティティの考察-値オブジェクト)
    - [5.7 アイデンティティの考察: エンティティ](#57-アイデンティティの考察-エンティティ)
      - [5.7.4　不変性とアイデンティティ](#574不変性とアイデンティティ)
    - [5.8 集約](#58-集約)
      - [5.8.2 集約の参照](#582-集約の参照)

## 訳者前書き

- 本書は関数型プログラミングの概念やテクニックを応用したドメインモデリングについて紹介する本だが、それが機能的であること、実際に役に立つことも意識されている
- ソフトウェア開発における複雑性はさまざまな側面に現れる
  - 要件・設計・コード・データ・技術・人的要因
- これらの複雑性を単純化し、適切に管理することがソフトウエア開発のかなめ
- ここではイミュータブルなデータとイミュータブルな関数を組み合わせた「型」により、ドメインの状態遷移を明示的に表現する方法が提案されている
-

## はじめに

### 本書の内容

- ドメインの理解
- ドメインのモデリング
- モデルの実装

### 他の方法でドメインモデリングを行う

- 本書では、データ構造とそれに作用する関数を定義することでドメインモデリングを行う「主流」の方法に焦点を当てているが、状況によっては他のアプローチの方が適用しやすい場合もある
  - ドメインが反構造化データを中心に展開している場合、厳格なモデルは適しておらず、キーと値のペアを格納するマップなどの柔軟な構造を使用することがよりよいアプローチになるかもしれない
  - ドメインの重点が、要素を組み合わせて他の要素を作ることにある場合、データに注目する前に、これらの構成ルールが何であるか（いわゆる「台数」）に注目することは、じばし有用

## 第1部　ドメインの理解

### 第1章 ドメイン駆動設計の紹介

- 開発者の仕事はコードを書くことではなく、ソフトウェアによって課題を解決すること

#### 1.1 モデルを共有することの重要性

- 問題を解決するためには、その問題を正しく理解することが大切
- ソフトウェア開発プロセスの中には、仕様書や要件定義を使って問題の詳細を全て把握しようとするものがある
  - しかし、この方法では、問題をもっともよく理解している人と、その解決手段を作り出す人との間に、しばし距離が生じてしまう

        ![CleanShot 2024-09-10 at 15.15.16@2x.png](./assets/CleanShot_2024-09-10_at_15.15.162x.png)

  - 伝言ゲームになり、開発者の問題理解とドメインエキスパートの問題理解のミスマッチはプロジェクトの成功に致命的な影響を与える
  - よりよい解決方法は、仲介者を排除し、ドメインエキスパートが開発プロセスに直接に関与することを奨励し、開発チームとドメインエキスパートの間にフィードバックループを導入すること

        ![CleanShot 2024-09-10 at 15.18.21@2x.png](./assets/CleanShot_2024-09-10_at_15.18.212x.png)

    - この方法も完璧ではない
      - 開発者は翻訳者として、ドメインエキスパートのメンタリングモデルをコードに翻訳するがそこで誤解してエラーを引き起こす危険性が高い
  - 3つめのアプローチ
    - ドメインエキスパート、開発チーム、その他のステークホルダー、そして(もっども重要な)ソースコード自体が、全て同じモデルを共有していいればドメインエキスパートの要件からコードへの翻訳はない
    - 共有されたメンタルモデルを直接反映するようにコードが設計される

            ![CleanShot 2024-09-10 at 15.21.40@2x.png](./assets/CleanShot_2024-09-10_at_15.21.402x.png)

    - ソフトウェアモデルとビジネスドメインを一致させることには多くのメリットがある
      - 市場投入までの時間短縮
      - ビジネス価値の向上
      - 無駄の削減
      - メンテナンスと進化の容易さ
- そうしたら共通のモデルを作成することができるか？
  - ドメイン駆動設計のコミュニティのガイドライン
    - データ構造ではなく、ビジネスイベントやワークフローに焦点を当てる
    - メインをより小さなサブドメインに分割する
    - 各サブドメインのモデルを解決空間に作成する
    - プロジェクトに関わる全ての人が共有し、コードのあらゆる場所で使用される共通言語を開発する

#### 1.2 ビジネスイベントによるドメインの理解

- ビジネスは単にデータを持っているだけではなく、何らかの方法でデータを変換する
- イベントストリーミングによってビジネスイベントを洗い出す

    ![CleanShot 2024-09-10 at 15.28.27@2x.png](./assets/CleanShot_2024-09-10_at_15.28.272x.png)

- ビジネス活動を表現する言葉
  - 「ワークフロー」・「シナリオ」・「ユースケース」・「プロセス」

    ![CleanShot 2024-09-10 at 15.29.30@2x.png](./assets/CleanShot_2024-09-10_at_15.29.302x.png)

#### 1.2.4 コマンドの文書化

- イベントを引き起こした依頼を「コマンド」と呼ぶ
  - コマンドが「〜する」だった場合、ワークフローが〜すれば、対応するドメインイベントは「~した」「~された」となる
- すべてのイベントがコマンドに関連づく必要はない
  - 月末締のようにスケジューラによってtriggerされるものもある

#### 1.3 ドメインをサブドメインに分割する

- イベントとコマンドのリストができ、さまざまなビジネスプロセスが何であるかをよく理解できたがまだ混沌としている
- ドメインという言葉はドメイン構造設計の世界では、「ドメイン」を「首尾一貫した知識の領域」と定義できる
- 1つのドメインの中にも、特徴的な領域があるかも知れない
  - このような領域をサブドメインと呼んでいる
  - ドメインは少しずつ重なっている

        ![CleanShot 2024-09-10 at 15.39.13@2x.png](./assets/CleanShot_2024-09-10_at_15.39.132x.png)

#### 1.4 境界づけられたコンテキストを利用した解決手段の作成

- 問題を理解したからと言って、解決手段(ソリューション)の構築が簡単になるわけではない

    ![CleanShot 2024-09-10 at 15.41.35@2x.png](./assets/CleanShot_2024-09-10_at_15.41.352x.png)

- 解決空間では、問題空間のドメインとサブドメインが、DDD用語で境界づけられたコンテキストと呼ばれるものにマッピングされる
- サブシステムの代わりに境界づけられたコンテキストという言葉を使うのは、解決手段を設計する際に重要なこと

#### 1.4.1 コンテキストを正しく区別する

- 理論でなく職人芸の世界だが、ガイドラインがある
  - ドメインエキスパートの声に耳を傾ける
    - 彼らが皆同じ言語を共有し同じ問題に焦点を当てている場合、彼らはおそらく同じサブドメインで作業している
  - 既存のチームや部門の境界に注目しましょう
  - 境界づけられたコンテキストの「境界づけられた」という部分を忘れてはいけない
  - 自立性を目指して設計しましょう
  - 摩擦のないビジネスワークフローを目指して設計しましょう

#### 1.4.2 コンテキストマップの作成

- これらのコンテキストを定義した後は、設計の詳細に巻き込まれることなく、コンテキスト間の相互作用(全体像)を伝える方法が必要 = コンテキストマップ

    ![CleanShot 2024-09-10 at 15.53.24@2x.png](./assets/CleanShot_2024-09-10_at_15.53.242x.png)

#### 1.6 ドメイン駆動設計の概念の要約

- ドメイン
  - 解決しようとしている問題に関する知識の領域
  - 単純に「ドメインエキスパート」が専門としているものごと
- ドメインモデル
  - あるドメインにおいて、特定の問題に関連した側面を単純化して表現したものの集合
  - ドメインモデルは解決空間の一部だが、ドメインモデルが表現するドメインは問題空間の一部
- ユビキタス言語
  - ドメインに関連する概念と語彙の集合
  - チームメンバーとソースコードの両方で共有される
- 境界づけられたコンテキスト
- コンテキストマップ
- ドメインイベント
- コマンド

#### 1.7 まとめ

- データよりもイベントやプロセスに焦点を当てる
- ドメインをより小さなサブドメインに分割する
- 各サブドメインのモデルを解決空間に作成する
- プロジェクトに関わるすべての人が共有できる「ユビキタス言語」を開発する

## 第2章 ドメインの理解

### 2.1 ドメインエキスパートへのインタビュー

- 要件と非機能要件のそれぞれをインタビューを通して理解する
- インプットとアウトプットを考える

    ![CleanShot 2024-09-11 at 22.56.01@2x.png](./assets/CleanShot_2024-09-11_at_22.56.012x.png)

### 2.2 データベース駆動設計をしたいという衝動との戦い

![CleanShot 2024-09-11 at 23.00.31@2x.png](./assets/CleanShot_2024-09-11_at_23.00.312x.png)

- ドメイン駆動設計ではドメインから設計を導き出す
  - 現実の紙ベースのシステムではデータベースは存在しない
  - DDDの用語では、これを永続性非依存と呼ぶ
  - データベース内のデータ表現を気にすることなく、ドメインを正確にモデル化することに集中させてくれる
- データベースの視点で設計していると、データベースモデルに合わせて設計を歪めてしまうことが多い

### 2.3 クラス駆動設計をしたいという衝動との戦い

![CleanShot 2024-09-11 at 23.00.41@2x.png](./assets/CleanShot_2024-09-11_at_23.00.412x.png)

- クラス駆動の設計は、データベース駆動の設計と同じ暗い危険
  - 要件収集の際には全てを受け入れる姿勢を保ち、自分の技術的な考えをドメインに押し付けないことです

### 2.4 ドメインの文章化

- UMLなどの視覚的な図を使うこともできるが、これは作業がしにくく、ドメインの微妙な部分を表すには十分な詳細さが得られないことがある
- ミニ言語を使って「注文確定」のワークフローを記述する
  - ワークフローではインプットとアウトプットを主に文書化する
  - ビジネスロジックはごく簡単な疑似コードで表現するに留める
  - データ構造では、Name AND Addressのように、ANDを使用して両方が必須なことを表し、Email OR PhoneNumberのようにORを使用してどちらか一方が必須なことを表す

        ![CleanShot 2024-09-14 at 18.18.22@2x.png](./assets/CleanShot_2024-09-14_at_18.18.222x.png)

        ![CleanShot 2024-09-14 at 18.18.29@2x.png](./assets/CleanShot_2024-09-14_at_18.18.292x.png)

        ![CleanShot 2024-09-14 at 18.18.36@2x.png](./assets/CleanShot_2024-09-14_at_18.18.362x.png)

### 2.6 複雑さをドメイン モデリングを表現する

- ワークフローを深掘りすると、ドメインモデルはより複雑になっていく
- 複雑さを理解するために時間を費やすのは、コーディングの最中になってからではなく、今の方がいい

![CleanShot 2024-09-15 at 12.12.20@2x.png](./assets/CleanShot_2024-09-15_at_12.12.202x.png)

## 関数型アーキテクチャ

- 無知の極みにいる
  - 時間をもっと有効に使えるのは、この無知を解消すること
  - イベントストリーミング・インタビュー・その他の要件収集に関するあらゆるベストプラクティスを行うこと
- サイモンブラウンの4Cアプローチ
  - アーキテクチャは4つのレベルで構成される
    - 「システムコンテキスト」
      - システム全体を表す最上位の概念
    - 「コンテナ」
      - システムコンテキストを構成する要素
      - Webサイト、Webサービス、データベースなどデプロイ可能な単位
    - 「コンポーネント」
      - 各コンテナを構成する要素
      - コードの構成において主要な構成要素
    - 「クラス」(関数型アーキテクチャでは「モジュール」)
    - 低レベルのメソッドや関数の集合
- 優れたアーキテクチャの目的の1つは、コンテナ・コンポーネント・モジュール間のさまざまな境界を定義し、新しい要件が発生した時に「変更コスト」を最小限に抑えること

### 3.1 自律的なソフトウェアコンポーネントとしての境界づけられたコンテキスト

- コンテキスト
  - 自律的なサブシステム
  - 明確に定義された境界を持つ
- システム全体が単一のモノリシックなデプロイ単位（前述したC4用語で言えば、単一コンテナ）として実装されている場合
  - 境界づけられたコンテキストは、明確に定義されたインターフェイスを持つ独立したモジュールのように、単純なものになるかもしれない
  - これは古典的なサービス指向アーキテクチャの姿
  - さらに細分化して、ワークフローを独立してデプロイ可能なコンテナの単位にもできる(マイクロサービスアーキテクチャ
- しかし、この初期段階では、特定のアプローチに拘束される必要はない。
  - 境界づけられたコンテキストが独立し、自立性を確保する限り、論理的な設計からデプロイ可能な形式への変換は重要ではない
- 当然ながら、プロジェクトの初期段階で適切な境界を設定することは困難
  - ドメインについての知識が深まるにつれて境界は変化すると想定するべき
  - モノリスはリファクタリングが容易なため、最初はモノリスとしてシステムを構築し、必要に応じて疎結合コンテナにリファクタリングするのが良い方法
  - マイクロサービスの利点が欠点を上回ると確信できない限り、マイクロサービスに飛びついて「マイクロサービス・プレミアム」（運用上の余計な負担）を支払う必要はない

### 3.2 境界づけられたコンテキストのコミュニケーション

![CleanShot 2024-09-15 at 12.49.59@2x.png](./assets/CleanShot_2024-09-15_at_12.49.592x.png)

- 完全に疎結合な設計
  - 上流コンポーネントと下流コンポーネントはお互いを意識せず、イベントを通じてのみコミュニケーションをとっている
- コンテキスト間でイベントを送信するための具体的なメカニズムは、選択するアーキテクチャによって異なる
  - キューはバッファリングされた非同期通信に適しているので、マクロサービスやエージェントを使った実装では最初の選択肢となる
  - モノリシックなシステムでは同じキューイングアプローチを内部で使うこともできるし、上流コンポーネントと下流コンポーネントを関数呼び出しで段順に直接繋げることもできる

#### 3.2.1 境界づけられたコンテキスト間のデータ転送

- 一般に、コンテキスト間のコミュニケーションに使用されるイベントは、単なる信号ではなく、下流コンポーネントがイベントを処理するために必要な全てのデータを含む
  - データが大きすぎてイベントに含められない場合は、代わりに共有データストレージの位置をしめす、何らかの参照を送信できる
- 渡されるデータオブジェクトは、境界づけられたコンテキスト内で定義されたオブジェクト(ドメインオブジェクト)と表面的には似ているかも知れないが、同じではなく、コンテキスト間のインフラストラクチャの一部としてシリアライズされ共有されるように設計されている
  - これらのオブジェクトをデータ転送オブジェクト(DTO)と呼ぶことにする

        ![CleanShot 2024-09-15 at 12.58.31@2x.png](./assets/CleanShot_2024-09-15_at_12.58.312x.png)

#### 3.2.2 信頼の境界線と検証

![CleanShot 2024-09-15 at 12.59.56@2x.png](./assets/CleanShot_2024-09-15_at_12.59.562x.png)

- 入力ゲートでは入力がドメインモデルの制約に適合しているかどうかを常に検証する
- 出力ゲートの仕事は異なる
  - 出力ゲートの仕事は、境界づけられたコンテキストの外にプライベートな情報が漏れないようにすること
    - 偶発的な結合をさけるkとお、セキュリティのためという両方の理由がある

### 3.3 境界づけられたコンテキスト間の契約

- 2つのコンテキストは、コミュニケーションを成功させるために、それらの共通フォーマットに同意する必要がある
  - 誰が契約を決定する？
    - 「共有カーネル関係」
      - 2つのコンテキストが何らかの共通のドメイン設計を共有しているため、関係するチームが協力しなければならない場合
    - 「顧客/提供者(コンシューマー駆動契約)」
      - 下流コンテキストが上流のコンテキストに提供してほしい契約を定義する
      - ボトムアップ
    - 「順応者」
      - コンシューマー駆動とは逆

#### 3.3.1 腐敗防止層

- 外部のシステムとコミュニケーションを取る際に、利用可能なインターフェイスが私たちのドメインモデルと全く一致しないことがよくある
  - ドメインモデルの腐敗を防止するために、変換が必要になる

#### 3.3.2 関係を記述したコンテキストマップ

![CleanShot 2024-09-15 at 13.17.02@2x.png](./assets/CleanShot_2024-09-15_at_13.17.022x.png)

### 3.4 境界づけられたコンテキストでのワークフロー

- 関数型アーキテクチャではワークフローを一つの関数としてマッピングする
![alt text](<assets/CleanShot 2024-09-17 at 23.23.34@2x.png>)

#### 3.4.1 ワークフローのインプットとアウトプット

- ワークフローへの入力は、常にコマンドに関連するデータであり、出力は、常に他のコンテキストに伝えるためのイベントのセット
![alt text](<assets/CleanShot 2024-09-17 at 23.26.14@2x.png>)

#### 3.4.2 境界づけられたコンテキス内ではドメインイベントを避ける

- オブジェクト指向設計では、境界づけられたコンテキスト内で内部的に発生するドメインイベントを持つことが一般的
![alt text](<assets/CleanShot 2024-09-17 at 23.30.21@2x.png>)

- これでは隠れた依存関係が発生することになるため、関数型設計では避ける。代わりにあるイベントの「リスナー」が必要な場合、ワークフローの最後に次のように追加する
![alt text](<assets/CleanShot 2024-09-17 at 23.32.01@2x.png>)

### 3.5 境界づけられたコンテキストの中のコード構造

- ワークフローは、次の図に示されているように、最上層から始まり、データベースレイヤーまで作業を進め、最上層に戻ってくる
- ![alt text](<assets/CleanShot 2024-09-17 at 23.34.40@2x.png>)
- しかしこの方法には多くの問題点がある。
  - 特に問題なのは `「一緒に変更されるコードは一緒に配置されるべき」`という重要な設計原則を破ってしまうこと
  - レイヤーは「水平方向」に組み立てられているため、ワークフローの動作方法を変更すると、全てのレイヤーに手を入れる必要がある
- よりよい方法は、「垂直方向」のスライスに切り替えること
![alt text](<assets/CleanShot 2024-09-17 at 23.37.14@2x.png>)
- しかし、これはまだ理想的ではない。そこでワークフローを横方向のパイプにして、その中でレイヤーを見てみる
![alt text](<assets/CleanShot 2024-09-17 at 23.39.03@2x.png>)
- ロジックを理解する(そしてそれをテストする)のが不必要に複雑になるような方法で、レイヤーが混ざり合っているには明らか

#### 3.5.1 オニオンアーキテクチャ

- ドメインコードを中心におき、その周りに他の側面を配置する
- その際のルールは、各レイヤーは内側のレイヤーにのみ依存し、外側のレイヤーには依存しないようにする
![alt text](<assets/CleanShot 2024-09-17 at 23.42.13@2x.png>)

#### 3.5.2 I/Oを恥に追いやる

- 関数型プログラミングの主な目的は、内側を見なくても、予測可能で理解しやすい関数をあつかうこと
- これを実現するために、私たちは可能な限り不変のデータを扱い、関数が隠れた依存関係ではなく、明示的な依存関係を持つようにする
- もっとも重要なことは、関数の副作用を避けること
- 例えばデータベースやファイルシステムを読み書きする関数は「不純」とみなされるため、コアドメインではこのような種類の関数を避けるようにする
- 代わりにあらゆるI/Oをオニオンの端に追いやること
  - 例えば、データベースへのアクセスは、ワークフローの内側ではなく、ワークフローの開始時または終了時のみに行うようにする
- 実際、I/Oをデータベースへのアクセスを端に追いやるという手法は、「永続性非依存」という概念に非常にマッチしている

### 3.6 まとめ

- `ドメインオブジェクト`
  - データ転送オブジェクトとは対照的に、あるコンテキストの境界内でのみ使用するように設計されたオブジェクト
- `データ転送オブジェクト`
  - 境界づけられたコンテキスト間でデータを転送するために使用されるオブジェクト
- `共通カーネル・顧客/供給者・順応者`
  - 境界づけられたコンテキスト間の契約を定義するための3つの異なるアプローチ
- `腐敗防止層`
  - 結合を減らしてドメインが独立して進化できるように、あるドメインから別のドメインに概念を変換するコンポーネント
- `永続性非依存`
  - ドメインモデルがドメイン自体の概念のみに基づいていて、データベースやその他の永続化メカニズムを意識するべきではないこと

## 第2部　ドメインのモデリング

### 第4章 型の理解

#### 4.1 関数の理解

![alt text](<assets/CleanShot 2024-09-18 at 18.16.32@2x.png>)

#### 4.1.1 型シグネチャ

- apple -> bananaというきほうは　`型シグネチャ(別名: 関数シグネチャ)`と呼ばれる

```f#
let add1 x = x + 1 // 型シグネチャ: int -> int
let add x y = x + y // 型シグネチャ: int -> int -> int
```

### 4.2 型と関数

- 関数型プログラミングにおける型は、オブジェクト指向プログラミングにおけるクラスとは異なり、もっとシンプル
![alt text](<CleanShot 2024-09-18 at 18.19.59@2x.png>)

- 概念的には、型の中のものは、どんな種類のものでも、現実でも仮装でもよい
![alt text](<assets/CleanShot 2024-09-18 at 18.23.01@2x.png>)

### 4.3 型の合成

- 関数プログラミグでは、関数型設計の基礎となる「合成（コンポジション）」という言葉がよく使われる
- F#では2つの方法で小さな型から新しい型が作られる
  - ANDでまとめられる
    - ANDをつかって作られた型を**直積型**と呼ぶ
    - ORをつかって作られた型を**直和型**や**タグ付き共用体**と呼ぶ
  - ORでまとめられる

#### 4.3.3 単純型

- 次のように選択肢が1つしかない選択肢を定義することがよくある

```f#
type ProductCode = ProductCode of string
```

- なぜこのような型を作るのか
　- プリミティブ(stringやintなど)を内部の値として含む型である「ラッパー」を簡単に作れるから

### 4.5 型の合成によるドメインモデルの構築

- Eコーマスサイトの支払いを追跡する例

```f#
type CheckNumber = CheckNumber of int
type CardNumber = CardNumber of string

type CardType = Visa | MasterCard  // 'OR'型

type CreaditCard = { // 'AND'型
    CardNumber: CardNumber
    CardType: CardType
}

type PaymentMethod =
    | Cash
    | Check of CheckNumber
    | CreditCard of CreaditCard

type PaymentAmount = PaymentAmount of decimal
type Currency = EUR | USD 

type Payment = {
    Amount: PaymentAmount
    Currency: Currency
    Method: PaymentMethod
}
```

- このモデルはオブジェクト指向モデルではなく、関数型モデルなので、これらの型に直接関連する動作はない
- 例えば、Payment型を使って未払いの請求書の支払い処理をして、最終的には支払い済みの請求書になる方法を示したい場合、次のような関数型を定義できる

```f#
type PaymInvoice = UnpaidInvoice -> Payment -> PaidInvoice
```

## 第5章 型によるドメインモデリング

- 理想的には、ソースコードがドキュメントとしても機能することで、ドメインエキスパートや他の非開発者がコードをレビューしたり設計を確認したりできるようになることが望ましい
- ドメインモデルを正確にコードに反映させつつ
、ドメインエキスパートや開発者ではない人が読んでも理解できるような方法を学ぶ

### 5.6 アイデンティティの考察: 値オブジェクト

- DDDの用語では、永続的なアイデンティティを持つオブジェクトをエンティティと呼び、永続的なアイデンティティを持たないオブジェクトを値オブジェクトと呼ぶ
- 多くの場合、私たちが扱うデータオブジェクトにはアイデンティティがなく、交換可能
- 構造的等値性
  - 同じ値を持つ2つのオブジェクトは等価であると見なされる

### 5.7 アイデンティティの考察: エンティティ

- エンティティにはライフサイクルがある
  - ビジネスプロセスによってある状態から別の状態に変化する 　

#### 5.7.4　不変性とアイデンティティ

- **値オブジェクト**には、不変性が必要
  - e.g) 誰かの名前の一部を変えたとする。その名前は同じ人物を指しているとは限らない
- **エンティティ**の場合、別の問題
  - 時間とともに変化することが予想され、それが変化しない識別子を持つ理由になっている

### 5.8 集約

- あるentityのコレクションを見ていくと、個別のentityには独自のIDがあり、entityのコレクションを含んでいる「トップレベル」のentityも存在するという構造が多い
- DDDの用語では、このようなentityのコレクションを集約と呼び、トップレベルのentityを集約ルートと呼ぶ

#### 5.8.2 集約の参照

- 例えば顧客に対する情報をOrderに関連づける必要があるとする。Customer<顧客>をOrder<注文>のFieldとして追加したいという誘惑にかられるかもしれないがよくない
  - 不変性の波及効果について考えてみる
    - 顧客のどこかを変更すると、注文も変更しなければならなくなる
  - よりよい設計は、顧客のレコード自体ではなく、顧客への参照を格納すること

```f#
type Order = {
  OrderId: OrderId
  CustomerId: CustomerId // 関連する顧客に対する参照
  OrderLines: OrderLine list
}
```

- CustomerとOrderは、個別で独立した集約
  - これらはそれぞれ独自の内部整合性に責任を持ち、それらの間の唯一の接続は、ルートオブジェクトの識別子を介して行われる
- これは集約が永続化の基本単位であるという、集約のもう一つの重要な側面につながる
  - データベースからオブジェクトをロードまたはセーブしたい場合は、集約全体をロードまたはセーブするべき
  - 各データベーストランザクションは、単一の集約を扱うべき
    - 複数の集約を含んだり、集約の境界を越えたり指定はいけない
- 集約は単なるエンティティの集まりではない
- 集約は、エンティティの集まりであり、それらの間の関係を制御するためのルートエンティティを持つ
- ドメインモデルにおける集約の重要な役割
  - 集約とは、トップレベルのエンティティが「ルート」として機能する、単一のユニットとして扱えるドメインオブジェクトのこと
  - 集約内のオブジェクトに対する全ての変更は、集約ルートであるトップレベルエンティティを起点にする必要があり、集約は、集約内の全てのデータが同時に正しく更新されることを保証する整合性の境界として機能する
  - 集約は、永続化、データベーストランザクション、およびデータ転送におけるアトミックな(すべて実行されるか、何も実行されないかのどちらになる)処理単位

## 第6章 ドメインの完全性と整合性

- せっかくドメインを適切にモデル化したのだから、このドメイン内のデータが有効で整合性があることを保証するために、予防策をいくつか講じるべき
  - 目標は「信頼できない外の世界とは違って、信頼できるデータだけを常に含んでいる、境界づけられたコンテキストを作ること」
- 本章では、信頼できるドメインの2つの側面、すなわち完全性と整合性のモデリングを見ていく
  - 完全性(妥当性とも言える)
    - それぞれのデータが正しいビジネスルールに従っていることを意味する
      - e.g)
        - 注文は常に、明細行が少なくとも1つ必要
        - 注文は、発送部門に送られる前に、発送先住所を検証しておかなければならない
  - 整合性
    - ドメインモデルの異なる部分が事実について一致していることを意味する
      - e.g)
        - 注文の合計金額は、個々の行の合計と同じでなければなりません。合計が異なる場合、データは矛盾している

### 6.1 単純な値の完全性

- ドメインに特化した型で表現するようにしたが、それらの値は何らかの形で制約を受ける

- e.g)
  - OrderQuantityは、符号付き整数で表現されるかもしれないが、ビジネスにおいてマイナスや40億にしたい可能性は非常に低い
  - CustomerNameは文字列で表されるかもしれないが、だからといってタブ文字や改行を含むべきではない

```f#
type WidgetCode = WidgetCode of string // 先頭が"W" + 数字4桁
type UnitQuantity = UnitQuantity of int // 1以上1000以下
type KilogramQuantity = KilogramQuantity of decimal // 0以上100.00以下 
```

- 制約を確実に強制するにはどうすれば良いか
  - 他のプログラミング言語と同じように、コンストラクタをプライベートにして別の関数を用意し、有効な値は作成するが、無効な値は拒否してエラーを返すようにする
  - 関数型プログラミングの世界では、この方法をスマートコントラクタアプローチと呼ぶことがある  

- プライベートコントラクタの欠点は、パターンマッチしてラップされたデータを抽出するためにコンストラクタを使用できなくなること

### 6.5 整合性

- 整合性は技術的な用語ではなく、ビジネス用語であり、整合性が何を意味するかは常に状況に依存する
- ただし、整合性を加味した設計には多大な労力がかかり、場合によってはコストもかかる
  - プロダクトオーナーが要求してくる整合性のレベルが現実的ではなく、そのまま受け入れるのは望ましくないことがよくある
  - 多くの場合、そのような整合性は必要なかったり、後から整合性をとっても問題なかったりする

#### 6.5.1 1つの集約内のでの整合性

- 整合性を確保するもっとも簡単な方法は、情報を保存するのではなく、生データから計算すること
  - 合計が必要になるたびに、メモリ内またはSQLクエリを使用して明細行を合計すればよい  
- 集約は原子性の単位であり、例えばこの注文をリレーショナルデータベースに保存する場合、注文ヘッダーと明細行が全て同じトランザクションで挿入または更新されるようにしなければならない

#### 6.5.2 異なるコンテキスト間での整合性

- 例
  - 注文が確定する、それに対応する請求書が作成されなければならない。注文は存在するが請求書が存在しない場合、データは矛盾している
  - 請求書の発行は、受注ドメインではなく、請求ドメインの一部。だからと言って、他のドメインに手を伸ばして、そのオブジェクトを操作する必要があるのか？
  - No. それぞれの境界づけられたコンテキストは分離して、切り離しておかなければならない
- 課金コンテキストのパブリックAPIを使って、次のようにするのはどうでしょう

```
Ask billing context to create invoice
If successfully created:
  create order in order-taking context
```

- この方法はどちらかのアップデートが失敗した場合に対処する必要があるため、見かけよりもずっと厄介
- Gregor Hohpe氏は、現実のビジネスでは一般的に、全てんおプロセスが足並み揃えて一斉に動くこと、つまり、全てのサブシステムが1つのステージを終えるのを待ってから次のステージに移ることは必要とされていないと指摘している
- その代わり**メッセージを使って非同期に調整が行われる**
- たまにうまくいかないこともあるが、まれなエラーに対処するためのコストは、全てを同期させておくためのコストよりもはるかに少ないことが多い
- 結果整合性で対応できる

#### 6.5.3 同じコンテキストの集約間の整合性

- 同じ境界づけられたコンテキス内にある集約間で整合性を確保するにはどうしたらいいでしょうか？
  - 同じトランザクションで一緒に更新するか？
  - 結果整合性を使って別々に更新するか
- 答えは場合による
  - 一般的には「1つのトランザクションにつき1つの集約のみを更新する」というガイドラインが有効
  - 複数の集約が関連している場合は、両方の集約が同じ境界付られたコンテキストにあるとしても、前述のようにメッセージと結果整合性を使用するべき
- しかし、時には、特にワークフローが1つのトランザクションであると考えられている場合、影響を受ける全てのエンティティをトランザクションに含める価値があるかもしれない
- e.g) 2つの口座間の送金で、一方の口座が増加し、もう一方の口座が減少する

```f#
Start transaction
Add X amount to accountA
Remove X amount form accountB
Commit transaction
```

- 口座がAccount<口座>集約で表されている場合、同じトランザクションで2つの異なる集約を更新することになる
- 必ずしも問題にならないが以下のようにモデリングすることもできる

```f#
type MoneyTransfer = {
  Id: MoneyTransferId
  ToAccount: AccountId
  FromAccount: AccountId
  Amount: Money
}
```

- Accountの現在の残高は、それを参照しているMoneyTransfer<送金>レコードを繰り返し処理することで計算されるようになった

### 6.6 まとめ

- ドメイン内のデータの信頼性を確保する方法を学んだ
  - 単純な型に対しては「スマートコントラクタ」を、より複雑な型に対しては「不正な状態は表現できないようにする」を組み合わせることで、型システム全体を使って多くの種類の完全性ルールを適用でき、より自己文書化されたコードになり、ユニットテストの必要性も少なくなることがわかった
- 単一の集約内で作業していない場合は、即時的な整合性ではなく結果整合性を考慮して設計する必要があると結論づけた

## 7章　パイプラインによるワークフローのモデリング

- 型を使ったドメインモデリングの一般的な手法を注文確定ワークフローに適用していく
- その過程で、あらゆるワークフローをモデル化するのに有効なテクニックをいくつか見ていく

```
workflow "Place Order" = 
  input: UnvalidatedOrder
  output (on success):
    OrderAcknowledgementSent
    AND OrderPlaced (to send to  shipping)
    AND BillableOrderPlaced(to send to billing)
  output (on error):
    ValidationError

  // ステップ1
  do ValidateOrder
  If order is invalid then:
    return with ValidationError
  
  // ステップ2
  do PriceOrder

  // ステップ3
  do AcknowledgeOrder

  // ステップ4
  create and return the events
```

![alt text](<assets/CleanShot 2024-09-26 at 21.32.01@2x.png>)

- ビジネスプロセスを表す「パイプライン」を作成し、それをさらに小さな「パイプ」の集合体として構築する
- このようなプログラミングのスタイルは「変換指向プログラミング」と呼ぶ

### 7.1 ワークフローの入力

- ワークフローの入力は、常にドメインオブジェクトでなければならない
  - 入力はすでにデータ転送オブジェクトからデシリアライズされているものとする

```
type UnvalidatedOrder = {
  OrderId: string
  CustomerInfo: UnvaludatedCustomerInfo
  ShippingAddress: UnvalidatedAddress
}
```

#### 7.1.1 入力としてのコマンド

- ワークフローはそれを開始するコマンドと関連している
- ある意味では、ワークフローの本当の入力は、実際には注文書ではなく、コマンドなのです
- このコマンドには、ワークフローがリクエストを処理するために必要なすべての内容が含まれていなければならない

```
type PlaceOrder = {
  OrderFrom: UnvalidatedOrder
  Timestamp: DateTime
  UserId: string
  // etc
}
```

#### 7.1.2 ジェネリクスによる共通構造の共有

```
type Command<'data> = {
  Data: 'data
  Timestamp: DateTime
  UserId: string
  // etc
}
```

そして、Dataスロットに入れる型を指定するだけで、ワークフロー固有のコマンドを生成できる

```
type PlaceOrder = Command<UnvalidatedOrder>
```

#### 7.1.3 複数のコマンドを1つの型にまとめる

![alt text](<assets/CleanShot 2024-09-26 at 21.48.02@2x.png>)

- 場合によっては、境界づけられたコンテキストの全てのコマンドが同じ入力チャネル(メッセージキューなど)で送信されることもあるため、それらをしリアライズできる1つのデータ構造に統一する方法が必要

```
type OrderTakingCommand =
  | Place of PlaceOrder
  | Cancel of CancelOrder
  | Change of ChangeOrder
```

![alt text](<assets/CleanShot 2024-09-26 at 21.52.20@2x.png>)

### 7.2 状態の集合による注文のモデリング

![alt text](<assets/CleanShot 2024-09-26 at 21.54.19@2x.png>)

- これらの状態をどのようにモデル化すれば良いのか?
- 素朴なアプローチとしては、状態を全て別々のフラグで表現した、単一のレコード型を作成することが考えられる

```
type Order = {
  OrderId: string
  ...
  IsValidated: bool // 検証時に設定される
  IsPriced: bool // 価格計算時に設定される
  AmountToBill: decimal option // 請求時に設定される
  // etc
}
```

- しかし、この方法には多くの問題がある
  - システムには明らかに状態があり、さまざまなフラグで示されているが、状態は暗黙的で、処理するためにはおおくの　条件付きコードが必要
  - いくつかの状態には、他の状態では必要とされないデータがあり、それらを全て1つのレコードに入れると設計が複雑になる。例えば、AmountToBillは「価格設定済み」状態でのみ必要だが、他の状態には存在しないため、フィールドを省略可能にする必要がある
  - どのフィールドがどのフラグに対応するのかが明確ではない。IsPriced<価格設定されているか>が設定されている場合はAmountToBill<請求金額>も設定されている必要があるが、このルールを強制する設計は存在せず、コメントを見ながらデータの整合性を保つように注意しなければならない
- ドメインをモデル化するためによりよい方法は、注文の各状態に対して新しい型を作成すること

```
data ValidatedOrder = 
  ValidatedCustomerInfo
  AND ValidatedShippingAddress
  AND ValidatedBillingAddress
  AND list of ValidateOrderLine
```

- そして、ValidatedOrderに対応する型定義を示す。素直に翻訳するとこのようになる。
- (OrderIdが追加されているが、これは注文のアイデンティティをワークフロー全体で維持するために必要)

```
type ValidatedOrder = {
  OrderId: string
  CustomerInfo: UnvalidatedCustomerInfo
  ShippingAddress: UnvalidatedAddress
  BillingAddress: UnvalidatedAddress
  OrderLines: UnvalidatedOrderLine list
}
```

- PricedOrder<価格計算済みの注文>の方も同じように、価格情報のフィールドを追加して作成していく。

```
type PricedOrder = {
  OrderId: string
  CustomerInfo: CustomerInfo
  ShippingAddress: Address
  BillingAddress: Address
  OrderLines: PricedOrderLine list
  AmountToBill: BillingAmount
}
```

- そこから1つ選択するトップレベルの型を作成できる

```
type Order = 
  | Unvalidated of UnvalidatedOrder
  | Validated of ValidatedOrder
  | Priced of PricedOrder
```

### 7.3 ステートマシン

- 状態を表すために、ステートマシンを使用することができる
![alt text](<assets/CleanShot 2024-09-28 at 18.01.05@2x.png>)

#### 7.3.1　なぜステートマシンを使うのか

- それぞれの状態において、受け付けられる処理を変えられる
- 全ての状態が明示的に文書化される
- 起こりうる状態をすべて考慮に入れて設計するように強く促される

#### 7.3.2 F#でシンプルなステートマシンを実装する方法

```f#
type Item = ...
type ActiveCarData = { UnpaidItems: Item list}
type PaidCartData = { PaidItems: Item list, Payment: float}

type ShoppingCart = 
  | EmptyCart // データなし
  | ActiveCart of ActiveCartData
  | PaidCart of PaidCartData

let addItem cart item = 
  match cart with
  | EmptyCart -> ActiveCart { UnpaidItems = [item] }
  | ActiveCart { UnpaidItems = existingItem } -> ActiveCart { UnpaidItems = item :: existingItem }
  | PaidCart _ -> failwith "Cannot add items to a paid cart"


let makePayment cart payment = 
  match cart with
  | EmptyCart -> failwith "Cannot pay for an empty cart"
  | ActiveCart { UnpaidItems = items } -> PaidCart { PaidItems = items, Payment = payment }
  | PaidCart _ -> failwith "Cannot pay for a paid cart"

```

### 7.10 まとめ

- ワークフローへの入力を文書化し、特にコマンドをどのようにモデル化するかを検討した
- 次に、ステートマシンを使って、文書のようにライフサイクルを持っているエンティティをどのようにモデル化するかを検討した
- また、各ステップの依存関係やエフェクトを文書化することにも力を入れた
- その過程で何百種類もの型を作ったように思う
  - それは必要だったのか?
  - これらの型を作らなかったら、検証済みの注文と価格設定された注文の違いや、装置コードと通常の文字列の違いを文書化しなければならない

## 第3部 モデルの実装

### 第8章 関数の理解

#### 8.1 関数、関数、どこにでも

- 関数型プログラミングとオブジェクト指向プログラミングとどのように違うのかを見ていく
- 関数型プログラミングとは、関数が非常に重要であるかのようにプログラミングすること

- 比較
  - オブジェクト指向のアプローチでは、これらのパーツはクラスやオブジェクトになる
  - 関数型のアプローチでは、これらのパーツは関数になる
  - オブジェクト指向のアプローチでは、インターフェースや依存関係の注入を使用する
  - 関数型アプローチでは、関数を使ってパラメータ化する
  - DRYの原則に従って、多くのコンポーネント間でコードを再利用したい
    - オブジェクト指向のアプローチでは、継承やDecoratorパターンを使う
    - 関数型アプローチでは、再利用可能なコードを全て関数にまとめ、関数合成を使ってそれらを組み合わせる

- 関数型プログラミングでは、別のパラダイムで生じる疑問(「コレクションをループするにはどうしたらよいか」「Strategyパターンを実装するにはどしたらいいか」など)にそのまま答えようとするのではなく、その擬婚が解説したかった根底の課題(「コレクションの各要素に対してアクションを実行するにはどうしたら良いか」「振る舞いをパラメータ化するにはどうしたらいいか」など)を解決しようとすると考えた方がよい

#### 8.2 「もの」としての関数

- 関数型プログラミングのパラダイムにおいて、関数はそれ自体が「もの」
  - 他の関数のへの入力として渡せる

![alt text](<assets/CleanShot 2024-09-29 at 21.04.19@2x.png>)
![alt text](<assets/CleanShot 2024-09-29 at 21.06.26@2x.png>)

```f#
let plus3 x = x + 3
let times2 x = x * 2
let square = (fun x -> x * x)
let addThree = plus3
```

- 3つ目の定義では、letキーワードを使って、無名関数(ラムダ式)にsquareという名前を割り当てている

8.2.3 出力としての関数

- 関数を返すことの重要な理由の1つは、関数に特定のパラメーターを「組み込めるということ」

```f#
let add1 x = x + 1
let add2 x = x + 2
let add3 x = x + 3
```

- 重複を解消したいと考える
  - 「加算機ジェネレータ」つまり、加算する数が組み込まれた「加算」関数を返す関数を作成する

```f#
let adderGenerator nubmerToAdd = (fun x -> x + numberToAdd)
let add1 = adderGenerator 1
let add2 = adderGenerator 2
let add3 = adderGenerator 3
```

##### 8.2.4 カリー化

- この「関数を返す」という技を使えば、どんな多パラメータの関数でも、1パラメータの関数が連なったものに変換できる
- この技術を「カリー化」と呼ぶ

```f#
// int -> int -> int
let add = (fun x y -> x + y)
// int -> (int -> int)
let add = (fun x -> (fun y -> x + y))
```

##### 8.2.5 部分適用

```f#
// sayGreeting: string -> string -> uint
let sayGreeting greeting name = printfn "%s, %s!" greeting name
```

- この関数を部分適用することで、新しい関数を作成できる

```f#
let sayHello = sayGreeting "Hello"
let sayGoodbye = sayGreeting "Goodbye"
```

#### 8.3 全域関数

- 数学の世界では、関数とはとりうる各入力に対して、それぞれ1つの出力に結びついているものを指す
- 関数型プログラミングでも同じように、とりうる入力全てについて、対応する出力が1つずつ決まるように関数を設計しようと思う
- このような関数を「全域関数」と呼ぶ

```f#
type NonZeroInt = 
  // ゼロでない整数に制約されるように定義する
  // スマートコンストラクタを追加するなど
  private NonZeroInt of int

// 制限された入力を行う
let twelveDividedBy(NonZeroInt n) = 
  match n with
  |6 -> 2
   ...
   // 0は入力にないため、ここには含まれない

// シグネチャー
val twelveDividedBy: NonZeroInt -> int
```

```f#
let twelveDividedBy n = 
  match n with  
  | 6 -> Some 2 //有効
  | 5 -> Some 2 // 有効
  | 4 -> Some 3 // 有効
  ...
  | 0 -> None // 無効

// シグネチャー
val twelveDividedBy: int -> int option
```

### 8.4 関数合成

![alt text](<assets/CleanShot 2024-09-29 at 21.35.36@2x.png>)

#### 8.4.1 関数からアプリケーション全体を構築する

![alt text](<assets/CleanShot 2024-09-29 at 21.38.21@2x.png>)
![alt text](<assets/CleanShot 2024-09-29 at 21.38.33@2x.png>)

#### 8.4.3 関数を合成する上での課題

- 関数を合成するときに、一方の関数の出力がもう一方の関数の入力と一致する場合は簡単
- しかし、出力と入力が一致しない場合はどうするか
  - このような場合、関数を合成するためには、中間関数を作成する必要がある

```f#
let add1 x = x + 1
let times2 x = x * 2
let square x = x * x

let add1Times2 = (fun x -> times2 (add1 x))
let add1Times2Square = (fun x -> square (times2 (add1 x)))
```
