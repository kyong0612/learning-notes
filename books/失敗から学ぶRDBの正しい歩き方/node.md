# 失敗から学ぶRDBの正しい歩き方

- [失敗から学ぶRDBの正しい歩き方](#失敗から学ぶrdbの正しい歩き方)
  - [アンチパターンの何が問題か？](#アンチパターンの何が問題か)
  - [アンチパターンを産まないためには](#アンチパターンを産まないためには)
    - [命名ミスは初期段階で対処](#命名ミスは初期段階で対処)
  - [アンチパターンの解説](#アンチパターンの解説)
    - [過去の事実(値)が失われる](#過去の事実値が失われる)
    - [過去の事実(過程)が失われる](#過去の事実過程が失われる)
    - [過去の事実は非常時に必要になる](#過去の事実は非常時に必要になる)
  - [アンチパターンを産まないためには?](#アンチパターンを産まないためには-1)
    - [「履歴の保存」はトレードオフ](#履歴の保存はトレードオフ)
  - [アンチパターンのポイント](#アンチパターンのポイント)
  - [やりすぎたJOIN](#やりすぎたjoin)
    - [JOINの問題点](#joinの問題点)
    - [JOINのアルゴリズムの種類](#joinのアルゴリズムの種類)
    - [アンチパターンのポイント](#アンチパターンのポイント-1)
  - [効かないINDEX](#効かないindex)
  - [フラグの闇](#フラグの闇)
    - [削除フラグとして「状態」を持たせるのは絶対だめ？](#削除フラグとして状態を持たせるのは絶対だめ)
    - [削除フラグを利用したくなるケース](#削除フラグを利用したくなるケース)
  - [ソートの依存](#ソートの依存)
    - [リレーショナルモデル](#リレーショナルモデル)
    - [ORDER BYの仕組み](#order-byの仕組み)
    - [ORDER BY句狙いのINDEX](#order-by句狙いのindex)
    - [ページャーの問題](#ページャーの問題)
    - [アントパターンを生まないためには？](#アントパターンを生まないためには)

## アンチパターンの何が問題か？

- 不適切な名前では、データベースのテーブルの関連性や意図が理解できない
- リレーショナルモデルに基づいた設計をしていないと、既存の便利なツールが利用できない
- 保存されたデータが正しいかどうかどうかが判断できない
- どのようなデータを保存し、どのようなデータを取り出せばいいかわからない

## アンチパターンを産まないためには

- 動くものを作るときに適切に作る

### 命名ミスは初期段階で対処

- 命名ミスはさっさとなおせ
- - 現場で稀に、外部キー制約はCHECK制約をかけずに「アプリケーション側でバリテーションすれば良い」という人がいるが、CHECK制約が守る対象は「アプリケーションのバグ」も含み、DDLからそのカラムの持つ意味を担保することも含む

## アンチパターンの解説

- RDBは**時間軸と直行するような設計**が大切

- e.g) 消費税の改正後に商品の返品があったとき、過去の価格を参照できなくなる

### 過去の事実(値)が失われる

![alt text](<CleanShot 2025-01-01 at 17.57.35@2x.png>)

### 過去の事実(過程)が失われる

![alt text](<CleanShot 2025-01-01 at 17.58.25@2x.png>)

### 過去の事実は非常時に必要になる

- 今ある事実のみを保存してしまうと過去の事実を失ってしまうので、例外処理を行うときやトラブル時に状況把握する場合に情報が不足してしまう

## アンチパターンを産まないためには?

- 履歴を保存する
  - ![alt text](<CleanShot 2025-01-01 at 18.00.42@2x.png>)
  - ![alt text](<CleanShot 2025-01-01 at 18.01.09@2x.png>)

### 「履歴の保存」はトレードオフ

- RDBに履歴を保存させるデメリット
  - レコードの保存量が増えるためテーブルサイズが増える
  - 集計が単純な主キー検索ができなくなるため、テーブルサイズが肥大化した際に検索速度が劣化する

## アンチパターンのポイント

- 払い戻しなど取り消し処理に対応できるか
- 配送状況などステータス変化を追えるか
- トラブル対応時、欲しい情報が失われていないか

- パフォーマンスの劣化を考えて、あえて履歴を保存しない設計をとるケースもある
  - 別手段で履歴を保存する
    - 遅延レプリケーションを使う
    - アプリケーションログとしてElasticsearchなどの分析ツールに保存する

## やりすぎたJOIN

### JOINの問題点

- JOINの回数が増えると急激に重くなるのがJOINの特徴

### JOINのアルゴリズムの種類

- Nested Loop Join(NLJ)
  - ![alt text](<CleanShot 2025-01-02 at 21.43.14@2x.png>)
- Hash Join
  - ![alt text](<CleanShot 2025-01-02 at 21.43.42@2x.png>)
- Sort Merge Join
  - ![alt text](<CleanShot 2025-01-02 at 21.43.56@2x.png>)

![alt text](<CleanShot 2025-01-02 at 21.44.50@2x.png>)

> ハッシュ表(Hash Table)
> マップの一種で、ハッシュ関数を使ってキーをハッシュ値（整数値）に変換し、それをインデックスとしてデータを管理します

### アンチパターンのポイント

- JOINは必要最低限
- INDEXを適切に活用する
- JOINするテーブルは小さくしてからJOINする
- 複雑なクエリになった場合はViewを活用する

## 効かないINDEX

- インデックスショットガン
  - アンチパターン
  - 闇雲にINDEXを設定しまくること
  - INDEXを設定すると、INSERT/UPDATE/DELETEの処理が遅くなる

  - MENTORの原則に基づいて対応することが勧められている
    - ![alt text](<CleanShot 2025-01-03 at 23.48.15@2x.png>)
- INDEXは追加するより削除する方が難しい
  - INDEXを削除することはリスキーだが、INDEXはデータテーブルを効率よく保存した実態のあるデータで、disk容量も増えるため作りすぎはよくない

## フラグの闇

### 削除フラグとして「状態」を持たせるのは絶対だめ？

- 以下の条件を満たす場合、テーブルに状態を持たせることは許容される
  - 対象のテーブルが小さく、INDEXが不要
  - そのテーブルが関連するテーブルの親になることがなく、データを取得する際に頻繁にJOINの対象になることがない
  - UNIQE制約が不要で、外部キーでデータの整合性を担保する必要がない

### 削除フラグを利用したくなるケース

- エンドユーザから見えなくしたいが、データは消したくない
- 削除したデータを検索したい
- データを消さずにログに残したい
- 操作をあやまってもなかったことにしたい
- 削除してもすぐに元に戻したい

## ソートの依存

### リレーショナルモデル

- RDBの元となっている考え方がリレーショナルモデル
  - リレーショナルモデルは集合を扱うデータモデルのこと
    - 集合には以下のような性質がある
      - 重複がない
      - 実在する要素しかない(NULLがない)
      - 要素に順序がない
  - RDBMSにはnullやソートがあるがリレーショナルモデルにない世界を扱うことは苦手

```
PostgreSQLでNULLを扱う際には、以下の点で注意が必要です。
 1. 比較演算子の使用: NULLは未知の値を表すため、=や<>などの比較演算子で直接比較しても、結果は常にNULLとなります。 これは、NULL同士の比較でも同様です。 NULLを判定する際は、IS NULLやIS NOT NULLを使用してください。 ￼
 2. 算術演算でのNULLの扱い: NULLを含む算術演算（例: 10 + NULL）の結果はNULLとなります。 計算時にNULLを0などのデフォルト値に置き換える場合、COALESCE関数を使用すると便利です。 例えば、COALESCE(value, 0)とすることで、valueがNULLの場合に0を返すことができます。 ￼
 3. ORDER BY句でのNULLの位置: ORDER BY句でソートする際、NULL値の位置はデフォルトで昇順（ASC）の場合は最後、降順（DESC）の場合は最初に配置されます。 この挙動を変更したい場合、NULLS FIRSTやNULLS LASTを明示的に指定することができます。 ￼
 4. 集計関数でのNULLの扱い: COUNT(column_name)は、NULL値を無視してカウントします。 一方、SUMやAVGなどの集計関数もNULLを無視しますが、全ての値がNULLの場合、結果はNULLとなります。 NULLを含めてカウントしたい場合は、COUNT(*)を使用してください。 ￼
 5. 文字列結合時のNULL: 文字列とNULLを結合すると、結果はNULLになります。 例えば、'abc' || NULLの結果はNULLです。 NULLを特定の文字列に置き換えて結合したい場合、COALESCE関数を使用してNULLを別の値に変換してから結合すると良いでしょう。 ￼
 6. CASE文でのNULLの扱い: CASE文内でNULLを直接比較することはできません。 NULLを条件として扱う場合、WHEN column IS NULL THEN ...のように記述する必要があります。 また、COALESCE関数を組み合わせてNULLを別の値に変換してから条件分岐を行う方法も有効です。 ￼

これらのポイントを踏ま CASE文でのNULLの扱いにくわえて、PostgreSQLでのNULLの扱いに注意してください。
```

### ORDER BYの仕組み

![alt text](<CleanShot 2025-01-05 at 23.12.18@2x.png>)

- ソートはデータを取り出してからバラバラのデータを並び替えるため高コストな処理

### ORDER BY句狙いのINDEX

- Btree INDEXはデータをソートして保存しているため、ORDER BY句でソートする際にINDEXを利用することでソート処理を高速化できる

### ページャーの問題

- Offset Paginationでは、OFFSETの数も含めてデータ取得するため、ページが進むにつれて処理が重くなる

### アントパターンを生まないためには？

- ORDER BYを早くするには
  - データを小さくする
  - INDEXを使う
- idを指定してソートを高速化する
  - cursor pagination
