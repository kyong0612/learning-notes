# 失敗から学ぶRDBの正しい歩き方

- [失敗から学ぶRDBの正しい歩き方](#失敗から学ぶrdbの正しい歩き方)
  - [アンチパターンの何が問題か？](#アンチパターンの何が問題か)
  - [アンチパターンを産まないためには](#アンチパターンを産まないためには)
    - [命名ミスは初期段階で対処](#命名ミスは初期段階で対処)
  - [アンチパターンの解説](#アンチパターンの解説)
    - [過去の事実(値)が失われる](#過去の事実値が失われる)
    - [過去の事実(過程)が失われる](#過去の事実過程が失われる)
    - [過去の事実は非常時に必要になる](#過去の事実は非常時に必要になる)
  - [アンチパターンを産まないためには?](#アンチパターンを産まないためには-1)
    - [「履歴の保存」はトレードオフ](#履歴の保存はトレードオフ)
  - [アンチパターンのポイント](#アンチパターンのポイント)
  - [やりすぎたJOIN](#やりすぎたjoin)
    - [JOINの問題点](#joinの問題点)
    - [JOINのアルゴリズムの種類](#joinのアルゴリズムの種類)
    - [アンチパターンのポイント](#アンチパターンのポイント-1)
  - [効かないINDEX](#効かないindex)
  - [フラグの闇](#フラグの闇)
    - [削除フラグとして「状態」を持たせるのは絶対だめ？](#削除フラグとして状態を持たせるのは絶対だめ)
    - [削除フラグを利用したくなるケース](#削除フラグを利用したくなるケース)
  - [ソートの依存](#ソートの依存)
    - [リレーショナルモデル](#リレーショナルモデル)
    - [ORDER BYの仕組み](#order-byの仕組み)
    - [ORDER BY句狙いのINDEX](#order-by句狙いのindex)
    - [ページャーの問題](#ページャーの問題)
    - [アントパターンを生まないためには？](#アントパターンを生まないためには)
  - [隠された状態](#隠された状態)
    - [EAV(エンティティ・アトリビュート・バリュー)](#eavエンティティアトリビュートバリュー)
    - [Polymorphic Associations(ポリモーフィック関連)](#polymorphic-associationsポリモーフィック関連)
    - [テーブル単位で状態を隠す](#テーブル単位で状態を隠す)
    - [隠された状態が生む問題](#隠された状態が生む問題)
    - [アンチパターンを生まないために](#アンチパターンを生まないために)
    - [アンチパターンのポイント](#アンチパターンのポイント-2)
  - [JSONの甘い罠](#jsonの甘い罠)
  - [転んだ後のバックアップ](#転んだ後のバックアップ)
    - [3つのバックアップ](#3つのバックアップ)
    - [バックアップの設計](#バックアップの設計)
  - [見れないエラーログ](#見れないエラーログ)
  - [知らないロック](#知らないロック)
    - [SQL標準の分離レベルとロックの挙動](#sql標準の分離レベルとロックの挙動)
      - [分離レベルの概要](#分離レベルの概要)
      - [用語解説](#用語解説)
      - [各分離レベルの一般的な挙動](#各分離レベルの一般的な挙動)
        - [1. READ UNCOMMITTED](#1-read-uncommitted)
        - [2. READ COMMITTED](#2-read-committed)
        - [1. REPEATABLE READ](#1-repeatable-read)
        - [4. SERIALIZABLE](#4-serializable)
      - [注意点](#注意点)
  - [ロックの功罪](#ロックの功罪)
  - [簡単すぎる不整合](#簡単すぎる不整合)
    - [非正規化の誘惑](#非正規化の誘惑)
    - [データの不整合の速度の等価交換](#データの不整合の速度の等価交換)
    - [非正規化の代替案](#非正規化の代替案)

## アンチパターンの何が問題か？

- 不適切な名前では、データベースのテーブルの関連性や意図が理解できない
- リレーショナルモデルに基づいた設計をしていないと、既存の便利なツールが利用できない
- 保存されたデータが正しいかどうかどうかが判断できない
- どのようなデータを保存し、どのようなデータを取り出せばいいかわからない

## アンチパターンを産まないためには

- 動くものを作るときに適切に作る

### 命名ミスは初期段階で対処

- 命名ミスはさっさとなおせ
- - 現場で稀に、外部キー制約はCHECK制約をかけずに「アプリケーション側でバリテーションすれば良い」という人がいるが、CHECK制約が守る対象は「アプリケーションのバグ」も含み、DDLからそのカラムの持つ意味を担保することも含む

## アンチパターンの解説

- RDBは**時間軸と直行するような設計**が大切

- e.g) 消費税の改正後に商品の返品があったとき、過去の価格を参照できなくなる

### 過去の事実(値)が失われる

![alt text](<CleanShot 2025-01-01 at 17.57.35@2x.png>)

### 過去の事実(過程)が失われる

![alt text](<CleanShot 2025-01-01 at 17.58.25@2x.png>)

### 過去の事実は非常時に必要になる

- 今ある事実のみを保存してしまうと過去の事実を失ってしまうので、例外処理を行うときやトラブル時に状況把握する場合に情報が不足してしまう

## アンチパターンを産まないためには?

- 履歴を保存する
  - ![alt text](<CleanShot 2025-01-01 at 18.00.42@2x.png>)
  - ![alt text](<CleanShot 2025-01-01 at 18.01.09@2x.png>)

### 「履歴の保存」はトレードオフ

- RDBに履歴を保存させるデメリット
  - レコードの保存量が増えるためテーブルサイズが増える
  - 集計が単純な主キー検索ができなくなるため、テーブルサイズが肥大化した際に検索速度が劣化する

## アンチパターンのポイント

- 払い戻しなど取り消し処理に対応できるか
- 配送状況などステータス変化を追えるか
- トラブル対応時、欲しい情報が失われていないか

- パフォーマンスの劣化を考えて、あえて履歴を保存しない設計をとるケースもある
  - 別手段で履歴を保存する
    - 遅延レプリケーションを使う
    - アプリケーションログとしてElasticsearchなどの分析ツールに保存する

## やりすぎたJOIN

### JOINの問題点

- JOINの回数が増えると急激に重くなるのがJOINの特徴

### JOINのアルゴリズムの種類

- Nested Loop Join(NLJ)
  - ![alt text](<CleanShot 2025-01-02 at 21.43.14@2x.png>)
- Hash Join
  - ![alt text](<CleanShot 2025-01-02 at 21.43.42@2x.png>)
- Sort Merge Join
  - ![alt text](<CleanShot 2025-01-02 at 21.43.56@2x.png>)

![alt text](<CleanShot 2025-01-02 at 21.44.50@2x.png>)

> ハッシュ表(Hash Table)
> マップの一種で、ハッシュ関数を使ってキーをハッシュ値（整数値）に変換し、それをインデックスとしてデータを管理します

### アンチパターンのポイント

- JOINは必要最低限
- INDEXを適切に活用する
- JOINするテーブルは小さくしてからJOINする
- 複雑なクエリになった場合はViewを活用する

## 効かないINDEX

- インデックスショットガン
  - アンチパターン
  - 闇雲にINDEXを設定しまくること
  - INDEXを設定すると、INSERT/UPDATE/DELETEの処理が遅くなる

  - MENTORの原則に基づいて対応することが勧められている
    - ![alt text](<CleanShot 2025-01-03 at 23.48.15@2x.png>)
- INDEXは追加するより削除する方が難しい
  - INDEXを削除することはリスキーだが、INDEXはデータテーブルを効率よく保存した実態のあるデータで、disk容量も増えるため作りすぎはよくない

## フラグの闇

### 削除フラグとして「状態」を持たせるのは絶対だめ？

- 以下の条件を満たす場合、テーブルに状態を持たせることは許容される
  - 対象のテーブルが小さく、INDEXが不要
  - そのテーブルが関連するテーブルの親になることがなく、データを取得する際に頻繁にJOINの対象になることがない
  - UNIQE制約が不要で、外部キーでデータの整合性を担保する必要がない

### 削除フラグを利用したくなるケース

- エンドユーザから見えなくしたいが、データは消したくない
- 削除したデータを検索したい
- データを消さずにログに残したい
- 操作をあやまってもなかったことにしたい
- 削除してもすぐに元に戻したい

## ソートの依存

### リレーショナルモデル

- RDBの元となっている考え方がリレーショナルモデル
  - リレーショナルモデルは集合を扱うデータモデルのこと
    - 集合には以下のような性質がある
      - 重複がない
      - 実在する要素しかない(NULLがない)
      - 要素に順序がない
  - RDBMSにはnullやソートがあるがリレーショナルモデルにない世界を扱うことは苦手

```
PostgreSQLでNULLを扱う際には、以下の点で注意が必要です。
 1. 比較演算子の使用: NULLは未知の値を表すため、=や<>などの比較演算子で直接比較しても、結果は常にNULLとなります。 これは、NULL同士の比較でも同様です。 NULLを判定する際は、IS NULLやIS NOT NULLを使用してください。 ￼
 2. 算術演算でのNULLの扱い: NULLを含む算術演算（例: 10 + NULL）の結果はNULLとなります。 計算時にNULLを0などのデフォルト値に置き換える場合、COALESCE関数を使用すると便利です。 例えば、COALESCE(value, 0)とすることで、valueがNULLの場合に0を返すことができます。 ￼
 3. ORDER BY句でのNULLの位置: ORDER BY句でソートする際、NULL値の位置はデフォルトで昇順（ASC）の場合は最後、降順（DESC）の場合は最初に配置されます。 この挙動を変更したい場合、NULLS FIRSTやNULLS LASTを明示的に指定することができます。 ￼
 4. 集計関数でのNULLの扱い: COUNT(column_name)は、NULL値を無視してカウントします。 一方、SUMやAVGなどの集計関数もNULLを無視しますが、全ての値がNULLの場合、結果はNULLとなります。 NULLを含めてカウントしたい場合は、COUNT(*)を使用してください。 ￼
 5. 文字列結合時のNULL: 文字列とNULLを結合すると、結果はNULLになります。 例えば、'abc' || NULLの結果はNULLです。 NULLを特定の文字列に置き換えて結合したい場合、COALESCE関数を使用してNULLを別の値に変換してから結合すると良いでしょう。 ￼
 6. CASE文でのNULLの扱い: CASE文内でNULLを直接比較することはできません。 NULLを条件として扱う場合、WHEN column IS NULL THEN ...のように記述する必要があります。 また、COALESCE関数を組み合わせてNULLを別の値に変換してから条件分岐を行う方法も有効です。 ￼

これらのポイントを踏ま CASE文でのNULLの扱いにくわえて、PostgreSQLでのNULLの扱いに注意してください。
```

### ORDER BYの仕組み

![alt text](<CleanShot 2025-01-05 at 23.12.18@2x.png>)

- ソートはデータを取り出してからバラバラのデータを並び替えるため高コストな処理

### ORDER BY句狙いのINDEX

- Btree INDEXはデータをソートして保存しているため、ORDER BY句でソートする際にINDEXを利用することでソート処理を高速化できる

### ページャーの問題

- Offset Paginationでは、OFFSETの数も含めてデータ取得するため、ページが進むにつれて処理が重くなる

### アントパターンを生まないためには？

- ORDER BYを早くするには
  - データを小さくする
  - INDEXを使う
- idを指定してソートを高速化する
  - cursor pagination

## 隠された状態

### EAV(エンティティ・アトリビュート・バリュー)

![alt text](<CleanShot 2025-01-07 at 09.37.20@2x.png>)

- 以下のようなデータの状態は実際に取り出すまでわからない
  - その属性名に対する値があるのかないのか
  - その属性名があるのかないのか
  - 属性名と値の組み合わせは正しいのか
  - 属性名の一覧
- 以下の設計上の問題
  - 必須属性が設定できない
  - データ型が指定できない
  - 正規化されていないため外部キー制約(参照整合性制約)が強制できない
  - 属性名を補う必要がある
    - 表記揺れの可能性が高まる
- EAVの代替案になり得るJSONデータ型

### Polymorphic Associations(ポリモーフィック関連)

- 子テーブルが複数の親テーブルを持つような設計
![alt text](<CleanShot 2025-01-07 at 09.40.55@2x.png>)

- 子テーブルの属性によって紐づく親テーブルが変わる
  - 外部キー制約が使えない
  - データを取り出すまでどの親テーブルに紐づくかわからない
    - 非効率なクエリが実行される

### テーブル単位で状態を隠す

- EAV
  - 1つのカラムに状態を詰め込んでレコード単位で状態を隠す手法
  - Polymorphic Associationsはテーブル単位で状態を隠す手法

### 隠された状態が生む問題

- コードやデータから見えない状態の辛さ
  - パフォーマンスの問題もあるが、何より運用コストが跳ね上がる
  - バグが起きて不正なデータが生まれた場合に整理が難しい
- 失われた制約
  - 不正なデータが投入されることを防げない
  - 無防備になるデータベース
- ドキュメントに正しい仕様が残されていない場合、どの値が何を表すのかが正しく読み取れなくなる

### アンチパターンを生まないために

- RDBには事実のみを保存するのが基本
  - そのデータの属性や責務が複数ある場合、その保存先を分けていくのが妥当
![alt text](<CleanShot 2025-01-07 at 09.49.16@2x.png>)
![alt text](<CleanShot 2025-01-07 at 09.50.45@2x.png>)
![alt text](<CleanShot 2025-01-07 at 09.51.04@2x.png>)

### アンチパターンのポイント

- 交差テーブルは作ることが面倒なため忌避する人もいるがそれは逆効果
- アンチパターンを防ぐコツ
  - データに複数の意味を持たせない
  - 一つのデータの責務を小さくする
  - 常に状態が見えるようにするために事実のみを保存する
- トリガーも同様に隠された状態を生むことがある

## JSONの甘い罠

- JSON型はデータに柔軟性を与えるが、整合性を犠牲にする
  - トレードオフ

## 転んだ後のバックアップ

### 3つのバックアップ

- 論理バックアップ
  - SQLやCSVとして、DBそのものを再構築できるようにバックアップをとること
  - PostgreSQLの場合はpg_dumpというコマンドを使うことができる
  - デメリット
    - ファイルサイズが大きくなりやすいこと
    - バックアップとリストアともに時間が長くなりやすいこと
- 物理バックアップ
  - データベースの物理ファイルを丸ごとバックアップする手法
  - メリット
    - 最小限のサイズで取得でき、バックアップとリストアの時間が短いこと
    - リストアの復旧方法もシンプルで運用しやすい
      - ただし、シンプルにデータファイルをコピーする場合は、データベースの停止が必要になる
      - 専用ツールの使用を推奨
  - デメリット
    - 論理バックアップのような移植性の高さはなく、バージョン違いでは互換性がないことが多い
- PITR
  - 特定の日時の状態にデータをリストアできる手法
  - PITRを行うためには、バックアップファイルと更新情報の入ったログが必要
    - 更新情報の入ったログ
      - MySQLの場合はバイナリログ
      - PostgreSQLの場合はアーカイブログ

### バックアップの設計

- 次の3点について考える必要がある
  - RPO(Recovery Point Objective)
    - 障害が発生した時に、いつの時点のデータを復旧するか
  - RTO(Recovery Time Objective)
    - 障害が発生した時に、どれだけの時間で復旧するか
  - RLO(Recovery Level Objective)
    - 障害が発生した時に、どれだけのデータを復旧するか
      - 障害が発生した場合に、実際にどこまで復旧させるか

![alt text](<CleanShot 2025-01-14 at 23.08.23@2x.png>)

## 見れないエラーログ

![alt text](<CleanShot 2025-01-14 at 23.09.17@2x.png>)

## 知らないロック

- レベル
  - 排他ロック(eXcluded lock)
    - 他のトランザクションが読み取りも書き込みもできない状態
  - 共有ロック(Shared lock)
    - 他のトランザクションが読み取りはできるが書き込みはできない状態
- 粒度
  - 表ロック
    - テーブル全体にロックをかける
  - 行ロック
    - テーブルの行にロックをかける

![alt text](<CleanShot 2025-01-14 at 23.12.26@2x.png>)

- タイミング
  - 明示的ロック
    - トランザクション内で明示的にロックをかける
    - SELECT ... FOR UPDATE
    - SELECT ... LOCK IN SHARE MODE
    - LOCK TABLE
    - LOCK ROW
  - 暗黙的ロック
    - トランザクション内で明示的にロックをかけていないが、データベースが自動的にロックをかける
    - トランザクションが終了するまでロックが解除されない

### SQL標準の分離レベルとロックの挙動

#### 分離レベルの概要

| 分離レベル         | Dirty Read | Non-Repeatable Read | Phantom Read | 主な特徴                                 |
|:------------------|:----------:|:-------------------:|:------------:|------------------------------------------|
| **READ UNCOMMITTED** | あり        | あり                 | あり          | もっとも緩い分離レベル。実装によっては READ COMMITTED と同等になることもある。   |
| **READ COMMITTED**   | なし        | あり                 | あり          | 多くの製品のデフォルト。コミット済みのデータのみを読み、ダーティリードを防ぐ。     |
| **REPEATABLE READ**  | なし        | なし                 | 実装依存       | 同一トランザクション内で同じクエリ結果が変わらなくなるが、ファントムリードが防げるかは実装依存。 |
| **SERIALIZABLE**     | なし        | なし                 | なし          | 直列実行（シリアライズ）と同等の結果を保証。競合が起こりやすく、エラーが発生する場合あり。 |

#### 用語解説

- **Dirty Read（ダーティリード）**  
  他のトランザクションがまだコミットしていないデータを読み込む現象。  
- **Non-Repeatable Read（ノンリピートリード）**  
  同一トランザクション内で同じ行を再度読み込んだとき、他のトランザクションがコミットした更新が反映され、読み出す結果が変わってしまう現象。  
- **Phantom Read（ファントムリード）**  
  同一トランザクション内で同じ検索条件のクエリを実行しても、INSERT/DELETE によって行数や結果が変わってしまう現象。  

#### 各分離レベルの一般的な挙動

##### 1. READ UNCOMMITTED

- **特徴**  
  - ダーティリードが許されるため、他トランザクションの未コミットデータを読み取る可能性がある。
  - Non-Repeatable Read や Phantom Read も防げない。
  - 実際には多くのデータベースで **READ COMMITTED 相当**にマップされる場合が多い。
- **ロック・MVCC 的観点**  
  - データベースによっては未コミットデータをそのまま読み取る可能性がある。
  - 基本的に読み取りのためのロックは取得しない。

##### 2. READ COMMITTED

- **特徴**  
  - ダーティリードは起こらない（コミット済みのデータのみ読み取る）。
  - ただし、Non-Repeatable Read や Phantom Read は防げない。
  - 多くの RDB でデフォルト設定。
- **ロック・MVCC 的観点**  
  - SELECT 実行時点でのコミット済みデータを取得する。
  - 書き込みロックがある最新行に直接アクセスが必要な場合はブロックされることがあるが、MVCC により“過去バージョン”を読む場合はブロックされないケースが多い。

##### 1. REPEATABLE READ

- **特徴**  
  - ダーティリードや Non-Repeatable Read を防ぐ（同一トランザクション内での再読み取り結果が変わりづらい）。
  - SQL標準では Phantom Read を防ぎきれないとされるが、MySQL(InnoDB) など一部実装では Phantom Read も防ぐことがある。
- **ロック・MVCC 的観点**  
  - トランザクション（またはクエリ）開始時点のスナップショットを参照し続ける。
  - 他トランザクションがコミットしても、その変更はトランザクション内で見えないことが多い。

##### 4. SERIALIZABLE

- **特徴**  
  - もっとも厳格な分離レベル。並行実行したトランザクションが**直列実行したのと同等**の結果を保証する。
  - Phantom Read を含むあらゆる読み取りの不整合を防止する。
  - 競合が起こるとシリアライズ失敗（Serialization Failure）としてエラーやロールバックを起こす場合がある。
- **ロック・MVCC 的観点**  
  - データベースによっては読み取り時にもロックを取得したり、コミット時に検証を行い衝突を検知したりする仕組みを持つ。
  - 高い整合性を保つ代わりにスループットが下がりやすい。

---

#### 注意点

1. **分離レベルは「ロックの取り方」ではなく、「どの種類のリード不整合をどこまで許容するか」を定義したもの**です。  
   - ロック戦略そのものはデータベース製品やエンジン実装（行ロック、テーブルロック、MVCC など）によって異なります。

2. **READ COMMITTED だからといって「ロック中の行が読めない」わけではない**  
   - 多くのデータベースが MVCC を実装しているため、ロック中の最新バージョンを読む必要がなければ、ロックを待たずに“過去バージョン”を読むことが可能な場合があります。

3. **REPEATABLE READ や SERIALIZABLE でも「他のトランザクションの変更がまったく読めない」というわけではない**  
   - トランザクション開始時点（またはクエリ実行開始時点）のスナップショットをもとにしており、結果的に最新の変更が見えない（または見えにくい）だけのことです。

4. **READ UNCOMMITTED は実運用で用いられることが少ない**  
   - 通常、READ COMMITTED で十分なケースが多いです。  
   - 不整合が大きくなるため、積極的に選択されることはあまりありません。

5. **トランザクションとロックに関する挙動は製品依存です**  
   - Oracle、PostgreSQL、MySQL(InnoDB)、SQL Server、各種クラウドデータベースなどで実装に差異があります。  
   - 必要に応じて製品の公式ドキュメントを参照してください。

## ロックの功罪

- 並列処理でデータを守るには?
  - トラザクション同士のデータの一貫性を保つには、トランザクション分離レベルにserializableを設定して直列処理で順番に処理するしかないが、パフォーマンス上の課題として並列処理が求められる
  - 並列度を維持しながらデータの一貫性を担保するにはどうすればよいか？
    - Lockを活用する

![alt text](<CleanShot 2025-01-18 at 18.10.40@2x.png>)

## 簡単すぎる不整合

- テーブルを非正規化することでDBは簡単に壊れる
  - テーブルを非正規化した場合、アプリケーションで整合性を担保しなければならない

### 非正規化の誘惑

- 非正規化したい場面
  - テーブルを作って正規化をするのが面倒なとき
  - 外部キー制約によってデットロックなどが発生しているとき
    - 外部キー制約によってロックが発生するケース
      - 子テーブルの INSERT/UPDATE
        - 親テーブルのキー（主キーなど）が実在するか検証すると同時に、親テーブル該当行に対して「共有ロック（RowShareLock）」を取得する
      - 親テーブルの UPDATE/DELETE
        - 親テーブルの行を変更・削除しようとする場合も、関連する子テーブルの外部キーを参照して制約チェックを行うため、子テーブルや他のロック状況と競合が起こり得る
    - デッドロックが起きる典型例
      - 1. トランザクションA:
        - 子テーブルCの行を更新・挿入し、親テーブルPの「行1」に対して共有ロックを取得したまま。
        - さらに別の操作で、親テーブルPの「行2」のロックを取得しようとする。
      - 2. トランザクションB:
        - 子テーブルCの行を更新・挿入し、親テーブルPの「行2」に対して共有ロックを取得したまま。
        - さらに別の操作で、親テーブルPの「行1」のロックを取得しようとする。
    - `親テーブルに対して正しく共有ロックをとっていれば防げる問題`
  - 正規化によってJOINのコストが高くなり、パフォーマンスに問題が出ているとき
    - 非正規化が有効化どうかはケースバイケース
    - 正規化した方がデータの重複はなくなり、メモリに乗りやすくなるためパフォーマンス的には有利

### データの不整合の速度の等価交換

- 非正規化によってパフォーマンスが悪化するケース
  - 1つめのN:Nのリレーションを表現するために交差テーブルを用意しているパターン
  - JOINが多段になっているパターン
- 解決策としては非正規化ではなく、多くの場合では「キャッシュの活用」
  - materialized view

### 非正規化の代替案

- その1: CHECK制約
- その2: ENUM型
- CHECK制約・ENUM型に共通することは、制約条件が暗黙的になりやすく、更新にはALTERが必要になること
