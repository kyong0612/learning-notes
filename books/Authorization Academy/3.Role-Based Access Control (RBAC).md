- [Role-Based Access Control (RBAC)](#role-based-access-control-rbac)
  - [1. What Part of the System is Role-Based Authorization?](#1-what-part-of-the-system-is-role-based-authorization)
    - [Enforcement](#enforcement)
  - [Why Use Authorization Models?](#why-use-authorization-models)
  - [Role-Based Access Control (RBAC) Models](#role-based-access-control-rbac-models)
  - [Organizational Roles](#organizational-roles)
    - [What the authorization model is](#what-the-authorization-model-is)
    - [How to implement the model](#how-to-implement-the-model)
    - [When to use this model](#when-to-use-this-model)
  - [Cross-Organization Roles](#cross-organization-roles)
    - [What the authorization model is](#what-the-authorization-model-is-1)
    - [How to implement the model](#how-to-implement-the-model-1)
    - [When to use this model](#when-to-use-this-model-1)
  - [Resource-Specific Roles](#resource-specific-roles)
    - [What the authorization model is](#what-the-authorization-model-is-2)
    - [How to implement the model](#how-to-implement-the-model-2)
    - [When to use this model](#when-to-use-this-model-2)
  - [Custom Roles](#custom-roles)
    - [What the authorization model is](#what-the-authorization-model-is-3)
    - [How to implement the model](#how-to-implement-the-model-3)
    - [When to use this model](#when-to-use-this-model-3)
  - [3. Quick Reference To Choosing An Authorization Model](#3-quick-reference-to-choosing-an-authorization-model)

## Role-Based Access Control (RBAC)

ロールベースの認可、またはロールベースのアクセス制御とは、権限を「ユーザ」や「管理者」のようなロールにグループ化し、それらのロールをユーザに割り当てることを意味します。 これは、権限コードを構造化する一般的で効果的な方法です。この構造により、開発者にとってもユーザにとっても、誰がどのリソースにアクセスできるかを理解しやすくなります。

### 1. What Part of the System is Role-Based Authorization?

前の章では、典型的なウェブ・アプリケーションであるGitClubを紹介し、そのアプリに認可を追加する手順を説明しました。認可は、「決定(decision)」と「実施(enforcement)」の二つの部分からなることを説明しました。

決定(decision)とは、「このユーザがこのリソースに対してこのアクションを実行することを許可されているか 」ということです。多くの場合、それは 「イエス 」か 「ノー 」である。

実施(enforcement)とは、一旦決定したらどのようなアクションを取るかということです。もし 「deny 」であれば、リダイレクトするか、「Permission Denied 」のページを表示するか。ユーザーが要求したアクションの実行が許可された場合、それはどのように見えるか？

この章では、その決定(decision)に焦点を当てる。特に、次のような質問をします： 「アプリケーションの中で誰が何をすることができるのか？また、データについても話す必要があります。「誰が何をできるか 」を問うとき、どのようなデータ構造を調べるのでしょうか？

これが完全にオープンエンドな問題になるのを防ぐために、私たちは認可モデルを使用して実装を導きます。モデルとは、認可コードを構造化し、実装をガイドする方法である。

この章では、役割ベースのアクセス制御（RBAC）の使い方について説明します。異なる種類の企業間(B2B)アプリケーションを中心に、いくつかの異なるモデルを取り上げます。それぞれのモデルについて、以下について説明します：

認可モデルとは何か。適切な認可モデルを選択することは、望ましいユーザエクスペリエンスに依存します。そのモデルがどのようなものであるか、また、実際の使用例を示し、どのような場合に使用するのが合理的であるかを説明します。

モデルの実装方法: 前章で述べたように、認可の決定はデータとロジックという2つの情報で構成される。認可ロジックは、誰が何をできるかを決定する抽象的なルールセットである。例えば、ある組織のメンバーは、その組織に属するリポジトリへのアクセスを許可される。 これらのルールは認可データ上で表現される。

さらに、リレーショナルデータベースにどのように格納されるかのスキーマ図を含めて、ロジックをバックアップする認可データをどのように構成するかを説明します。(e.g PostgreSQL)

多くの場合は、前の章で紹介した GitClub のサンプルアプリケーションを使うことになるでしょう。覚えておきましょう： GitClubはソースコードのホスティング、コラボレーション、バージョン管理のためのウェブサイトであり、現実のアプリケーションであるGitLabやGitHubに似ています。GitClubは、そもそも権限付与の動機となるもの、つまりリソースへのアクセスを確保することの純粋な例を提供している。GitClubでは、リソースの例はリポジトリだ。ユーザーは、リポジトリを読んだり変更したりすることができるかもしれないし、できないかもしれない。

#### Enforcement

それぞれの例では、アプリケーションの中で、以前推奨したように認可が実施されていると仮定します。たとえば、リポジトリを返すメソッドでは、ユーザーがそのリポジトリの読み込みを許可されているかどうかをチェックし、許可されていなければ拒否されたことを返します：

![alt text](<assets/CleanShot 2024-10-25 at 20.07.56@2x.png>)

前の章で紹介したis_allowedインターフェイスを使います。

これはアクター、アクション、リソースを受け取り、True/Falseを返します。

### Why Use Authorization Models?

認可モデルは、「私たちのアプリケーションで誰が何をできるか」という、そうでなければオープンエンドな質問に構造を適用するのに役立ちます。これは実装の観点からは素晴らしいことで、適用するテンプレートがあると便利です。また、ユーザーエクスペリエンスを劇的に向上させます。

認可モデルは、実装の指針になるだけではありません。それは、アプリケーションの中で何ができるかを示すために、ユーザーに教えるメンタルモデルです。明確な認可モデルを持つことで、私たちはユーザーに、「あなたが私たちのアプリケーションで実行することが期待されている職務はこれです 」と伝えることができます。

どのような権限が必要なのかを理解するためには、アプリケーションがどのように機能するのかを熟知している必要があります：

![alt text](<assets/CleanShot 2024-10-25 at 20.10.04@2x.png>)

あるいは、どこかの管理者を困らせるようなダイアログが表示される

![alt text](<assets/CleanShot 2024-10-25 at 20.11.55@2x.png>)

では、どうすればこのような状況を回避できるのだろうか？

それは、現在のニーズに適切で、新しいニーズが発生したときに対応できるよう、時間とともに成長できる柔軟性を備えた承認モデルを使用することだ。

時間の経過に伴う新しいニーズに対応するのは難しい部分であり、チームが苦労しているのを見てきました。この章では、モデルが互いの上に構築され、柔軟性とシンプルさのバランスが取れていることを確認することで、この問題に対処する。

### Role-Based Access Control (RBAC) Models

ロールは、認可のアプローチとして広く使われている。ロールベースのアクセス制御」としても知られるロールは、実装者とユーザの両方にとって、認可ロジックを単純化する効果的な方法です。

ロール(Role)とは、単に権限をグループ化し、ユーザに割り当てられるようにしたものです。

ユーザがロールに割り当てられると、そのロールが持つすべてのパーミッションがユーザに付与されます。

パーミッション(Permission)は、ユーザがリソースに対して実行できるアクションを指定します。例えば、ある組織のユーザはリポジトリの読み取り権限を持っているとします。

ロールのパーミッションは任意に選ばれるものではありません。一般的に、ロールはユーザーが誰なのか、アプリケーションで何をしたいのか、そしておそらくは組織内での役割や肩書きに沿ったものであるべきです。

例えば、GitClubでは主要なユーザーは開発者です。これは、私たちのシステムにおける一つの「ロール」になります。組織の設定を担当する IT 管理者や、課金を担当する財務担当者などです。これらのユーザはそれぞれ、アプリケーションを使用するために必要な異なる権限を持っています。GitClub の権限モデルでは、これらのユーザはそれぞれひとつのロールになります。

"課金" ロールに割り当てられた人は、当然ながら組織の課金を設定できることを期待するでしょう - 新規会員の支払いや支払い情報の更新などです。

ロールを使うことで、エンドユーザーに公開する必要のあるパーミッション情報の表面積を減らすことができます。アプリケーションを使用するために、膨大な数のパーミッションを設定する代わりに、少数のオプションから選択することができます。

ロールは信じられないほど柔軟であり、このセクションで異なる機能を実現するためにロールを使用するいくつかの異なる方法を見ていきます。

### Organizational Roles

GitClubでは、他の多くのアプリケーションと同様に、マルチテナント・アプリケーションとしてアプリケーションを構築しています。つまり、単一のバージョンのアプリケーションで、多くのインスタンスがすべてのユーザーや組織のリクエストに対応するということです。当然ながら、ユーザーが所属していない組織のリソースを閲覧できないようにする必要があります。では、どうすればよいのでしょうか？

#### What the authorization model is

ロールの単純な出発点は、各ユーザを1つの組織に関連付け、ロールに割り当てることです。その後、すべてのアクセスは、そのユーザーが組織内で持つどのロールによっても制御されます。

しかし、どのようなロールを作成すればよいのでしょうか？

ユーザー・エクスペリエンスをできるだけシンプルに保つために、最初は少数のロールで始めるべきです。ロールの数が多すぎると、すぐに混乱して管理が大変になります。

GitClub では、まず admin と member の二つのロールを用意します。これは、多くの B2B アプリケーションで一般的な開始点です。メンバーロールは、アプリケーションのすべてのコア機能 (リポジトリの読み書きなど) にアクセスできます。管理者は、メンバーができることすべてと、組織にユーザーを招待することができます。実際のシステムでは、管理者に支払いの設定、設定の構成、組織の削除の権限を与えるかもしれません。

#### How to implement the model

まず第一に、ユーザーを特定の組織に関連付け、ロールに割り当てる方法が必要です。データモデルでこれを実現する簡単な方法は、組織からユーザーへの1対多のリレーションシップを持ち、ユーザーに別のroleカラムを持つことです。

![alt text](<assets/CleanShot 2024-10-25 at 20.15.59@2x.png>)

このデータモデルでは、ユーザーがリソースに対してアクションを起こせるかどうかをチェックするロジックは、以下のチェックで構成される：

1. そのユーザーが所属する組織と、どのようなロールを持っているか
2. ロールが持っているパーミッション
3. パーミッションがアクションとリソースに適用されるかどうか

ロールと組織はユーザーデータに由来する。

ロール名からパーミッションの文字列リストまでの単純な辞書に格納することで、「ロールがどのようなパーミッションを持っているか」を定義します。手始めに、リポジトリへの読み書きと組織へのユーザー追加に関する簡単なパーミッションに注目してみましょう。例えば

![alt text](<assets/CleanShot 2024-10-25 at 20.17.03@2x.png>)

パーミッションにはaction:resourceという規約を使用しています。つまり、ユーザーがこのパーミッションを持っていれば、「resource 」タイプのリソースに対して 「action 」を実行できるということです。ユーザーは特定の組織のロールを持っていますが、パーミッションは組織とリポジトリの両方に適用されることに注意してください。

リソースがロールと同じ組織に属している場合、パーミッションは対象のリソースに適用されます。これらをまとめると

![alt text](<assets/CleanShot 2024-10-25 at 20.17.49@2x.png>)

#### When to use this model

これは、アプリケーション内でのアクセスを決定するものが組織レベルのロールだけである場合にうまく機能する、シンプルで保守性の高いモデルを提供します。

このモデルにはいくつかの制限があります。各ユーザーはただ1つの組織と関連付けられ、組織内のすべてのリソースを同じように扱います。異なるリポジトリに対して異なる権限を割り当てる必要がある場合、これでは十分ではありません。次のセクションでは、このようなケースをカバーするためにモデルを拡張する方法を示します。

### Cross-Organization Roles

#### What the authorization model is

GitClub のような共同作業ソフトウェアでは、一人のユーザーが個人的なプロジェクトのために自分のアカウントを持ち、また他の人と共同作業をするために他の多くの組織にも参加するのが一般的です。

各ユーザーをひとつの組織だけに所属させるのではなく、一人のユーザーが複数の組織に所属できるようにします。さらに、ユーザーは所属する組織ごとにロールが必要になります。

これをサポートするために、これまでの1対多のユーザーと組織の関係を、**多対多**の関係に変更する必要がある。

#### How to implement the model

多対多のリレーションの場合と同じように、結合テーブルを作成し、そのテーブルにロール名のカラムを追加してデータを構造化します。

![alt text](<assets/CleanShot 2024-10-25 at 20.19.49@2x.png>)

これにより、組織に所属することと、組織で役割を割り当てられることは同じであることが明示される。ロールを持たずに組織に所属することは不可能であり、その逆も同様である。

ロジックについては、以前と同じパーミッションを使用します。しかし、ユーザーのすべてのロールを検索し、ターゲット組織と照合するためにロジックを更新する必要があります：

![alt text](<assets/CleanShot 2024-10-25 at 20.20.15@2x.png>)

ロジックは少し複雑になり始めています。データベースからロールをフィルタリングすることで、潜在的な数の中から該当するロールをチェックしています。しかし、同じ基本的な構造がまだ存在することがわかります：ロールを取得し、それが組織に一致するかチェックし、正しいパーミッションをチェックします。

#### When to use this model

ユーザが複数の組織にまたがってアカウントを持つ必要がある場合、このモデルは先に説明したシンプルなモデルよりも大きく改善される！

この代替案は、Slackのような状況（記事執筆時点）であり、参加するSlackワークスペースごとに個別のアカウントとログインを作成する必要がある。これは、ユーザーがアカウントを持っているかどうかさえ分からない、ログインが何であるかを忘れてしまう、そして一般的に新しい組織に参加する障壁を増やすという状況をもたらします。

これは、将来的な対策としても価値のある取り組みであることが多い。アプリケーションが1組織につき1ユーザーのモデルに明確に適合しているように見えても、将来的には組織横断的なユーザーを追加する必要が出てくるかもしれません。より柔軟なモデルを使うことで、この新しい機能を後の段階で追加しても、移行は必要ない。この柔軟性の代償として、データモデルが若干複雑になります。

### Resource-Specific Roles

GitClubでは、大きな組織にも使ってもらえるようになったとします。顧客から、特定のリポジトリを誰が見ることができるかをもっとカスタマイズしたいという声が聞かれるようになりました。例えば、ある顧客は、すべてのインフラをコードとしてリポジトリに保存している。すべてのチームメンバーがこのリポジトリに書き込みアクセスできるようにすることはできません。

多くのB2B企業は、この機能要求の何らかのバリエーションに遭遇するでしょう。組織内のすべてのリソースへのアクセスを一律に扱うことに満足している限り、私たちが書いた組織ロールはうまく機能する。しかし、当社の製品を使用する組織の規模が大きくなるにつれて、単一のロール・セットでは、すべてのユーザーができることを十分に説明できなくなります。当社の顧客は、フォルダを作成し、フォルダにロールを割り当ててファイルへのアクセスを管理したり、リソースをプロジェクトや部署ごとにグループ化したり、個々のリソースへのアクセスを明示的に制御できるようにしたいと考えるかもしれません。

これに対処するために、リソース固有の役割を導入することができる。

#### What the authorization model is

リソース固有ロールは、組織ロールをより一般的にしたものです。特定の組織にロールを関連付けるのではなく、あらゆる種類のリソースにロールを関連付ける。組織自体がリソースの一種であるため、組織ロールはリソース・ロールの特殊な形となります。

GitClubでは、リポジトリもリソースの一種です。ここでは、組織のロールに加えてリポジトリにスコープされるロールを紹介します。

#### How to implement the model

このモデルのいいところは、組織の役割と同じ構造になっていることだ。

実際、組織そのものがリソースである。組織へのアクセス（または組織のメンバーであること）は、他のリソースへのアクセスと同じようにゲートされる！組織はもはや特別なケースではありません。すべてのリソース（この場合は組織とリポジトリ）は、このように同等のデータモデルを持っている：

![alt text](<assets/CleanShot 2024-10-25 at 20.24.04@2x.png>)

ベストプラクティスとして、ユーザーが同じリソースにアクセスできる異なる方法の数を最小限にします。そのため、リポジトリにアクセスするにはリポジトリのロールが必要です。今後は、リポジトリとのやり取りを許可する権限を組織のロールに割り当てることはありません。

GitClub では、「admin」 と 「member」 という 2 つの組織ロールはそのままに、「mentainer」 と 「contributor」 という 2 つの新しいロールをリポジトリ用に定義します。メンテナは、ブランチの作成やコードのプッシュ、プルリクエストのマージなど、リポジトリに対して何でもできます。コントリビューターは、コードを読んだり、課題を開いたり、プルリクエストを開いたりすることしかできません。

リポジトリを作成した人には、自動的に「メンテナ(maintainer)」ロールを割り当てることができます。しかし、アクセス権を得るために、組織の全員を手動でリポジトリに追加しなければならないのは迷惑です。私たちが欲しいのは、組織の全員に適用される基本レベルのアクセスです。

例えば、リポジトリと同じ組織にいる人は、明示的にロールが割り当てられていない限り、デフォルトのロールは「貢献者(contributor)」です。

![alt text](<assets/CleanShot 2024-10-25 at 20.25.08@2x.png>)

一方、組織レベルのアクションのアクセスチェックは、引き続き組織のロールのみをチェックする。これには、組織に新規ユーザーを追加するようなアクションが含まれる。

#### When to use this model

リソース固有のロールは、多くのユースケースに十分なきめ細かなパーミッションをサポートできる、非常に強力なモデルです。ここでは、リポジトリと組織というシンプルなリソースから説明しましたが、きめ細かなアクセス制御を行いたいアプリ内の他のタイプのリソースにも、同じロジックを適用し続けることができます。

このモデルは、何らかのリソース階層を持つあらゆるものに適している。フォルダ（Google DriveやDropboxを想像してほしい）、プロジェクト、ディレクトリ、あるいはそれに類するものだ。

このレベルまで成熟すれば、ロールベースのアプローチでほとんどのニーズに対応できると確信できるはずだ！

### Custom Roles

さらに複雑な問題があります。

ある GitClub ユーザーは CI/CD チームを持っていて、その唯一の仕事はメインへのコミットのマージと CI ジョブの実行です。彼らはコードを読むことはできませんが、ワークフローをトリガーすることはできます。これは既存のどの役割にも当てはまらない。
様々なユースケースやカスタマイズをサポートするための最善の努力にもかかわらず、自分のアカウントでユーザができることを正確にコントロールする必要がある少数の企業ユーザがいます。最後の手段として、お客様が独自のロールを作成し、カスタマイズできるようにすることができます。これはデータベースを複雑にし、UIを必要とします。

#### What the authorization model is

カスタムロールは、エンドユーザ（アプリケーションのユーザ）が独自のロールを作成し、そのロールに権限を割り当てることができるモデルです。

これらのカスタム・ロールは、ユーザをロールに割り当てることで通常どおり使用することができます。カスタム・ロールは、既存のロールと一緒に使用することができます。

#### How to implement the model

カスタムロールのモデルは、ロールから権限リストへのマップが動的である必要があり、ユーザを動的に作成されたロールに関連付ける方法が必要であることを除けば、これまで使用してきたものと実質的に同じです。

これを実現するために、ロールを管理する追加のテーブルを作成します。各ロールは特定のリソースに関連付けられていなければなりません。組織でロールをカスタマイズしたい場合は、ロールを組織に関連付けます。

ロールはロール名とパーミッションのリストで構成される。

![alt text](<assets/CleanShot 2024-10-25 at 20.29.38@2x.png>)

抽象的な視点から見ると、これは以前のスキームで書いたロジックとほとんど同じに見える。「ロールが持っているパーミッションをチェックする "というステップは同じです。実装の観点からの違いは、これらのパーミッションがメモリではなくデータベースに保存されるようになったことです。

#### When to use this model

ユーザーが独自のロールを作成できるようにすることは、すべてのユースケースを想定し、それらのユースケースのためにロールを定義する必要なく、幅広いユースケースをサポートする素晴らしい方法です。

しかし、**これをサポートする選択には十分注意してください**。カスタムロールを機能させるには、権限の定義を公開することに賛同する必要があります。これは、ドキュメント化し、変更時にユーザーに通知することを意味します。新しいパーミッションで新しい機能を追加したり、アプリケーションを移動させたりすると、予期せぬ副作用があるかもしれません。

実際、私たちがインスピレーションを得た2つの主要な情報源であるGitHubとGitLabを見てみると、どちらのアプリケーションもカスタムロールをサポートしていません。

GitHubは2020年にロードマップを公開しましたが、それ以来ずっと動かしています：

![alt text](<assets/CleanShot 2024-10-25 at 20.31.00@2x.png>)

一方、GitLab はこの機能について多くの議論を行い、最終的にサポートしないことを選択しました: <https://gitlab.com/gitlab-org/gitlab-foss/-/issues/12736#note_50662947>

しかし、どのような場合にカスタムロールを作る意味があるのでしょうか。ひとつの可能性は、platform-as-a-serviceのように大規模な設定が必要なアプリケーションです。この場合、ユーザがどのようにチームを編成し、製品を使用するかをユーザに押し付けたくないかもしれません。

エンドユーザーが設定可能なロールの世界に入ることは、AWS Identity and Access Management (IAM)システムのような完全に設定可能な権限システムにつながる。これについては今後の章で詳しく説明する。

### 3. Quick Reference To Choosing An Authorization Model

私たちは、最も複雑でない（そして最も柔軟でない）ものから最も柔軟なものまで、ロールベースの認可の4つのバリエーションを示した。

1. 組織ごとに 「メンバー 」や 「管理者 」のようなロールをユーザーに与えることは、ほとんどのアプリケーションで始められる素晴らしい方法です。
2. ユーザが個人アカウントを持つ必要がある場合や、組織をまたいで共同作業を行う必要がある場合は、組織横断的なロールを追加することができます。これは複雑さを増しますが、より柔軟です。
3. B2Bアプリケーションで、より大きな組織にサービスを提供している場合、顧客はおそらくリソース固有のロールを必要とするでしょう。データモデルはより複雑になりますが、これによって特定のリソースに対する権限を制御できるようになります。
4. ユーザが独自の権限スキームを作成し設定できるようにする必要がある場合、カスタムロールを実装する方法を説明しました。これを必要とする企業はほとんどないでしょう！

ここで説明したロールは、プロダクションで遭遇する多くの状況をカバーします。しかし、すべてをカバーしているわけではありません。ロールでは対処できない状況もあります：

1. ユーザーが作成したコメントを削除できる
2. ユーザーは共有されたコードスニペットを読むことができます。
3. 閲覧が許可されているリポジトリに属するすべての課題を閲覧することができます。

次の章では、このようなケースに対応するために、*関係*に基づく認可(ReBAC)を紹介する。
