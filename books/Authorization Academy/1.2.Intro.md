# Authorization Academy

ref: <https://www.osohq.com/academy>

- [Authorization Academy](#authorization-academy)
  - [Authorization Academy Introduction](#authorization-academy-introduction)
    - [What Does Authorization Academy Teach?](#what-does-authorization-academy-teach)
  - [What is Authorization?](#what-is-authorization)
    - [1. Authentication vs. Authorization](#1-authentication-vs-authorization)
    - [2. What Authorization Looks Like in an App](#2-what-authorization-looks-like-in-an-app)
      - [Website Architecture](#website-architecture)
      - [The Data Model](#the-data-model)
      - [Our Authorization Goal](#our-authorization-goal)
    - [3. Where To Put Our Authorization Logic](#3-where-to-put-our-authorization-logic)
      - [Initial connection](#initial-connection)
      - [At the proxy](#at-the-proxy)
      - [At the website router](#at-the-website-router)
      - [In the web application/controller](#in-the-web-applicationcontroller)
      - [Extra credit](#extra-credit)
      - [At the database/database connector](#at-the-databasedatabase-connector)
    - [Summary](#summary)
    - [4. Adding Authorization to an Application](#4-adding-authorization-to-an-application)
      - [Naïve Approach](#naïve-approach)
      - [Separating our authorization from our application is difficult](#separating-our-authorization-from-our-application-is-difficult)
      - [Formalizing Our Authorization Model](#formalizing-our-authorization-model)
      - [What Interface To Use For Our Authorization API](#what-interface-to-use-for-our-authorization-api)
      - [Options for Implementing Authorization Decisions](#options-for-implementing-authorization-decisions)
        - [Decentralized authorization: keeping authorization in the application](#decentralized-authorization-keeping-authorization-in-the-application)
        - [Centralized authorization: adding a service](#centralized-authorization-adding-a-service)
        - [Hybrid approach](#hybrid-approach)
      - [A Quick Guide To Authorization Data Flow](#a-quick-guide-to-authorization-data-flow)
    - [5. Putting Everything Together](#5-putting-everything-together)
    - [6. What's Next](#6-whats-next)

## [Authorization Academy Introduction](https://www.osohq.com/academy/authorization-academy)

認可アカデミーは、アーキテクチャ、モデリングパターン、実施、テスト、UIレベルでの統合など、認可をアプリケーションに組み込む方法を説明する一連のテクニカルガイドです。このコースを修了すると、認可の仕組みに関するメンタルモデルと、認可をアプリケーションに組み込むためのツールを手に入れることができます。
多くの開発チームがそうであるように、Authorizationにかける時間は必要な分だけにしたいものです。問題は、アプリに認可を組み込む方法について、開発者が利用できる具体的な資料が限られていることです。開発者がこのようなシステムや機能を構築できるように、私たちはオーソリゼーション・アカデミーを執筆しました。
このコースをできるだけ具体的にするために、GitClubというアプリケーションの例をコース全体を通して使います。GitClubはソースコードのホスティング、コラボレーション、バージョン管理のためのウェブサイトです。聞き覚えがあるかもしれません！GitClubの着想は、GitHubやGitLabといった実際のアプリケーションから得たもので、これらは一般的な認可のシナリオのケーススタディとして適しています。
このコースでは、企業間（B2B）のSaaS（Software-as-a-Service）アプリケーションにおける認可に焦点を当てます。このコースは、あらゆるレベルの開発者に役立ちます。初心者の開発者にとっては、Authorizationの基礎をしっかりと身につけることができます。経験豊富なベテランの方には、過去に遭遇したことのある問題へのすっきりとしたアプローチを提供します。
私たちは認可のプロフェッショナルです。このコースは、オーソリゼーション・システムを開発した経験や、スタートアップからフォーチュン100社に名を連ねる企業でオーソリゼーションに携わっている開発者との数十回に及ぶミーティングを基に作成しました。

### What Does Authorization Academy Teach?

このコンテンツは章に分かれており、以下のトピックを取り上げる：
a. 第II章 オーソライゼーションとは何か？認可とは何か: 認可コードを整理する方法
b. 第III章: ロールベースのアクセス制御: アプリ内の権限をUserやAdminのようなロールにグループ化する
c. 第IV章: 関係ベースの制御: 「投稿の作成者はその投稿を編集できる」のように、関係によって権限をグループ化する
d. 第V章： 権限の強制: アプリがアクセスの許可または拒否を決定したら、その決定をどうするか？

私たちは今後の章を計画している：

1. ユーザーインターフェース
2. 認可コードのテスト
3. マイクロサービス間の認可

## What is Authorization?

認可は、アプリケーションで誰が何をできるかを制御するメカニズムです。ユーザが自分のデータにアクセスでき、自分のデータ以外のデータを見ることを許可されないようにする方法です。認可には、どのようなアプリケーション・アーキテクチャにも適合する、共通のアーキテクチャ・パターンがあります。このガイドではそのパターンを紹介します。
認可はすべてのアプリケーションの重要な要素ですが、ユーザからはほとんど見えません。また、大抵の場合、あなたが取り組んでいるコア機能やビジネスロジックとは無関係です。

### 1. Authentication vs. Authorization

多くの人が、認証と認可の両方を指すのに、「auth」という用語をよく使います。しかし、これらは同じものではありません。
認証は、ユーザが誰であるかを検証するメカニズムです。アプリケーションのフロントドアです。例えば、ユーザー名とパスワードは、一緒になってID（ユーザー名）と検証方法（パスワードを知っているか）を構成する。その他の認証形式としては、OAuthやOpenID Connect（OIDC）がある。OIDCは、「Googleでログイン」や「Facebookでログイン」のような機能を追加するためによく使われ、SAMLは、企業が従業員に複数のアプリ間で単一のログインを与えるために使う標準である。

認可とは、ユーザーができることをコントロールするメカニズムである。認証がフロントドアであるなら、認可は、ユーザが中に入ってから開けられるドアを制御する。
認可はしばしば認証の上に構築され、この2つが最も密接に重なり合うのは、ユーザが誰であるかという情報が、そのユーザができることを決定するための入力となる場合である。例えば、あるユーザーが認証されると、そのユーザー名を使って権限を調べたり、他の属性に基づいて権限を推測したりすることができます。

このコースでは、認証に焦点を当て、関連する場合のみ認証に触れます。このコースでは、あなたが認証システムを導入しているか、他の場所で入手可能なガイダンスに従って認証システムをセットアップできることを前提としています。

### 2. What Authorization Looks Like in an App

私たちは、理論だけでなく、オーソライゼーションの実践例をお見せしたいと思います。そのために、各コンセプトを実証できるサンプルアプリを作りました。

GitClub は、ソースコードのホスティング、コラボレーション、バージョン管理のためのウェブサイトです。これは、現実のgitホストであるGitHubやGitLabによく似ています。GitClubは、そもそも権限付与の動機となるもの、つまりリソースへのアクセスを確保することの純粋な例を提供しています。GitClubのリソースの一つはリポジトリで、リポジトリにはアクセス制限があります。ユーザーはリポジトリを読んだり変更したりすることができるかもしれませんし、できないかもしれません。つまり、認可が必要なのです！

#### Website Architecture

まずは、GitLab のみなさんが提供している素晴らしいドキュメントを参考に、妥当なサービスのアーキテクチャを考えてみましょう。複雑そうに見えるかもしれませんが、心配はいりません！このアーキテクチャの中で認可がどのような位置づけにあるのかを説明しながら、徐々に複雑な部分を取り除いていきます。

![alt text](<assets/CleanShot 2024-10-24 at 23.22.52@2x.png>)

上の図は、私たちのアーキテクチャの主な部分を含んでいます。

gitclub.devは3種類のトラフィックを処理します：

1. ウェブサイトへの訪問。これは、gitclub.comのフロントページの内容のようなHTMLをブラウザに返します。
2. APIリクエスト。これは、ユーザーやサードパーティの統合機能からのデータのリクエストを処理し、JSON やその他の構造化されたデータ形式を返します。
3. git clone <<https://gitclub.dev/oso/authzacademyのような> Git 接続。SSH または HTTP 接続です。

すべてのリクエストは1つのポイントに接続される。プロキシはウェブサーバーの代わり（「プロキシ」）をするので、この名前がついた。プロキシは接続を適切な場所にリダイレクトします。完全なシステムでは、プロキシはロードバランサーや認証プロキシのような多くの部分から構成される。

ウェブサイトとAPIはデータベース（DB）にアクセスすることができる。

APIとGit接続はファイルシステム（FS）にアクセスし、そこにGitリポジトリが保存されます。

認証のために(注意: 認証と認可の違いについてはイントロダクションを参照)、ウェブアプリケーションは単純なユーザ名とパスワードの仕組みを使ってユーザを認証します。最初の認証の後、ウェブアプリケーションはユーザーにトークンを返し、その後のリクエストでパスワードを再入力する必要がないようにします。Webアプリケーションでは、APIアプリケーションとやりとりするためのAPIトークンを作成することもできる。これらのトークンは「**ベアラートークン**」と呼ばれ、トークンの持ち主にアクセスを許可する軽量なトークンです。

Gitサービスは、ウェブ・アプリケーションと同じユーザー名とパスワードのペアを用いて認証を行う。

余談：モノリス対マイクロサービス

ここでの例のアーキテクチャはかなりモノリシックだ。実行中のアプリケーションは数個だけだ。マイクロサービスについては、いくつかの違いがあり、それらに遭遇したときに呼び出すことにする。

#### The Data Model

このシステムには多くのGitリポジトリがある。
組織では、リポジトリへのグループ・アクセスを許可しています。組織（会社やオープンソースのグループなど）は多くのリポジトリを持つことができます。各組織は多くのユーザーを持つことができます。

一人の個人はユーザーによって表されます。ユーザーは多くの組織に属することができます。(org:user = N:N)

#### Our Authorization Goal

私たちのシステム全体で、1つの権限ルールを適用します。ユーザーがリポジトリにアクセスできるのは、そのリポジトリを所有する組織に属している場合のみです。
後でルールを追加します！

### 3. Where To Put Our Authorization Logic

さて、アーキテクチャの概要がわかったところで、リクエストがアプリケーションのコンポーネントを通過するのを追いかけて、どこで認証が行われるのかを考えてみましょう。
ある GitClub ユーザー 「<alice@acme.org>」 がウェブインターフェイスからアプリケーションにアクセスしています。彼らが特定のリポジトリ、例えば <<https://gitclub.dev/acme/anvilのページにアクセスしようとしたとしましょう。どうなるでしょうか？>

彼らは以前にパスワードで認証されているので、リクエストにはトークンが認証情報として含まれています。この場合、acmeは組織であり、ユーザはその組織のメンバーなので、ユーザはこのリポジトリへのアクセスを許可されています。

インフラを通してリクエストを追跡するとき、認可の3つの主要な側面に戻ってくる：

1. 誰がリクエストしているのか？
2. 彼らは何をしようとしているのか？ (What are they trying to do?)
3. 何をしようとしているのか？ (What are they doing it to?)

#### Initial connection

まず最初に、ユーザーのブラウザが私たちの外部向けプロキシと接続を行います。

誰がリクエストしているのか?

-リクエストをするUserの身元はまだわからない。そうするにはリクエストからトークンを取り出す必要がある。おそらくIPアドレスはわかっているでしょう。

彼らは何をしようとしているのか?

-TLS接続の確立。

接続先は?

-ホスト: gitclub.dev on port 443.

アプリケーションの認可はまだ行っていませんが、ネットワークレベルの認可を行うことは可能です。IPアドレスの許可リストを作るとか、あるいは相互のTLSを要求するとか（これはやや議論の余地がありますが）。

#### At the proxy

プロキシは、必要に応じてウェブサーバ、APIサーバ、Gitサーバにトラフィックを誘導するように設定される。これら三つのサーバーは、最終的にはある程度のユーザー認証を行う必要があります。先ほど説明したように、認証にはユーザー名とパスワードの組み合わせかベアラートークンが使われます。

認証を必要とするダウンストリームサービスが多数ある場合、認証プロキシを追加する価値は高くなる。例えば、WebアプリケーションとAPIアプリケーションは、ほとんどのルートにアクセスするためにトークンを必要とする。トークンの検証をプロキシで処理すれば、次のような認証ができる：

リクエストをするのは誰か？

プロキシはリクエストに含まれるトークンを検証する。トークンはさらにユーザに関する情報を含むかもしれない。例えば、JSON Web Token (JWT)のように、JSONでエンコードされたデータを使うかもしれません。

デコードされたトークンが次のようなものだとする：

```json
{
    "email": "alice@acme.org",
    "valid_until": "2024-10-24T23:22:52Z",
    etc... 
}
```

それなら、ユーザーは 「<<alice@acme.org>」だとわかる。

彼らは何をしようとしているのか？

HTTPリクエストを検査することで、ユーザーがGETリクエストをしていることがわかります。

彼らは何に対してGETリクエストをしているのでしょうか?

繰り返しますが、HTTPリクエストを検査することで、URLは/acme/anvilです。

私たちが知っていることに基づいて認可を実行できますか?

どのような認可を適用したいかによる。リクエストに存在する情報だけが与えられれば、ルートレベルで適用される認可だけを行うことができます。ユーザ「<alice@acme.org>」は/acme/anvilへのGETリクエストを許可されていますか?

ユーザに関する唯一の情報はメールアドレスです。すべてのユーザは /<owner>/<repository形式のパスに GET リクエストを行うことができます。

しかし、もし私たちが完全な要件 - ユーザーはリポジトリと同じ組織でなければならない - を実施したいのであれば、十分な情報がありません。どうすればその情報を得ることができるでしょうか？トークンにどんどん情報を追加していくことも考えられます。あるいは、データベースにアクセスするようにプロキシを設定することもできます。この方法はProxyをかなり複雑にし、Databaseアクセスロジックを重複させます。

しかし、プロキシは、レート制限ユーザー、APIキーまたは認証の要求、Webアプリケーションファイアウォール（WAF）に見られるような悪意のあるペイロードのスキャンなど、認可に関連する懸念を適用するのに適した候補である。

#### At the website router

![alt text](<assets/CleanShot 2024-10-24 at 23.31.17@2x.png>)

プロキシについては説明した！Webサイトとデータベースに移りましょう。

最後に、認証されたリクエストはWebアプリケーションのルータに到達し、ルータがリクエストの処理方法を決定します。この時点で、認証ミドルウェアがリクエストで提供されたIDをデータベースから取得したデータモデルに変換するのが一般的です。

リクエストを行うのは誰か？

-認証ミドルウェアがリクエストで提供されたIDをUserオブジェクトに変換し、Userについて知りたいことすべてにアクセスできるようにしたと仮定しましょう。

彼らは何をしようとしているのでしょうか？

-まだHTTPリクエスト・オブジェクトを使っており、HTTPメソッドはGETである。

何のために？

ここにはまだリクエストオブジェクトとパスしかない： 「/acme/anvil"。

アプリケーションデータにアクセスできるので、関連する情報を調べることができます。たとえば、既存のロジックを使って、/acme/anvilに対応する組織を調べ、ユーザがその組織に属しているかどうかを見ることができます。

しかし、これは次のステップのコントローラ層で行う必要があることとほぼ同じです。コントローラはリクエストを受け取り、データを検索し、必要なデータ操作を行い、ビジネスロジックを適用します。

したがって、ミドルウェアで認可を行うというアプローチを取ろうとすると、 ロジックが重複してしまい、データベースへの呼び出しが重複する可能性があります。

このレイヤで認可を行うことが意味のあるシナリオがいくつかある：

1. 単純なルートレベルのプロパティをチェックすることで、認可に徹底的な防御アプローチを適用する。たとえば、ウェブサイトの /admin/... に管理者専用の領域があり、User オブジェクトに管理者権限が保存されている場合、このチェックを素早く適用できます。
2. リクエストの処理のどこかで、おそらくアプリケーションのより深いレイヤーで、認可が実行されたことを確認する。これは、粗いルートレベルの懸念だけをカバーするという制限を受けずに、 認証がどこでも適用されることを保証するという利点を得ることができます。
3. リクエストルーティングとデータアクセスが密接に結合しているアプリケーション。例えば、データベースの前に薄いRESTやGraphQLインターフェイスを持つAPI駆動型アプリケーションなどである。この場合、RouterとControllerのレイヤーは実質的に1つのレイヤーに圧縮され、認可は両方に同時に適用することができる。詳しくは次で説明する。

#### In the web application/controller

Webルータは、GET /acme/anvilをコントローラのメソッドにマッピングします。このメソッドを view_repository(owner: 「acme」, name: 「anvil」) とします。

このメソッドでは、/acme/anvil のウェブページを表示するために必要なデータを照合し、そのデータをビューに渡します。GitClub ではシンプルなコードにこだわっているので、ページのレンダリングもサーバーサイドで行っています。UI のデータをすべて取得し、ユーザー用のテンプレートをレンダリングします。

あまり細かいことは省きますが、おそらくリポジトリビューにはソースコードや課題、プルリクエスト、投稿者などのほか、リポジトリそのものの基本的な情報が含まれることになるでしょう。

最終的に、ユーザーに表示されるデータはすべて認可されたものでなければなりません。そもそも彼らはリポジトリを見ることができるのでしょうか？ページ上のすべての追加データはどうでしょうか？

誰がリクエストしているのでしょうか？ (Who is making the request?)

-前のステップから、Userオブジェクトは認証ミドルウェアの一部としてフェッチされたと仮定できます。

彼らは何をしようとしているのでしょうか？ (What are they trying to do?)

-リポジトリページを表示し、リポジトリ情報にアクセスします。コントローラメソッド内で、Userが何をしようとしているのかがわかります。

ユーザが何をしようとしているのか? (What are they doing it to?)

-acme/anvilリポジトリです。いずれにせよ、メソッドの一部としてデータベースから取得します。

ようやく、すべてのカモが揃ったようだ。必要なデータはすべて揃っており、ユーザーが何を達成しようとしているのかも正確に分かっている。アンビルリポジトリはacmeという組織が所有しており、ユーザーはその組織のメンバーです！彼らにこれを読ませるべきだ。

#### Extra credit

しかし、まだある！

ビューのレンダリングの一部としてアクセスされるすべての補助データはどうでしょうか？リポジトリメンバー、課題、コメントなど。これらはすべてユーザーに見えるのでしょうか？

まあ、必要に応じてアクセス制御を決定し続けることができます。私たちは関連するすべての情報にアクセスすることができ、ユーザの代わりにどのデータを取得しようとしているのかを知ることができます。

ここでさらに踏み込むことができます。ユーザーはリポジトリの管理者ではないので、リポジトリの設定を行うアクセス権を持っていないとします。つまり、この情報をビューレンダラに返すことで、ページからそのオプションを非表示にすることができます。これについては、今後のガイドで詳しく説明します。

ユーザーがリポジトリの閲覧を許可されていない場合、役立つ情報を表示するビューをレンダリングしたり、「Forbidden」 レスポンスを返したりするのに理想的です。

#### At the database/database connector

データベースからデータをフェッチするときです。SQLクエリそのもの（ミドルウェアやクエリプロキシを使って）、あるいはデータベース内です。

誰がリクエストしているのか？ (Who is making the request?)

クエリコンテキストにユーザの情報を含めることができます。

ユーザは何をしようとしているのか？ (What are they trying to do?)

SQLのSELECT文を実行する。

何をしようとしているのか？ (What are they doing it to?)

名前=「acme/anvil 」でフィルタリングされたリポジトリテーブル。

データアクセスレイヤーに入ったので、必要なアプリケーションコンテキストをデータベース接続/リクエスト、またはデータベースクエリに含める必要があります。

強制したいロジックを思い出してください：

ユーザーは、リポジトリと同じ組織に所属していれば、リポジトリを読むことができます。

このルールはSQLクエリとして簡単に表現できるため、データレイヤーはこのルールを強制するのに理想的な場所です。この場合、repositoriesテーブルでSELECT文を実行するときに、organization_membersテーブルでjoinし、ユーザと同じ組織に属するリポジトリだけを選択することができます。

![alt text](<assets/CleanShot 2024-10-24 at 23.40.12@2x.png>)

このアプローチの利点は、Yes/Noの認可クエリに答える以上のことができることです。例えば、同じフィルタを適用することで、ユーザがホームページで閲覧できる全てのリポジトリをリストアップすることができます。

ここでの課題は、アプリケーション内で処理するSQL文の構築と管理のロジックを重複させることなく、認可のためのクエリフィルタを生成する方法です。このため、アプリケーションの他の場所で使われているのと同じメカニズムを使うことで、認可フィルタを実装するのが最も理にかなっていることがよくあります。

### Summary

まとめると、認可を適用する場所にはいくつかの候補がある：

1. ネットワーク層。このレイヤーのデータは非常に限られており、許可/拒否リストのような単純なネットワークアクセス制御手段しか使えない。ここでは認可に焦点を当てるべきでない。
2. プロキシまたはルータ。一般的に、より詳細なアクセス制御を行うには、認可を決定するためにサービスやデータベースを呼び出す必要があります。
3. アプリケーション/コントローラ。ここではすべての情報が利用可能なので、認可要件を簡単に適用できます。認可ロジックを配置する場所としては、ここがよいでしょう。
4. データベース: アプリケーションがデータベースフィルタを生成する場合、ここで認可を適用できます。これは、アクセスに関してより広範な質問をすることができるので、**可能であれば、ここで認可を実施するのがベストです**。

なぜなら、ユーザーが何をしようとしているのかという正確なコンテキストと、判断を下すために利用可能なデータが最も多く存在するからである。

### 4. Adding Authorization to an Application

これまで、アーキテクチャのどこで認可を適用するかについて説明してきた。多くの場合、アプリケーションの中で認可を適用し、アプリケーションのコンテキストに完全にアクセスできるようにしたい。

しかし、どのように認可を設計し、実装し、実行するのでしょうか？

#### Naïve Approach

多くの人は、開発を始めるとき、別の開発ステップとして「認可を実装する」ことはしない。彼らは単純に、必要だと思われるチェックをアプリケーションコードに追加するだけです。これが一般的な理由は、ロジックが単純に感じられるからです。それがそこにあることに気づかないかもしれない！例えば、データベースクエリの一部として、ユーザーIDや組織IDによってすべてのリポジトリをフィルタリングすることができます。アプリケーション・コンテキストがすぐそこにあるので、この方法で実装するのは簡単です。

しかし、これはすぐに難しくなります。認可を適用する必要がある場所が増えてくると、同じロジックを重複させてしまうことになる。変更を加えるには、ロジックが重複しているすべての場所を覚えておく必要がある。

前の例では、ユーザーがAcme組織のメンバーである場合にのみ、/acme/anvilページを見ることができるようにしました。同じロジックが/acme/anvil/issuesや/acme/anvil/membersなどの他のサブページにも適用されます。これらのページを処理する各メソッドは、同じロジックを繰り返す必要がある。

ここで、特定のリポジトリで共同作業を行うために、組織外のユーザーを招待する機能を追加するとします。このチェックを認可ハンドラに追加する必要があります。ナイーブなケースでは、リポジトリページを扱うすべてのメソッドを意味します。

#### Separating our authorization from our application is difficult

アプリケーション・ロジックの他の部分と同じように、「懸念事項の分離」を適用し、認可をアプリケーション・ロジックから独立して書きたい。これは意外と難しいことがわかりました！ 最初は、すべてのリポジトリビューをリファクタリングして、最初にリポジトリを読み込んで権限をチェックするようにするかもしれません。組織の管理者だけが/acme/anvil/settingsへのアクセスを許可されています。そのため、組織の管理者に関する情報も含めるように、リポジトリの抽象化を修正する必要があります。認可はアプリケーションと深く関わっているため、認可をビジネスロジックから切り離すためのきれいなインターフェイスを考えるのは難しいかもしれません。

どうすればより良いものを設計できるでしょうか？

#### Formalizing Our Authorization Model

上記の例のセクションで、オーソライゼーションの判断はしばしば次のように組み立てられると述べた：

1. 誰がリクエストしているのか(Who is making the request)
2. 何をしようとしているのか(What are they trying to do)
3. 何をしようとしているのか(What are they doing it to)
オーソライゼーションについて書く場合、これらのそれぞれについて正式な用語があります。

「誰が」は**行為者(actor)**と呼ばれる。多くの場合、この行為者はアプリケーションの単なるユーザです。

「何をしようとしているか」は、多くの場合、単純な動詞に帰着します。例えば、APIで一般的なcreate、read、update、delete（CRUD）などです。私たちはこれらの**アクション(action)**をこう呼びます。

「何に対してそれを行っているか」が**リソース(resource)**です。
これは、アプリケーション内の特定のオブジェクトかもしれません。GitLabの場合は、リポジトリや組織です。

このトリプルは（様々な名前で）認可システムで頻繁に使用されている。例えば、Microsoft Azure の文献では、「Security Principal」（セキュリティプリンシパル）、「Action」（アクション）、「Resource」（リソース）が使用されています。

この構造をアプリケーションに導入する利点は2つあります。第一に、単純なユースケースと複雑なユースケースの両方をカバーするために、認可について一貫した言語を得ることができます。アクターは単純なユーザーである場合もありますが、他のユーザーに権限を委譲したユーザーの代理を務めるサードパーティーアプリケーションである場合もあります。

第二に、これはクリーンなインターフェースの始まりを提供する。単純な認可インターフェースは、トリプル(アクター、アクション、リソース)を受け取り、入力に対して許可または拒否の決定を返します。

#### What Interface To Use For Our Authorization API

ここまでは、認可を 「適用 」する場所に焦点をあててきた。認可とは、入力リクエストを評価し、関連情報を抽出し、これを追加のデータ検索と組み合わせ、ルールとチェックを実装し、さらに許可によってデータをフィルタリングするプロセス全体を指す。

これには2つの重要な部分がある。認可インターフェースは、この2つの境界となるものです。

私たちのインターフェイスがメソッドis_allowed(actor, action, resource)だとします。

例えば、is_allowed(current_user, 「read」, Repository(name: 「acme/anvil」))。

**エンフォースメント(Enforcement)**とは、認可の決定に対して何をすべきかを決定する方法である。これは、先の例で見たようにリクエストからアクターやアクション、そしてリソースを取り出して is_allowed メソッドをコールすることを意味します。

GitClub では、ユーザーが /acme/anvil リポジトリを読む権限を持っていない場合は HTTP 403 Forbidden レスポンスを返すか、別のページにリダイレクトします。その他の実施例としては、データベースフィルタを使用してデータのコレクション全体へのアクセスを制限することなどがあります。

**決定(decision)**とは、認可インターフェースを実装する方法です。入力のトリプル（アクター、アクション、リソース）が与えられたら、結果を返します。先ほどの例では、「acme/anvilはacmeという組織に属しており、ユーザーはその組織のメンバーである。

決定は、必ずしもyes/noのバイナリである必要はなく、さらに他のイベントやチェックに依存したり、警告を発するなどの追加効果があるかもしれません。

![alt text](<assets/CleanShot 2024-10-24 at 23.51.00@2x.png>)

アプリケーションレイヤーやデータベースレイヤーで認可を適用する必要があると述べたのは、主にエンフォースメントについてです。エンフォースメントに関するオプションについては、今後のガイドで取り上げる予定である。しかし、決定は別個のものであり、異なる場所で実装することができる。

#### Options for Implementing Authorization Decisions

認可の決定を行うには、データとロジックという2つの情報が必要である：

1. **認可データ(Authorization Data)**はアクセス制御に使われるアプリケーションデータのサブセットである。例えば、Alice は Acme 組織のメンバーであり、acme/anvil リポジトリは acme 組織に属する。
2. **認可ロジック(Authorization Logic)**は、データ上で表現され、ユーザーがリソース上でアクションを実行することが許可されているかどうかを決定するために使用される抽象的なルールを記述します。例えば、ある組織のメンバーは、その組織に属するリポジトリへのアクセスが許可される。

認可の決定には、集中型と分散型という2つの異なるアプローチがある。中央集権型アプローチでは、認可の決定は、必要なデータへのアクセスを提供され、認可ロジックを入力として受け取る中央機関に委譲される。分散型アプローチでは、アプリケーションはすでにアクセス可能なデータを使用して、認可の決定を自ら行う。

第3の選択肢としてハイブリッド・アプローチがあり、これは分散型アプローチをとるが、複数のサービスやアプリケーションを持つシステムに適用される。

ここでは、この3つの選択肢について、具体的な事例を交えて説明する。

##### Decentralized authorization: keeping authorization in the application

素朴でアドホックな実装から、アプリケーションに組み込まれた認可システムに移行するのが自然な流れです。これは、既存のコードをリファクタリングして、先に提案したインターフェイスによって実施と決定を分離するような形になるかもしれません。

これは、専用のDIY実装であったり、使用しているフレームワークのネイティブ部分であったり、専用の認可ライブラリであったりします。例えば、GitLab の Declarative Policy フレームワーク、Ruby/Rails 用の Pundit、Python/Django 用の django-guardian、（私たちが書いたのでお気に入りですが）クロスランゲージ用の Oso などです。どのようなアプローチを取るにせよ、このアプローチにはいくつかの長所と短所があります。

まず第一に、認可ロジックを別のサービスとしてではなく、アプリケーションの中に保持することは、開発経験を単純化します。アプリケーションに追加するということは、コードやライブラリを追加するということです。権限に変更を加えることは、アプリケーションに変更を加えることと同じであり、同じプロセスを経ます。これは、テストやデバッグのような他の領域にも及びます。

しかし、おそらくアプリケーションにおける認可の最も重要な利点は、意思決定のためのデータへのアクセスである。この例から、決定を行うには、ユーザが特定の組織に属しているかどうかをチェックする必要があります。アプリケーションが既にこのデータを使用している場合、例えば、ウェブアプリケーションが既にユーザの組織をリストアップする方法を知っている場合、認可の決定のためにこの情報を取得するメカニズムが既にあります。

![alt text](<assets/CleanShot 2024-10-24 at 23.54.57@2x.png>)

分散化された認可では、すべてのアプリケーションが認可を決定するために必要なロジックとデータを持つ必要がある。

一方、ウェブ・アプリケーション、API アプリケーション、Git アプリケーションのように複数のアプリケーションがある場合、すべてのアプリケーションで同じ認可ロジックが重複してしまう可能性があります。さらに悪いことに、データを取得するためのロジックが重複してしまうかもしれません。私たちのGitアプリケーションは、認可の決定以外に組織について知る必要はありません。

##### Centralized authorization: adding a service

同じアクタ、アクション、リソースを扱うアプリケーションやサービスが多数ある場合、それらの間で認可コードを重複させるべきではありません。アプリケーションが呼び出す別のサービスを追加することで、認可ロジックを切り離すことができます。

![alt text](<assets/CleanShot 2024-10-24 at 23.55.50@2x.png>)

中央集権モデルでは、アプリケーションは独自のデータを管理し、ロジックはアプリケーションから切り離されるが、中央サービスはすべてのデータにアクセスする必要がある。

中央サービスにはいくつかの明確なオプションがあり、それらは主にアプリケーションデータにアクセスする方法に関連している。

まず、セントラルサービスは、他の既存サービスにリクエストを出すか、データベースに直接アクセスしてデータを取得する、通常のサービスとして構築することができます。このアプローチの欠点は、すべてのサービスとセントラルサービスとの間に、直接的または間接的な結合が生じることです。例えば、セントラル・サービスのAPIを変更する必要がある場合、これは問題となる。

その代わりに、サービスをデータの所有者にするかもしれない。GoogleのZanzibarシステムのように、いくつかのプロダクション認可システムはこれを採用している。この場合、サービスは認可に関連するあらゆるデータの真実の中心的なソースになります。例えば、ユーザーが組織でどのような役割を持っているか、あるいはリポジトリがどの組織に属しているかなどである。

このアプローチの利点は、認可に関する質問に答えるためにこのサービスを最適化できることである。欠点は、すべてのアプリケーションの依存関係になることです。先に提案したシンプルなインターフェースの代わりに、このサービスは他のアプリケーションが必要とするデータを追加で提供する必要がある。

最終的なアプローチは、認可サービスへのリクエストの一部として、関連するアプリケーションデータを含めることである。どのデータが 「関連 」であるかを決定するのは、そもそも認可の決定と同じくらい難しい。前述の例では、関連するデータは、ユーザーが所属するすべての組織とリポジトリであった。

どのアプローチも、別個のサービスを管理する複雑さという点で、いくつかのデメリットを抱えている。

##### Hybrid approach

上記2つの最良の要素を組み合わせた第3のアプローチがある。

ハイブリッド・モデルでは、個々のアプリケーションやサービスが独自のデータとそのデータに対する認可を管理する。しかし、アプリケーションは認可の決定をサポートする他のサービスに依存する。

![alt text](<assets/CleanShot 2024-10-24 at 23.57.35@2x.png>)

ハイブリッドモデルでは、各アプリケーションは自身のデータと関連する認可ロジックだけを管理する。意思決定は必要に応じて他のアプリケーションに委譲される。

これは、モノリス・アプリケーションに複数の小規模な補助サービスがある場合によく見られるモデルです。中央のモノリスがすべてのデータを管理し、他のサービスにはシンプルなエンドポイントを公開します。しかし、これと同じパターンを複数のサービスに適用することもできます。

GitClubの例を見てみよう。おそらくAPIサービスが組織やリポジトリ、ユーザーデータを管理しているのでしょう。しかし Git サービスは、あるユーザーがリポジトリのソースコードを読むことを許可されているかどうかを知る必要がある。そこで、認可の判断をAPIサービスに委ねる。

これを実現するには、単純な認可インターフェースを拡張してより多くの情報を返すようにする必要があります。例えば、APIサービスが/org/1/repo/2へのリクエストの一部として、現在のユーザーがそのリポジトリに対してどのようなパーミッションを持っているかを返すことができれば、Gitサービスはそれを使って些細な認可の判断を下すことができます。

これ以上の権限を配布することもできる。組織データを扱う 「organizations 」サービスを用意して、ユーザーが持つ組織と権限のリストを提供することもできる。

このアプローチの威力は、既存のアーキテクチャの形に自然に従うことだ。つまり、サービスは、あなたが最初に管理するために設計したデータを管理し、認可はその延長線上にある。

#### A Quick Guide To Authorization Data Flow

要約すると、認可の決定にはいくつかの異なるアプローチがある：

1. 分散型アプローチは、すべてのアプリケーションが自身の認可を管理するため、実装が 最も簡単である。これは、少数のアプリケーションや、すでにアプリケーションによって管理されているデータに依存した決定を行う場合に最適なアプローチである。
2. 一元化されたサービスは、複数のアプリケーション間で意思決定ロジックの一貫性を保つのに役立ち、ポリシーの変更を切り離すこともできる。しかし、この欠点は、**決定を行うために多くの認可データを集中管理する必要があることです。このアプローチは、多くのサービスが同じデータセットの認可決定を行う必要がある場合に有効である。**
3. ハイブリッド・アプローチでは、意思決定は個々のアプリケーションに任せるが、必要に応じて他のアプリケーションからその意思決定にアクセスできるようにする。これは、アプリケーション間でロジックとデータの分離のバランスを取るには最適なアプローチであるが、一貫した実装方法が必要である。

### 5. Putting Everything Together

認可を実装するには、以下のコンポーネントが必要である：

1. リクエストを行う人（アクタ）を識別する認証システム。
2. リクエストを受け取り、それを（アクタ、アクション、リソース）に変換し、認可決定プロセスに渡すエンフォースメント。
3. 認可ロジックは、認可データ上で表現される、どのように決定がなされるかを指定する。
4. 認可ロジックとデータとともに、(アクタ、アクション、リソース)を入力として受け取り、決定を返す。
5. 結果のデシジョンは、アクターにレスポンスを返すために、エンフォースメントに よって使用される。

上記の組み合わせは数多くあるが、ほとんどのアプリケーションでは、通常、以下のセットアップを推奨する：

1. IDプロバイダを使って認証を行う。
2. アプリケーション自体で認可を強制する。
3. 認可インタフェースを追加することで、認可ロジックをアプリケーションコードから分離する。
4. 認証データをアプリケーション内に保持する。これは、アプリケーションのサービス数が少ない場合は、単純な分散型モデルを使用して決定を実装するか、複数のサービスを使用する場合はハイブリッド・アプローチを使用することを意味します。

もちろん、各組織は個別にユースケースとトレードオフを評価する必要があります。もしあなたがこの分野を探求しているのであれば、Oso Slackの開発者コミュニティに参加することをお勧めします！当社のコア・エンジニアリング・チームもSlackに参加しており、あなたの質問に喜んでお答えします。アプリケーションに認可を組み込むプロセスを始めたい場合は、Osoを使用し、Osoのドキュメントで詳細を学ぶことができます。

### 6. What's Next

ここまで、認可の実施と決定を実装するためのさまざまなアーキテクチャについて説明してきた。しかし、楽しみはそれだけに留まりません。

認可システムをアプリケーション全体の一部として構築し始めると、他の関連領域が現れ始めます。

例えば、認可情報をエンドユーザーに伝えたいとしたらどうだろうか？このアクションは禁止されています」と言われ続けるのは理想的なユーザーエクスペリエンスではない。そのためには、バックエンドがこの情報をユーザーに返す必要がある。もしユーザーが書き込み権限を持っていないのであれば、変更を加えるオプションを灰色にする。

同様に、組織のメンバがアプリケーションでどのような権限を持っているかを表示する管理者インタフェースを提供したいと思うかもしれません。これには、アプリケーションにどのようなロールが存在するのか、誰が特定のリソースにアクセスできるのか、あるいは、特定のユーザがどのリソースにアクセスできるのかを一覧表示することが含まれます。

これらはすべて、認可をアプリケーション全体の構成要素として考えることを含みます。これらのユースケースの詳細については、今後の章で説明します。

このガイドで使用した単純な例にとどまらず、リポジトリはいくつもの方法で作成、破棄、読み取り、編集することができ、アクセス制御が親リソースのそれに関連する子リソース（課題、Wiki、ブランチなど）を持つこともできます。さらに、パーミッション階層はリソースに限定されません。ユーザーを組織にグループ化し、さらにチームやサブチームにグループ化することができ、アクセス制御のビジネスをさらに複雑にしています。

次回のエントリでは、このようなユースケースに一般的な権限パターンを適用する方法を紹介します。ここでは GitClub を例にとりますが、所有権や階層化されたパーミッション、ネストしたリソースなど、ここで取り上げるパターンは多くのユーザー向けアプリケーションに共通するものです。
