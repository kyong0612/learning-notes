
# [Authorization Enforcement](https://www.osohq.com/academy/microservices-authorization)

モノリスからサービス指向アーキテクチャに移行する場合、それに応じて認可を設計する必要があります。 認証データをサービス間で共有する必要がありますが、その方法は数多くあります。 設計とアーキテクチャの決定にはそれぞれトレードオフがあり、それを理解する必要があります。 それぞれの選択肢とトレードオフをご紹介します。 そして、サービス・アーキテクチャに関する意思決定に役立つヒューリスティックスを提供します。

## 1. How Microservices Make Authorization Complicated

これまでの章では、コード、ロジック、データのすべてが同じアプリケーション内にある場合の認可の構築について説明してきました。ここでは、コード、ロジック、データが異なるサービスに存在するような分散環境で認可を動作させるための課題について説明します。 この章では

1. サービスとは、ネットワークを介してユーザーや他のサービスからアクセスされるコンピュータ、または多くのコンピュータのグループのことである。
2. 多くの小さなサービスで構成されるアプリケーションやAPIは、「マイクロサービス」アーキテクチャを持つ。

この章では、マイクロサービスアーキテクチャにおける認可について説明します。 通常、「マイクロサービス」という用語は、多数の個別のサービスを持つデプロイメントを指しますが、分散環境における構築の課題は、2つのサービスであろうと200のサービスであろうと同じです。 アプリケーション間で内部的に動作する認可を構築するのと、OAuthのような連携認可プロトコルを使ってサードパーティのサービスと安全に統合するのとでは、違いがあります。 この章では前者について説明する。サードパーティとの認可については触れない。

複数のサービスを持つアーキテクチャを採用する理由はたくさんある。 例えば、異なるテクノロジー・スタックを使う必要がある新製品を作りたい場合などだ。 あるいは、ひとつのモノリシックなサービスをより小さなサービスに分割して、各チームがコンポーネントを分離して作業できるようにする必要があるかもしれない。

どのような理由であれ、結果として、アプリケーションは多くの異なるコードベースから構成されることになり、一貫した認証エクスペリエンスを提供する必要がある。

これらの要件は相反する！ 開発者はマイクロサービス・アーキテクチャを使用して異なるサービスを切り離し、チームが別々に作業できるようにするが、権限付与は各サービスで一貫して動作する必要があるため、それらを結合する。

![alt text](<assets/CleanShot 2024-10-29 at 22.11.58@2x.png>)

この問題を実際に見るために、ロールベースのアクセス制御（RBAC）の例を考えてみよう。 複数のサービスを持つアプリでは、ユーザは組織内の複数のロールのいずれかに所属し、そのロールを持ちます。

最低限、各サービスは組織内でメンバが持ちうるロールに合意する必要があります。 どのロールがあるかを知ることに加えて、各サービスは特定のユーザがどのロールを持つかを知る必要があります。

モノリスでは、ローカルのデータベースにユーザーのロールを問い合わせることができます。 この例で、ローカルにデータベースのコピーを持たないサービスのコードを書く場合はどうなるでしょうか？ すべてのデータをトークンで渡しますか？ ユーザがリクエストしたときに、必要なデータをフェッチするために、サービス同士がジャスト・イン・タイムで呼び合うのか？ サービスが認可を決定するために必要なインプットを得たら、どのようにしてこの決定を実施し、その結果をユーザーに伝えるのでしょうか？

これらはすべて、建築に関する有意義な質問であり、最良のアプローチは必ずしも明らかではない。

## 2. Our Example: GitClub Jobs

これらのトレードオフを実際に見てみましょう。 私たちは、既存のGitClub製品を補完する新しい "GitClub Jobs "サービスを構築しています。 GitClubはGitHubやGitLabに似たコードホスティングアプリです。 GitClub Jobsは、開発者がリポジトリにデプロイやコンパイルのタスクを定義し、自動化するための方法です。 GitClub Jobs を使って、新しいコミットごとにテストスイートを実行したり、新しいバージョンをリリースするたびにウェブサービスのビルドとデプロイを自動化することができます。

GitClub Jobsサービスは、私たちのオリジナルのウェブサービスとは全く異なるタイプの作業、つまり任意の計算タスクを実行するために設計されました。 要件が異なるため、GitClub Jobsを新しいサービスとして構築しました。

![alt text](<assets/CleanShot 2024-10-29 at 22.13.47@2x.png>)

この新しいサービスのデータオブジェクトは、ジョブとランである。 ジョブは実行する自動化されたタスクの定義で、ランは与えられたジョブオブジェクトの個々の実行を表します。 例えば、アプリケーションの単体テストを実行したいユーザーは、必要な指示を含む "test "ジョブを定義します。 ユーザーがテストスイートを開始するたびに、Run オブジェクトが作成されます。 このオブジェクトは、成功のステータスと、ログや成果物のようなその他の出力を保持します。

GitClub ジョブズとのやり取りは、新しい `gitclub.dev/$ORGANIZATION/$REPOSITORY/jobs` ページから行います。 このページでは、リポジトリの現在のジョブの概要が表示され、"cancel job" や "restart job" といった基本的な管理作業を行うことができます。

GitClub Jobsは、マイクロサービスで見られる2つの認可のケース、つまり共有認可とサービス固有の認可をカバーしています。 GitClub Jobs の認可モデルには、ユーザーや組織、リポジトリといった GitClub ウェブアプリと共通のオブジェクトがあります。 これらの概念をサービス間で共有する必要があります。 このモデルはまた、ウェブ・アプリケーションが考慮する必要のない、サービス固有のオブジェクト（ジョブやラン）を定義している。

### GitClub Jobs’ Authorization Model

![alt text](<assets/CleanShot 2024-10-29 at 22.15.18@2x.png>)

リポジトリがなければジョブは存在しません。 この関係により、リポジトリで使用するのと同じロールを使用して、ジョブオブジェクトの権限をモデル化することができます。 例えば、リポジトリで "member "ロールを持つユーザーは、関連するすべてのジョブ・オブジェクトに対して、ジョブ・サービスで同じ "member "ロールを持つことになります。

ユーザーは、オーガニゼーションとリポジトリを経由して、ジョブやランとの関係を持っています。 これらのリレーションシップを使用して、以下のポリシーを適用します：

1. リポジトリの「リーダー」ロールを持つユーザーは、そのリポジトリに関連するすべての実行とジョブを表示できます。
2. リポジトリの「メンテナ」ロールを持つユーザーは、そのリポジトリに関連するすべてのジョブの実行をキャンセルおよび再開できます。
3. ユーザーは、自分が作成したジョブの実行をキャンセルおよび再開できます。

求人の概要ページを表示するには、さまざまなデータにアクセスする必要があります。 最低限必要な情報は以下の通りです：

1. どのユーザーがそのジョブを作成したか。
2. そのユーザーが、招待された結果など、リポジトリで直接ロールを持つかどうか。
3. リポジトリが属する組織と、その組織でユーザーがロールを持つかどうか。

これらのうち最初のものはジョブサービスで利用可能ですが、組織とリポジトリのデータはどうでしょうか？ モノリスであれば、これらのデータはすべて1つの場所で利用可能ですが、現在は2つのサービスに分かれています。

このポリシーを実施するためには、2つのサービスがポリシーと認可判断に必要なデータを共有する方法を見つける必要がある。

## 3. How to Share Data Between Services

### Decentralizing or Centralizing your Authorization Model

モノリスを複数のサービスに分割する場合、認可モデルを一元化するか、各サービスに分割するかを決定する必要があります。 この決定は、認可モデルの管理方法に影響します。 また、そのモデルの変更をサービス全体に展開するプロセスにも影響する。

この決定を下す際には、チームの要件も考慮してください。 例えば、他のチームと調整することなく、各チームが自分のサービスの認可モデルを変更できるようにする必要がありますか？

#### Decentralizing Models

認可モデルを分散化する1つの方法は、各サービスに認可ロジックを複製することである。 管理するサービスの数が少ない場合は、この方法が適切でしょう。 このシナリオでは、各サービスは認可モデルの完全なコピーを持つ。 このモデルには、すべてのサービスに共通する要素（ユーザーと組織の関係など）と、サービス固有の要素（ジョブをキャンセルできるユーザーを定義するルールなど）の両方が含まれています。 このアプローチにより、各サービスは他のチームからのインプットを必要とせずに権限モデルを変更することができます。

![alt text](<assets/CleanShot 2024-10-29 at 22.20.34@2x.png>)

ポリシーが大きくなるにつれて、サービス全体で同じ認可ロジックの多くのコピーを管理する必要があります。 特に、各コピーを最新の状態に保つことが重要です。 各サービスに各変更を展開する必要があります。

すべてのサービスコードベースが同じプログラミング言語を使用している場合、認証ロジックを共有ライブラリに分離することができます。 各サービスはこの共有ライブラリに依存する。 このように共有コードを使用することで、あるサービスが自身のポリシーにエラーを持つリスクを取り除くことができる。 この方法は、時間の経過とともに実装がばらばらになるリスクには対処できるが、それでもサービス間のアップデートを調整する必要がある。

#### Centralizing Models

分散システムは、常に一貫して利用できるとは限らない。 多くのサービスにデプロイする場合、サービス間でポリシーの更新がエラーになりやすくなります。 この時点で、認可ポリシーの定義と管理を一元化することは理にかなっている。

![alt text](<assets/CleanShot 2024-10-29 at 22.21.44@2x.png>)

中央集権化にはトレードオフがある。 完全に分散化されたアーキテクチャでは、各サービスはポリシーに対する新しい変更を自由に導入し、個別にテストすることができた。 この集中型の世界では、すべてのサービスに一度に変更を導入する必要がある。 各サービスのエッジケースを事前に予測するのは難しい。 モック・データやテスト・フィクスチャのように、デプロイ前にポリシーの動作をテストする方法を検討する価値はある。

1つのオプションは、アプリケーションの認可決定を処理する特別なサービスを作成することである。 そして各サービスは、認可に関する質問があるたびに、このセントラルAPIを呼び出す。 認可ポリシーをネットワーク上に公開することで、アプリケーションサービスはこの作業をオフロードすることができ、同時に認可ポリシーを管理する単一の場所を提供することができます。 さらに、中央のサービスにより、すべてのクライアントのポリシーを一度に更新することができ、サービスの変更を調整する必要がなくなります。

### Centralizing Data

ポリシーは権限付与の方程式の半分に過ぎない。 いつポリシーを一元化するかという問題は、いつデータを一元化するかという問題よりも簡単です。

それは、データセットのサイズ（ポリシーは通常数百行のテキストであるのに対し、データベースは無制限のサイズである）とデータの更新頻度によるものです。

おそらくポリシーの更新頻度は低いだろう。 一方、ユーザやサービスはアプリケーションのデータを常に変化させます。 さらに、ポリシーは、認可の決定を行うために、多くの異なるデータポイントへのアクセスを必要とするかもしれません。

GitClub Jobsをもう一度見てみましょう。 以下のルールを適用します：

1. リポジトリで「メンバー」ロールを持つユーザーは、そのリポジトリのすべてのジョブを表示できます。
2. リポジトリで「管理者」ロールを持つユーザーは、そのリポジトリのすべてのジョブをキャンセルできます。
3. ユーザーは自分のジョブをキャンセルできます。

このポリシーを実施するためには、ユーザー、ジョブ、そしてそれぞれが所属する組織やリポジトリに関するデータにアクセスする必要があります。 これは多くの異なるインプットだ！ クライアントはユーザーデータをJSON Web Tokenとして渡すことができ、ジョブデータはサービスのローカルで利用できる。 しかし、組織やリポジトリの入力についてはどうでしょうか？

モノリスでは、すべてのデータに一箇所でアクセスできることを保証できる。 残念ながら、マイクロサービスの世界ではそのような保証はありません。 このようなシナリオは、既存のアプリケーションを異なるサービスに分割する際によく見られるもので、分散アプリケーションにおける認可を解決するという基本的な課題を浮き彫りにしている。

このような状況に陥った場合、2つの選択肢がある。既存のテクノロジーを使ってインフラ内でデータを分散させるか、集中型認証サービスを導入してデータを一箇所に集めるかである。

### Distributing Data with Existing Infrastructure

私たちの黄金ルールは、アプリケーションを中心にオーソライゼーションを構築することです。 このルールは、モノリスアーキテクチャであろうとマイクロサービスアーキテクチャであろうと同じです。 そのために、マイクロサービス間でデータを共有するために、どのようなインフラや他のオプションが利用できるかを検討しましょう。

この問題は認可に限ったことではなく、すべてのサービスとデータを共有する必要がある場合は常に発生する。 このため、認可データを配布するために再利用できる既存のインフラがすでにあるかもしれない。

ここにいくつかの選択肢がある：

#### Service-to-service communication

ひとつの選択肢は、サービスがクライアントを模倣して互いのAPIを呼び出し、必要なデータをジャスト・イン・タイムで取得することだ。 こうすることで、承認判断に使用するデータは常に新鮮で信頼できるものになる。

![alt text](<assets/CleanShot 2024-10-29 at 22.26.01@2x.png>)

この素朴なアプローチは、パフォーマンス要件が軽い場合には有効ですが、負荷がかかるとすぐにパフォーマンスが低下します。 多くのサービスからのデータを必要とするリクエストは、このような状況では低速になります。一つのクライアントリクエストが、他のいくつかのリクエストを引き起こし、リクエストの負荷を効果的に増加させます。

サービス間の通信にgRPCを使用している場合のように、サービス間でデータを取得するパフォーマンスの高い方法がある場合は、ぜひそれを使用してください！

#### Authorization tokens

私たちの多くがそうであるように、あなたの組織がまだ高いパフォーマンスと利用可能な分散データベースの問題を解決できていないのであれば、他の選択肢があります。

認可のために各サービスで利用できる必要があるデータが少量しかない場合、各リクエストですべてのデータを渡すことで分散化できます。 これを行う1つの方法は、JSON Webトークン（JWT）のような認可トークンを使用して、各サービス間で安全にデータを渡すことです。

![alt text](<assets/CleanShot 2024-10-29 at 22.27.27@2x.png>)

認証トークンは、その内容の完全性を操作から保護するために暗号署名に依存している。 暗号署名は、攻撃者があるユーザーのトークンを取り出して、別のユーザーを表すように操作することを防ぎます。 多くのアプリケーションは、認可トークンのスコープを制限して、ユーザのIDだけをシリアライズします。 しかし、それは必ずしも必要なことではありません。サービスに他のロールベースのアクセス制御データを含めることができます。

GitClub の例では、あるユーザーが JWT 内で持っているすべての組織のロールを、ユーザー ID と一緒にシリアライズすることができます。 この方法は組織のロールをエンコードするのには適しています。 しかし、この方法はユーザーのリポジトリロールをエンコードする際には役に立ちません。 トークンのサイズには制限があります。特に、HTTPヘッダを介してJWTを渡すと、HTTPのあまり楽しくないヘッダ制限サイズに遭遇することになります。

認可トークンに多くのデータを入れることのもう1つの懸念は、トークンに含まれるデータがすぐに古くなることです。 たとえば、ユーザーが新しい認証トークンを受け取る頻度が低いアプリ（サインイン時など）では、（新しいリポジトリへの招待などの）変更はすぐに表示されません。 その代わりに、ユーザーは変更内容を表示するために認証トークンを更新する必要があります。‍

#### Shared databases

1つのトークンに詰め込める以上の認可データがある場合、それをどこに置くべきか。 一つの選択肢は、認証データ用に共有の専用データベースを使用することである。

企業は通常、信頼性やセキュリティの分離を確保するために、独立したデータストアを持つようにマイクロサービスを設計します。 サービス同士がハード的に依存しないのであれば、それは正しいことだ。

しかし、オーソライゼーションを実装する場合、特にこのデータをすべてのサービスで共有したいと思うだろう。 共有データベースは、このようなシナリオに適したソリューションです。 データベースは、データを保存し、複数の読者がアクセスできるようにするというタスクを、高いパフォーマンスで処理します！ すべてのサービスが認証データを操作する必要がない場合は、データベースのリード・レプリカを使用することで、単一障害点となる中央ホストに依存することなく、サービス間でデータを共有することもできます。

![alt text](<assets/CleanShot 2024-10-29 at 22.30.16@2x.png>)

GitClub Jobs の例では、関連するすべての権限データ（ユーザー ID、組織、リポジトリ関係のデータなど）の管理をウェブサービスに制約することができます。 そうすることで、ウェブサービスに負荷をかけることなく、ジョブサービスがこのデータの読み込み用レプリカを消費できるようになります。

データを複数のデータベース（サービス・ローカルと認可）に分割することの欠点は、すべてのデータベースを一度にクエリできないことです。 以前、認証基準に基づいて結果をフィルタリングするためにJOINを使用していた場合、アプリ内でそれらのJOINをインメモリで再実装する必要があります。 これは時間がかかり、メモリを消費します。

#### Event sourcing and selective data replication

多くのサービスを運営している場合、認証データセット全体のコピーを各サービスにレプリケートすることは、必ずしも意味のあることではない。

そのような場合、Kafkaのようなプラットフォームでイベント・ソーシング・メカニズムを実装することができる。 リソースへの変更を分散イベントストリームに公開し、異なるサービスでそれを利用することができる。 Kafkaのようなイベント・ストリーミング・プラットフォームは、通常、コンシューマがストリーム全体のフィルタリングされた部分をサブスクライブできるようにする。 これによって、サービスは自分たちの認可モデルに関連する変更のみを購読し、自分たち自身の独立したコピーを維持することができる。

イベント・ストリームの使用は、パフォーマンスやその他の理由でアプリケーションを使用してフィルタリングを実装することを除けば、事実上データベースのレプリケーションと同じです。 結果は同じで、ローカル・データ・ソースを使用して、サービスが迅速に承認結果を得ることができます。

#### Authorization-as-a-Service

もし手元に優れたデータ転送メカニズムがないのであれば、認可のためだけにそのメカニズムを導入することは避けよう。

もしここで説明したものがあなたのチームにとって有効でない場合、次善の策として一元化された認可サービスを構築することが考えられる。 将来的に運営するサービスの数を増やしていくのであれば、認可を一元化することも理にかなっています。

この方法と共有データベースのアプローチの決定的な違いは、データの一元化に加えて、ポリシーと意思決定をこの新しいサービスに一元化することです。

新しい中央認証サービスの開発における最大の課題は、データに関するものだ。 具体的には、データを確実に複製するか、一元化するかの問題である。 あなたのアーキテクチャは、この新しいサービスを、そのコンテンツすべてに対する真実の権威あるソースとして定義するか、それとも他の場所からのデータのコピーを含むかによって異なります。

#### Persisting data into the service

分散システムでは、それぞれのサービスに責任と依存関係がある。 GitClubの例では、ウェブサービスがユーザー、組織、リポジトリ、そしてそれらの相互関係を管理します。 ジョブサービスは、ジョブの作成やオーケストレーション、リポジトリからのジョブの実行を担当します。

分散システムにはサービス固有のリレーションシップも存在するため、一元的な認可を行うには、すべてのアプリケーションサービスから認可サービスに情報のコピーをリレーする必要がある。 前述したように、マイクロサービスは通常、信頼性の理由から独自のデータストアを持つ。 このようにデータストアが分かれているため、認可ポリシーに関連するデータを含むデータストアごとに、このレプリケーション設定を繰り返す必要がある。

データレプリケーションの実際の仕組みに関しては、多くのオプションが考えられます。 例えば、リモート認証サービスのHTTPコールに失敗した場合などです。 たとえば、リモートの認証サービスの HTTP 呼び出しが失敗した場合は、ローカルの更新も失敗するはずです。

多くのデータベース技術では、レコードの作成と更新操作を順番にシリアライズする操作ログを公開しています。 この操作ログを使用して、気になるリソースタイプの変更を監視し、その変更を認可サービスにリレーすることができます。 このパターンは、リレーショナルデータベースの内容に基づいて検索インデックスを作成するような、リアルタイムのレプリケーションが重要な場合に使用します。

最悪のケースは、ローカルとリモートのサービス・データの内容が一致しないことです。 リソースがローカルに存在し、中央認証サービスに存在しない場合、ユーザはそのリソースに対して正しいパーミッションを持つことができません。

サービスを追加すると、サービス間の接続数も増加します。 データをレプリケートし、ローカルとリモートのコピーが同期していることを確認することは、信頼できなくなる可能性がある。 中央認証サービスを全面的に採用し、データの権威ある真実のソースとすることで、この頭痛の種を完全に回避することができます。

残念ながら、このアプローチではアプリケーション・サービスの大幅な再編成が必要になる。 以前はリソースのフィルタリングと取得をローカル・データベースに依存していたアプリケーションは、新しい中央認証サービスを呼び出さなければならない。 このアプローチは実用的ですが、マイクロサービス間の厳密な分離を壊してしまいます。

### How much data should you store?

モデルのどの部分を一元化されたデータストアに移すかは、ポリシーの詳細によって決まります。

GitClub Jobs の例では、組織とリポジトリのロールデータとリレーションデータを一元管理するのは理にかなっています。

しかし、サービス固有の属性についてはどうでしょう？ 例えば、ジョブオブジェクトのauthorプロパティを使用して、ユーザーが自分のジョブをキャンセルできるようなルールを実装することができます。 もし認可ルールがこのリレーションシップを利用する唯一のサービスがジョブサービスである場合、中央のサービスにリレーすることは無駄のように思えるかもしれません。 しかし、それは構わない！ そのデータは重要であり、そのデータのサイズがボトルネックになることはめったにない。 中央認証サービスにYES/NOの認証結果を返させたい場合、その判断に関わるすべてのデータにアクセスする必要があります。 中央認可サービスにデータをレプリケートするときは、できる限り寛大にしましょう。 そうすれば、より機能的なポリシーを書くことができる。

こうすることで、将来モデルの拡張がより簡単になるという利点もあります。 例えば、あるジョブから生成されたファイルをユーザーに配布する新しい GitClub Artifacts サービスを作りたいとします。 ジョブが出力する成果物（Artifacts）とそれを作成したユーザー（User）の両方の関係を利用して、非常に厳しいアクセス制御を実装することができます。

### Pre-built options

一元化された認証サービスを構築するのは大変な労力である。 Google、Slack、Airbnbのように独自の認可サービスを構築した企業は、専門チームによる1年以上の労力を要したことが分かっている。

サードパーティの集中型認可サービスを利用することもできる。 Oso Cloud、Ory Keto（Google Zanzibarをベースにしたソリューション）、Aserto（Open Policy Agentをベースにしたソリューション）などが利用可能なオプションの一部だ。 これらのサービスやその他のサービスについては、サービスとしての認可のガイドで詳しく説明している。

## 4. Summary: General Rules for Microservice Authorization

あなたがモノリスを分割し始めたばかりであろうと、マイクロサービスの旅が非常に進んでいようと、ユーザーにシームレスなエクスペリエンスを提供するためには一貫した権限モデルが必要です。

最も重要なことは、パーミッションがユーザーにとって透過的であることです。 ユーザは、モノリスと異なるマイクロサービスの集まりのどちらとやりとりしているのか、区別がつかないはずだ。 これが機能するためには、最終的にサービスが認可に同意する必要がある。

どのようなプランであれ、オーソライゼーションはアプリケーションを中心に構築するものであり、その逆ではない。 このことが何を意味するかは、あなたの具体的な要求や状況によって異なるだろう。

例えば、各ユーザのロールデータが少量しかない場合、おそらくJWTのようなものに格納して各サービスに渡すだけで済むでしょう。 分散環境ですでに効果的なサービス間通信が行われている場合は、その通信を使用して必要な認可データをソースから直接取得することができます。 JWTで実現できるよりも詳細な認可を実施する必要がある場合は、単一のサービスに認可を集中させることを検討してください。

もし、多くの認可データがあり、そのタスクに利用可能な既存のインフラストラクチャがない場合、このデータを格納する中央認可サービスを構築する必要がある。 このようなサービスを運用する上での最大の課題は、そのサービスに含まれるデータが、世界の最新かつ一貫した状態を反映していることを保証することである。

中央認証サービスを構築することを選択した場合、主な優先事項は、さまざまなサービスで発生するすべての変更に合わせてデータを最新の状態に保つことです。 ユーザが新しいリソースを作成するたびに、またユーザにロールを付与するたびに、これらの変更を中央認証データストアにレプリケートする必要があります。 この作業を誤ると、誤った認証結果となり、ユーザをイライラさせることになります。
