# Authorization Academy

ref: <https://www.osohq.com/academy>

- [Authorization Academy](#authorization-academy)
  - [Authorization Academy Introduction](#authorization-academy-introduction)
    - [What Does Authorization Academy Teach?](#what-does-authorization-academy-teach)
  - [What is Authorization?](#what-is-authorization)
    - [1. Authentication vs. Authorization](#1-authentication-vs-authorization)
    - [2. What Authorization Looks Like in an App](#2-what-authorization-looks-like-in-an-app)
      - [Website Architecture](#website-architecture)
      - [The Data Model](#the-data-model)
      - [Our Authorization Goal](#our-authorization-goal)
    - [3. Where To Put Our Authorization Logic](#3-where-to-put-our-authorization-logic)
      - [Initial connection](#initial-connection)
      - [At the proxy](#at-the-proxy)
      - [At the website router](#at-the-website-router)
      - [In the web application/controller](#in-the-web-applicationcontroller)
      - [Extra credit](#extra-credit)
      - [At the database/database connector](#at-the-databasedatabase-connector)
    - [Summary](#summary)
    - [4. Adding Authorization to an Application](#4-adding-authorization-to-an-application)
      - [Naïve Approach](#naïve-approach)
      - [Separating our authorization from our application is difficult](#separating-our-authorization-from-our-application-is-difficult)
      - [Formalizing Our Authorization Model](#formalizing-our-authorization-model)
      - [What Interface To Use For Our Authorization API](#what-interface-to-use-for-our-authorization-api)
      - [Options for Implementing Authorization Decisions](#options-for-implementing-authorization-decisions)
        - [Decentralized authorization: keeping authorization in the application](#decentralized-authorization-keeping-authorization-in-the-application)
        - [Centralized authorization: adding a service](#centralized-authorization-adding-a-service)
        - [Hybrid approach](#hybrid-approach)
      - [A Quick Guide To Authorization Data Flow](#a-quick-guide-to-authorization-data-flow)
    - [5. Putting Everything Together](#5-putting-everything-together)
    - [6. What's Next](#6-whats-next)
  - [Role-Based Access Control (RBAC)](#role-based-access-control-rbac)
    - [1. What Part of the System is Role-Based Authorization?](#1-what-part-of-the-system-is-role-based-authorization)
      - [Enforcement](#enforcement)
    - [Why Use Authorization Models?](#why-use-authorization-models)
    - [Role-Based Access Control (RBAC) Models](#role-based-access-control-rbac-models)
    - [Organizational Roles](#organizational-roles)
      - [What the authorization model is](#what-the-authorization-model-is)
      - [How to implement the model](#how-to-implement-the-model)
      - [When to use this model](#when-to-use-this-model)
    - [Cross-Organization Roles](#cross-organization-roles)
      - [What the authorization model is](#what-the-authorization-model-is-1)
      - [How to implement the model](#how-to-implement-the-model-1)
      - [When to use this model](#when-to-use-this-model-1)
    - [Resource-Specific Roles](#resource-specific-roles)
      - [What the authorization model is](#what-the-authorization-model-is-2)
      - [How to implement the model](#how-to-implement-the-model-2)
      - [When to use this model](#when-to-use-this-model-2)
    - [Custom Roles](#custom-roles)
      - [What the authorization model is](#what-the-authorization-model-is-3)
      - [How to implement the model](#how-to-implement-the-model-3)
      - [When to use this model](#when-to-use-this-model-3)
    - [3. Quick Reference To Choosing An Authorization Model](#3-quick-reference-to-choosing-an-authorization-model)

## [Authorization Academy Introduction](https://www.osohq.com/academy/authorization-academy)

認可アカデミーは、アーキテクチャ、モデリングパターン、実施、テスト、UIレベルでの統合など、認可をアプリケーションに組み込む方法を説明する一連のテクニカルガイドです。このコースを修了すると、認可の仕組みに関するメンタルモデルと、認可をアプリケーションに組み込むためのツールを手に入れることができます。
多くの開発チームがそうであるように、Authorizationにかける時間は必要な分だけにしたいものです。問題は、アプリに認可を組み込む方法について、開発者が利用できる具体的な資料が限られていることです。開発者がこのようなシステムや機能を構築できるように、私たちはオーソリゼーション・アカデミーを執筆しました。
このコースをできるだけ具体的にするために、GitClubというアプリケーションの例をコース全体を通して使います。GitClubはソースコードのホスティング、コラボレーション、バージョン管理のためのウェブサイトです。聞き覚えがあるかもしれません！GitClubの着想は、GitHubやGitLabといった実際のアプリケーションから得たもので、これらは一般的な認可のシナリオのケーススタディとして適しています。
このコースでは、企業間（B2B）のSaaS（Software-as-a-Service）アプリケーションにおける認可に焦点を当てます。このコースは、あらゆるレベルの開発者に役立ちます。初心者の開発者にとっては、Authorizationの基礎をしっかりと身につけることができます。経験豊富なベテランの方には、過去に遭遇したことのある問題へのすっきりとしたアプローチを提供します。
私たちは認可のプロフェッショナルです。このコースは、オーソリゼーション・システムを開発した経験や、スタートアップからフォーチュン100社に名を連ねる企業でオーソリゼーションに携わっている開発者との数十回に及ぶミーティングを基に作成しました。

### What Does Authorization Academy Teach?

このコンテンツは章に分かれており、以下のトピックを取り上げる：
a. 第II章 オーソライゼーションとは何か？認可とは何か: 認可コードを整理する方法
b. 第III章: ロールベースのアクセス制御: アプリ内の権限をUserやAdminのようなロールにグループ化する
c. 第IV章: 関係ベースの制御: 「投稿の作成者はその投稿を編集できる」のように、関係によって権限をグループ化する
d. 第V章： 権限の強制: アプリがアクセスの許可または拒否を決定したら、その決定をどうするか？

私たちは今後の章を計画している：

1. ユーザーインターフェース
2. 認可コードのテスト
3. マイクロサービス間の認可

## What is Authorization?

認可は、アプリケーションで誰が何をできるかを制御するメカニズムです。ユーザが自分のデータにアクセスでき、自分のデータ以外のデータを見ることを許可されないようにする方法です。認可には、どのようなアプリケーション・アーキテクチャにも適合する、共通のアーキテクチャ・パターンがあります。このガイドではそのパターンを紹介します。
認可はすべてのアプリケーションの重要な要素ですが、ユーザからはほとんど見えません。また、大抵の場合、あなたが取り組んでいるコア機能やビジネスロジックとは無関係です。

### 1. Authentication vs. Authorization

多くの人が、認証と認可の両方を指すのに、「auth」という用語をよく使います。しかし、これらは同じものではありません。
認証は、ユーザが誰であるかを検証するメカニズムです。アプリケーションのフロントドアです。例えば、ユーザー名とパスワードは、一緒になってID（ユーザー名）と検証方法（パスワードを知っているか）を構成する。その他の認証形式としては、OAuthやOpenID Connect（OIDC）がある。OIDCは、「Googleでログイン」や「Facebookでログイン」のような機能を追加するためによく使われ、SAMLは、企業が従業員に複数のアプリ間で単一のログインを与えるために使う標準である。

認可とは、ユーザーができることをコントロールするメカニズムである。認証がフロントドアであるなら、認可は、ユーザが中に入ってから開けられるドアを制御する。
認可はしばしば認証の上に構築され、この2つが最も密接に重なり合うのは、ユーザが誰であるかという情報が、そのユーザができることを決定するための入力となる場合である。例えば、あるユーザーが認証されると、そのユーザー名を使って権限を調べたり、他の属性に基づいて権限を推測したりすることができます。

このコースでは、認証に焦点を当て、関連する場合のみ認証に触れます。このコースでは、あなたが認証システムを導入しているか、他の場所で入手可能なガイダンスに従って認証システムをセットアップできることを前提としています。

### 2. What Authorization Looks Like in an App

私たちは、理論だけでなく、オーソライゼーションの実践例をお見せしたいと思います。そのために、各コンセプトを実証できるサンプルアプリを作りました。

GitClub は、ソースコードのホスティング、コラボレーション、バージョン管理のためのウェブサイトです。これは、現実のgitホストであるGitHubやGitLabによく似ています。GitClubは、そもそも権限付与の動機となるもの、つまりリソースへのアクセスを確保することの純粋な例を提供しています。GitClubのリソースの一つはリポジトリで、リポジトリにはアクセス制限があります。ユーザーはリポジトリを読んだり変更したりすることができるかもしれませんし、できないかもしれません。つまり、認可が必要なのです！

#### Website Architecture

まずは、GitLab のみなさんが提供している素晴らしいドキュメントを参考に、妥当なサービスのアーキテクチャを考えてみましょう。複雑そうに見えるかもしれませんが、心配はいりません！このアーキテクチャの中で認可がどのような位置づけにあるのかを説明しながら、徐々に複雑な部分を取り除いていきます。

![alt text](<assets/CleanShot 2024-10-24 at 23.22.52@2x.png>)

上の図は、私たちのアーキテクチャの主な部分を含んでいます。

gitclub.devは3種類のトラフィックを処理します：

1. ウェブサイトへの訪問。これは、gitclub.comのフロントページの内容のようなHTMLをブラウザに返します。
2. APIリクエスト。これは、ユーザーやサードパーティの統合機能からのデータのリクエストを処理し、JSON やその他の構造化されたデータ形式を返します。
3. git clone <<https://gitclub.dev/oso/authzacademyのような> Git 接続。SSH または HTTP 接続です。

すべてのリクエストは1つのポイントに接続される。プロキシはウェブサーバーの代わり（「プロキシ」）をするので、この名前がついた。プロキシは接続を適切な場所にリダイレクトします。完全なシステムでは、プロキシはロードバランサーや認証プロキシのような多くの部分から構成される。

ウェブサイトとAPIはデータベース（DB）にアクセスすることができる。

APIとGit接続はファイルシステム（FS）にアクセスし、そこにGitリポジトリが保存されます。

認証のために(注意: 認証と認可の違いについてはイントロダクションを参照)、ウェブアプリケーションは単純なユーザ名とパスワードの仕組みを使ってユーザを認証します。最初の認証の後、ウェブアプリケーションはユーザーにトークンを返し、その後のリクエストでパスワードを再入力する必要がないようにします。Webアプリケーションでは、APIアプリケーションとやりとりするためのAPIトークンを作成することもできる。これらのトークンは「**ベアラートークン**」と呼ばれ、トークンの持ち主にアクセスを許可する軽量なトークンです。

Gitサービスは、ウェブ・アプリケーションと同じユーザー名とパスワードのペアを用いて認証を行う。

余談：モノリス対マイクロサービス

ここでの例のアーキテクチャはかなりモノリシックだ。実行中のアプリケーションは数個だけだ。マイクロサービスについては、いくつかの違いがあり、それらに遭遇したときに呼び出すことにする。

#### The Data Model

このシステムには多くのGitリポジトリがある。
組織では、リポジトリへのグループ・アクセスを許可しています。組織（会社やオープンソースのグループなど）は多くのリポジトリを持つことができます。各組織は多くのユーザーを持つことができます。

一人の個人はユーザーによって表されます。ユーザーは多くの組織に属することができます。(org:user = N:N)

#### Our Authorization Goal

私たちのシステム全体で、1つの権限ルールを適用します。ユーザーがリポジトリにアクセスできるのは、そのリポジトリを所有する組織に属している場合のみです。
後でルールを追加します！

### 3. Where To Put Our Authorization Logic

さて、アーキテクチャの概要がわかったところで、リクエストがアプリケーションのコンポーネントを通過するのを追いかけて、どこで認証が行われるのかを考えてみましょう。
ある GitClub ユーザー 「<alice@acme.org>」 がウェブインターフェイスからアプリケーションにアクセスしています。彼らが特定のリポジトリ、例えば <<https://gitclub.dev/acme/anvilのページにアクセスしようとしたとしましょう。どうなるでしょうか？>

彼らは以前にパスワードで認証されているので、リクエストにはトークンが認証情報として含まれています。この場合、acmeは組織であり、ユーザはその組織のメンバーなので、ユーザはこのリポジトリへのアクセスを許可されています。

インフラを通してリクエストを追跡するとき、認可の3つの主要な側面に戻ってくる：

1. 誰がリクエストしているのか？
2. 彼らは何をしようとしているのか？ (What are they trying to do?)
3. 何をしようとしているのか？ (What are they doing it to?)

#### Initial connection

まず最初に、ユーザーのブラウザが私たちの外部向けプロキシと接続を行います。

誰がリクエストしているのか?

-リクエストをするUserの身元はまだわからない。そうするにはリクエストからトークンを取り出す必要がある。おそらくIPアドレスはわかっているでしょう。

彼らは何をしようとしているのか?

-TLS接続の確立。

接続先は?

-ホスト: gitclub.dev on port 443.

アプリケーションの認可はまだ行っていませんが、ネットワークレベルの認可を行うことは可能です。IPアドレスの許可リストを作るとか、あるいは相互のTLSを要求するとか（これはやや議論の余地がありますが）。

#### At the proxy

プロキシは、必要に応じてウェブサーバ、APIサーバ、Gitサーバにトラフィックを誘導するように設定される。これら三つのサーバーは、最終的にはある程度のユーザー認証を行う必要があります。先ほど説明したように、認証にはユーザー名とパスワードの組み合わせかベアラートークンが使われます。

認証を必要とするダウンストリームサービスが多数ある場合、認証プロキシを追加する価値は高くなる。例えば、WebアプリケーションとAPIアプリケーションは、ほとんどのルートにアクセスするためにトークンを必要とする。トークンの検証をプロキシで処理すれば、次のような認証ができる：

リクエストをするのは誰か？

プロキシはリクエストに含まれるトークンを検証する。トークンはさらにユーザに関する情報を含むかもしれない。例えば、JSON Web Token (JWT)のように、JSONでエンコードされたデータを使うかもしれません。

デコードされたトークンが次のようなものだとする：

```json
{
    "email": "alice@acme.org",
    "valid_until": "2024-10-24T23:22:52Z",
    etc... 
}
```

それなら、ユーザーは 「<<alice@acme.org>」だとわかる。

彼らは何をしようとしているのか？

HTTPリクエストを検査することで、ユーザーがGETリクエストをしていることがわかります。

彼らは何に対してGETリクエストをしているのでしょうか?

繰り返しますが、HTTPリクエストを検査することで、URLは/acme/anvilです。

私たちが知っていることに基づいて認可を実行できますか?

どのような認可を適用したいかによる。リクエストに存在する情報だけが与えられれば、ルートレベルで適用される認可だけを行うことができます。ユーザ「<alice@acme.org>」は/acme/anvilへのGETリクエストを許可されていますか?

ユーザに関する唯一の情報はメールアドレスです。すべてのユーザは /<owner>/<repository形式のパスに GET リクエストを行うことができます。

しかし、もし私たちが完全な要件 - ユーザーはリポジトリと同じ組織でなければならない - を実施したいのであれば、十分な情報がありません。どうすればその情報を得ることができるでしょうか？トークンにどんどん情報を追加していくことも考えられます。あるいは、データベースにアクセスするようにプロキシを設定することもできます。この方法はProxyをかなり複雑にし、Databaseアクセスロジックを重複させます。

しかし、プロキシは、レート制限ユーザー、APIキーまたは認証の要求、Webアプリケーションファイアウォール（WAF）に見られるような悪意のあるペイロードのスキャンなど、認可に関連する懸念を適用するのに適した候補である。

#### At the website router

![alt text](<assets/CleanShot 2024-10-24 at 23.31.17@2x.png>)

プロキシについては説明した！Webサイトとデータベースに移りましょう。

最後に、認証されたリクエストはWebアプリケーションのルータに到達し、ルータがリクエストの処理方法を決定します。この時点で、認証ミドルウェアがリクエストで提供されたIDをデータベースから取得したデータモデルに変換するのが一般的です。

リクエストを行うのは誰か？

-認証ミドルウェアがリクエストで提供されたIDをUserオブジェクトに変換し、Userについて知りたいことすべてにアクセスできるようにしたと仮定しましょう。

彼らは何をしようとしているのでしょうか？

-まだHTTPリクエスト・オブジェクトを使っており、HTTPメソッドはGETである。

何のために？

ここにはまだリクエストオブジェクトとパスしかない： 「/acme/anvil"。

アプリケーションデータにアクセスできるので、関連する情報を調べることができます。たとえば、既存のロジックを使って、/acme/anvilに対応する組織を調べ、ユーザがその組織に属しているかどうかを見ることができます。

しかし、これは次のステップのコントローラ層で行う必要があることとほぼ同じです。コントローラはリクエストを受け取り、データを検索し、必要なデータ操作を行い、ビジネスロジックを適用します。

したがって、ミドルウェアで認可を行うというアプローチを取ろうとすると、 ロジックが重複してしまい、データベースへの呼び出しが重複する可能性があります。

このレイヤで認可を行うことが意味のあるシナリオがいくつかある：

1. 単純なルートレベルのプロパティをチェックすることで、認可に徹底的な防御アプローチを適用する。たとえば、ウェブサイトの /admin/... に管理者専用の領域があり、User オブジェクトに管理者権限が保存されている場合、このチェックを素早く適用できます。
2. リクエストの処理のどこかで、おそらくアプリケーションのより深いレイヤーで、認可が実行されたことを確認する。これは、粗いルートレベルの懸念だけをカバーするという制限を受けずに、 認証がどこでも適用されることを保証するという利点を得ることができます。
3. リクエストルーティングとデータアクセスが密接に結合しているアプリケーション。例えば、データベースの前に薄いRESTやGraphQLインターフェイスを持つAPI駆動型アプリケーションなどである。この場合、RouterとControllerのレイヤーは実質的に1つのレイヤーに圧縮され、認可は両方に同時に適用することができる。詳しくは次で説明する。

#### In the web application/controller

Webルータは、GET /acme/anvilをコントローラのメソッドにマッピングします。このメソッドを view_repository(owner: 「acme」, name: 「anvil」) とします。

このメソッドでは、/acme/anvil のウェブページを表示するために必要なデータを照合し、そのデータをビューに渡します。GitClub ではシンプルなコードにこだわっているので、ページのレンダリングもサーバーサイドで行っています。UI のデータをすべて取得し、ユーザー用のテンプレートをレンダリングします。

あまり細かいことは省きますが、おそらくリポジトリビューにはソースコードや課題、プルリクエスト、投稿者などのほか、リポジトリそのものの基本的な情報が含まれることになるでしょう。

最終的に、ユーザーに表示されるデータはすべて認可されたものでなければなりません。そもそも彼らはリポジトリを見ることができるのでしょうか？ページ上のすべての追加データはどうでしょうか？

誰がリクエストしているのでしょうか？ (Who is making the request?)

-前のステップから、Userオブジェクトは認証ミドルウェアの一部としてフェッチされたと仮定できます。

彼らは何をしようとしているのでしょうか？ (What are they trying to do?)

-リポジトリページを表示し、リポジトリ情報にアクセスします。コントローラメソッド内で、Userが何をしようとしているのかがわかります。

ユーザが何をしようとしているのか? (What are they doing it to?)

-acme/anvilリポジトリです。いずれにせよ、メソッドの一部としてデータベースから取得します。

ようやく、すべてのカモが揃ったようだ。必要なデータはすべて揃っており、ユーザーが何を達成しようとしているのかも正確に分かっている。アンビルリポジトリはacmeという組織が所有しており、ユーザーはその組織のメンバーです！彼らにこれを読ませるべきだ。

#### Extra credit

しかし、まだある！

ビューのレンダリングの一部としてアクセスされるすべての補助データはどうでしょうか？リポジトリメンバー、課題、コメントなど。これらはすべてユーザーに見えるのでしょうか？

まあ、必要に応じてアクセス制御を決定し続けることができます。私たちは関連するすべての情報にアクセスすることができ、ユーザの代わりにどのデータを取得しようとしているのかを知ることができます。

ここでさらに踏み込むことができます。ユーザーはリポジトリの管理者ではないので、リポジトリの設定を行うアクセス権を持っていないとします。つまり、この情報をビューレンダラに返すことで、ページからそのオプションを非表示にすることができます。これについては、今後のガイドで詳しく説明します。

ユーザーがリポジトリの閲覧を許可されていない場合、役立つ情報を表示するビューをレンダリングしたり、「Forbidden」 レスポンスを返したりするのに理想的です。

#### At the database/database connector

データベースからデータをフェッチするときです。SQLクエリそのもの（ミドルウェアやクエリプロキシを使って）、あるいはデータベース内です。

誰がリクエストしているのか？ (Who is making the request?)

クエリコンテキストにユーザの情報を含めることができます。

ユーザは何をしようとしているのか？ (What are they trying to do?)

SQLのSELECT文を実行する。

何をしようとしているのか？ (What are they doing it to?)

名前=「acme/anvil 」でフィルタリングされたリポジトリテーブル。

データアクセスレイヤーに入ったので、必要なアプリケーションコンテキストをデータベース接続/リクエスト、またはデータベースクエリに含める必要があります。

強制したいロジックを思い出してください：

ユーザーは、リポジトリと同じ組織に所属していれば、リポジトリを読むことができます。

このルールはSQLクエリとして簡単に表現できるため、データレイヤーはこのルールを強制するのに理想的な場所です。この場合、repositoriesテーブルでSELECT文を実行するときに、organization_membersテーブルでjoinし、ユーザと同じ組織に属するリポジトリだけを選択することができます。

![alt text](<assets/CleanShot 2024-10-24 at 23.40.12@2x.png>)

このアプローチの利点は、Yes/Noの認可クエリに答える以上のことができることです。例えば、同じフィルタを適用することで、ユーザがホームページで閲覧できる全てのリポジトリをリストアップすることができます。

ここでの課題は、アプリケーション内で処理するSQL文の構築と管理のロジックを重複させることなく、認可のためのクエリフィルタを生成する方法です。このため、アプリケーションの他の場所で使われているのと同じメカニズムを使うことで、認可フィルタを実装するのが最も理にかなっていることがよくあります。

### Summary

まとめると、認可を適用する場所にはいくつかの候補がある：

1. ネットワーク層。このレイヤーのデータは非常に限られており、許可/拒否リストのような単純なネットワークアクセス制御手段しか使えない。ここでは認可に焦点を当てるべきでない。
2. プロキシまたはルータ。一般的に、より詳細なアクセス制御を行うには、認可を決定するためにサービスやデータベースを呼び出す必要があります。
3. アプリケーション/コントローラ。ここではすべての情報が利用可能なので、認可要件を簡単に適用できます。認可ロジックを配置する場所としては、ここがよいでしょう。
4. データベース: アプリケーションがデータベースフィルタを生成する場合、ここで認可を適用できます。これは、アクセスに関してより広範な質問をすることができるので、**可能であれば、ここで認可を実施するのがベストです**。

なぜなら、ユーザーが何をしようとしているのかという正確なコンテキストと、判断を下すために利用可能なデータが最も多く存在するからである。

### 4. Adding Authorization to an Application

これまで、アーキテクチャのどこで認可を適用するかについて説明してきた。多くの場合、アプリケーションの中で認可を適用し、アプリケーションのコンテキストに完全にアクセスできるようにしたい。

しかし、どのように認可を設計し、実装し、実行するのでしょうか？

#### Naïve Approach

多くの人は、開発を始めるとき、別の開発ステップとして「認可を実装する」ことはしない。彼らは単純に、必要だと思われるチェックをアプリケーションコードに追加するだけです。これが一般的な理由は、ロジックが単純に感じられるからです。それがそこにあることに気づかないかもしれない！例えば、データベースクエリの一部として、ユーザーIDや組織IDによってすべてのリポジトリをフィルタリングすることができます。アプリケーション・コンテキストがすぐそこにあるので、この方法で実装するのは簡単です。

しかし、これはすぐに難しくなります。認可を適用する必要がある場所が増えてくると、同じロジックを重複させてしまうことになる。変更を加えるには、ロジックが重複しているすべての場所を覚えておく必要がある。

前の例では、ユーザーがAcme組織のメンバーである場合にのみ、/acme/anvilページを見ることができるようにしました。同じロジックが/acme/anvil/issuesや/acme/anvil/membersなどの他のサブページにも適用されます。これらのページを処理する各メソッドは、同じロジックを繰り返す必要がある。

ここで、特定のリポジトリで共同作業を行うために、組織外のユーザーを招待する機能を追加するとします。このチェックを認可ハンドラに追加する必要があります。ナイーブなケースでは、リポジトリページを扱うすべてのメソッドを意味します。

#### Separating our authorization from our application is difficult

アプリケーション・ロジックの他の部分と同じように、「懸念事項の分離」を適用し、認可をアプリケーション・ロジックから独立して書きたい。これは意外と難しいことがわかりました！ 最初は、すべてのリポジトリビューをリファクタリングして、最初にリポジトリを読み込んで権限をチェックするようにするかもしれません。組織の管理者だけが/acme/anvil/settingsへのアクセスを許可されています。そのため、組織の管理者に関する情報も含めるように、リポジトリの抽象化を修正する必要があります。認可はアプリケーションと深く関わっているため、認可をビジネスロジックから切り離すためのきれいなインターフェイスを考えるのは難しいかもしれません。

どうすればより良いものを設計できるでしょうか？

#### Formalizing Our Authorization Model

上記の例のセクションで、オーソライゼーションの判断はしばしば次のように組み立てられると述べた：

1. 誰がリクエストしているのか(Who is making the request)
2. 何をしようとしているのか(What are they trying to do)
3. 何をしようとしているのか(What are they doing it to)
オーソライゼーションについて書く場合、これらのそれぞれについて正式な用語があります。

「誰が」は**行為者(actor)**と呼ばれる。多くの場合、この行為者はアプリケーションの単なるユーザです。

「何をしようとしているか」は、多くの場合、単純な動詞に帰着します。例えば、APIで一般的なcreate、read、update、delete（CRUD）などです。私たちはこれらの**アクション(action)**をこう呼びます。

「何に対してそれを行っているか」が**リソース(resource)**です。
これは、アプリケーション内の特定のオブジェクトかもしれません。GitLabの場合は、リポジトリや組織です。

このトリプルは（様々な名前で）認可システムで頻繁に使用されている。例えば、Microsoft Azure の文献では、「Security Principal」（セキュリティプリンシパル）、「Action」（アクション）、「Resource」（リソース）が使用されています。

この構造をアプリケーションに導入する利点は2つあります。第一に、単純なユースケースと複雑なユースケースの両方をカバーするために、認可について一貫した言語を得ることができます。アクターは単純なユーザーである場合もありますが、他のユーザーに権限を委譲したユーザーの代理を務めるサードパーティーアプリケーションである場合もあります。

第二に、これはクリーンなインターフェースの始まりを提供する。単純な認可インターフェースは、トリプル(アクター、アクション、リソース)を受け取り、入力に対して許可または拒否の決定を返します。

#### What Interface To Use For Our Authorization API

ここまでは、認可を 「適用 」する場所に焦点をあててきた。認可とは、入力リクエストを評価し、関連情報を抽出し、これを追加のデータ検索と組み合わせ、ルールとチェックを実装し、さらに許可によってデータをフィルタリングするプロセス全体を指す。

これには2つの重要な部分がある。認可インターフェースは、この2つの境界となるものです。

私たちのインターフェイスがメソッドis_allowed(actor, action, resource)だとします。

例えば、is_allowed(current_user, 「read」, Repository(name: 「acme/anvil」))。

**エンフォースメント(Enforcement)**とは、認可の決定に対して何をすべきかを決定する方法である。これは、先の例で見たようにリクエストからアクターやアクション、そしてリソースを取り出して is_allowed メソッドをコールすることを意味します。

GitClub では、ユーザーが /acme/anvil リポジトリを読む権限を持っていない場合は HTTP 403 Forbidden レスポンスを返すか、別のページにリダイレクトします。その他の実施例としては、データベースフィルタを使用してデータのコレクション全体へのアクセスを制限することなどがあります。

**決定(decision)**とは、認可インターフェースを実装する方法です。入力のトリプル（アクター、アクション、リソース）が与えられたら、結果を返します。先ほどの例では、「acme/anvilはacmeという組織に属しており、ユーザーはその組織のメンバーである。

決定は、必ずしもyes/noのバイナリである必要はなく、さらに他のイベントやチェックに依存したり、警告を発するなどの追加効果があるかもしれません。

![alt text](<assets/CleanShot 2024-10-24 at 23.51.00@2x.png>)

アプリケーションレイヤーやデータベースレイヤーで認可を適用する必要があると述べたのは、主にエンフォースメントについてです。エンフォースメントに関するオプションについては、今後のガイドで取り上げる予定である。しかし、決定は別個のものであり、異なる場所で実装することができる。

#### Options for Implementing Authorization Decisions

認可の決定を行うには、データとロジックという2つの情報が必要である：

1. **認可データ(Authorization Data)**はアクセス制御に使われるアプリケーションデータのサブセットである。例えば、Alice は Acme 組織のメンバーであり、acme/anvil リポジトリは acme 組織に属する。
2. **認可ロジック(Authorization Logic)**は、データ上で表現され、ユーザーがリソース上でアクションを実行することが許可されているかどうかを決定するために使用される抽象的なルールを記述します。例えば、ある組織のメンバーは、その組織に属するリポジトリへのアクセスが許可される。

認可の決定には、集中型と分散型という2つの異なるアプローチがある。中央集権型アプローチでは、認可の決定は、必要なデータへのアクセスを提供され、認可ロジックを入力として受け取る中央機関に委譲される。分散型アプローチでは、アプリケーションはすでにアクセス可能なデータを使用して、認可の決定を自ら行う。

第3の選択肢としてハイブリッド・アプローチがあり、これは分散型アプローチをとるが、複数のサービスやアプリケーションを持つシステムに適用される。

ここでは、この3つの選択肢について、具体的な事例を交えて説明する。

##### Decentralized authorization: keeping authorization in the application

素朴でアドホックな実装から、アプリケーションに組み込まれた認可システムに移行するのが自然な流れです。これは、既存のコードをリファクタリングして、先に提案したインターフェイスによって実施と決定を分離するような形になるかもしれません。

これは、専用のDIY実装であったり、使用しているフレームワークのネイティブ部分であったり、専用の認可ライブラリであったりします。例えば、GitLab の Declarative Policy フレームワーク、Ruby/Rails 用の Pundit、Python/Django 用の django-guardian、（私たちが書いたのでお気に入りですが）クロスランゲージ用の Oso などです。どのようなアプローチを取るにせよ、このアプローチにはいくつかの長所と短所があります。

まず第一に、認可ロジックを別のサービスとしてではなく、アプリケーションの中に保持することは、開発経験を単純化します。アプリケーションに追加するということは、コードやライブラリを追加するということです。権限に変更を加えることは、アプリケーションに変更を加えることと同じであり、同じプロセスを経ます。これは、テストやデバッグのような他の領域にも及びます。

しかし、おそらくアプリケーションにおける認可の最も重要な利点は、意思決定のためのデータへのアクセスである。この例から、決定を行うには、ユーザが特定の組織に属しているかどうかをチェックする必要があります。アプリケーションが既にこのデータを使用している場合、例えば、ウェブアプリケーションが既にユーザの組織をリストアップする方法を知っている場合、認可の決定のためにこの情報を取得するメカニズムが既にあります。

![alt text](<assets/CleanShot 2024-10-24 at 23.54.57@2x.png>)

分散化された認可では、すべてのアプリケーションが認可を決定するために必要なロジックとデータを持つ必要がある。

一方、ウェブ・アプリケーション、API アプリケーション、Git アプリケーションのように複数のアプリケーションがある場合、すべてのアプリケーションで同じ認可ロジックが重複してしまう可能性があります。さらに悪いことに、データを取得するためのロジックが重複してしまうかもしれません。私たちのGitアプリケーションは、認可の決定以外に組織について知る必要はありません。

##### Centralized authorization: adding a service

同じアクタ、アクション、リソースを扱うアプリケーションやサービスが多数ある場合、それらの間で認可コードを重複させるべきではありません。アプリケーションが呼び出す別のサービスを追加することで、認可ロジックを切り離すことができます。

![alt text](<assets/CleanShot 2024-10-24 at 23.55.50@2x.png>)

中央集権モデルでは、アプリケーションは独自のデータを管理し、ロジックはアプリケーションから切り離されるが、中央サービスはすべてのデータにアクセスする必要がある。

中央サービスにはいくつかの明確なオプションがあり、それらは主にアプリケーションデータにアクセスする方法に関連している。

まず、セントラルサービスは、他の既存サービスにリクエストを出すか、データベースに直接アクセスしてデータを取得する、通常のサービスとして構築することができます。このアプローチの欠点は、すべてのサービスとセントラルサービスとの間に、直接的または間接的な結合が生じることです。例えば、セントラル・サービスのAPIを変更する必要がある場合、これは問題となる。

その代わりに、サービスをデータの所有者にするかもしれない。GoogleのZanzibarシステムのように、いくつかのプロダクション認可システムはこれを採用している。この場合、サービスは認可に関連するあらゆるデータの真実の中心的なソースになります。例えば、ユーザーが組織でどのような役割を持っているか、あるいはリポジトリがどの組織に属しているかなどである。

このアプローチの利点は、認可に関する質問に答えるためにこのサービスを最適化できることである。欠点は、すべてのアプリケーションの依存関係になることです。先に提案したシンプルなインターフェースの代わりに、このサービスは他のアプリケーションが必要とするデータを追加で提供する必要がある。

最終的なアプローチは、認可サービスへのリクエストの一部として、関連するアプリケーションデータを含めることである。どのデータが 「関連 」であるかを決定するのは、そもそも認可の決定と同じくらい難しい。前述の例では、関連するデータは、ユーザーが所属するすべての組織とリポジトリであった。

どのアプローチも、別個のサービスを管理する複雑さという点で、いくつかのデメリットを抱えている。

##### Hybrid approach

上記2つの最良の要素を組み合わせた第3のアプローチがある。

ハイブリッド・モデルでは、個々のアプリケーションやサービスが独自のデータとそのデータに対する認可を管理する。しかし、アプリケーションは認可の決定をサポートする他のサービスに依存する。

![alt text](<assets/CleanShot 2024-10-24 at 23.57.35@2x.png>)

ハイブリッドモデルでは、各アプリケーションは自身のデータと関連する認可ロジックだけを管理する。意思決定は必要に応じて他のアプリケーションに委譲される。

これは、モノリス・アプリケーションに複数の小規模な補助サービスがある場合によく見られるモデルです。中央のモノリスがすべてのデータを管理し、他のサービスにはシンプルなエンドポイントを公開します。しかし、これと同じパターンを複数のサービスに適用することもできます。

GitClubの例を見てみよう。おそらくAPIサービスが組織やリポジトリ、ユーザーデータを管理しているのでしょう。しかし Git サービスは、あるユーザーがリポジトリのソースコードを読むことを許可されているかどうかを知る必要がある。そこで、認可の判断をAPIサービスに委ねる。

これを実現するには、単純な認可インターフェースを拡張してより多くの情報を返すようにする必要があります。例えば、APIサービスが/org/1/repo/2へのリクエストの一部として、現在のユーザーがそのリポジトリに対してどのようなパーミッションを持っているかを返すことができれば、Gitサービスはそれを使って些細な認可の判断を下すことができます。

これ以上の権限を配布することもできる。組織データを扱う 「organizations 」サービスを用意して、ユーザーが持つ組織と権限のリストを提供することもできる。

このアプローチの威力は、既存のアーキテクチャの形に自然に従うことだ。つまり、サービスは、あなたが最初に管理するために設計したデータを管理し、認可はその延長線上にある。

#### A Quick Guide To Authorization Data Flow

要約すると、認可の決定にはいくつかの異なるアプローチがある：

1. 分散型アプローチは、すべてのアプリケーションが自身の認可を管理するため、実装が 最も簡単である。これは、少数のアプリケーションや、すでにアプリケーションによって管理されているデータに依存した決定を行う場合に最適なアプローチである。
2. 一元化されたサービスは、複数のアプリケーション間で意思決定ロジックの一貫性を保つのに役立ち、ポリシーの変更を切り離すこともできる。しかし、この欠点は、**決定を行うために多くの認可データを集中管理する必要があることです。このアプローチは、多くのサービスが同じデータセットの認可決定を行う必要がある場合に有効である。**
3. ハイブリッド・アプローチでは、意思決定は個々のアプリケーションに任せるが、必要に応じて他のアプリケーションからその意思決定にアクセスできるようにする。これは、アプリケーション間でロジックとデータの分離のバランスを取るには最適なアプローチであるが、一貫した実装方法が必要である。

### 5. Putting Everything Together

認可を実装するには、以下のコンポーネントが必要である：

1. リクエストを行う人（アクタ）を識別する認証システム。
2. リクエストを受け取り、それを（アクタ、アクション、リソース）に変換し、認可決定プロセスに渡すエンフォースメント。
3. 認可ロジックは、認可データ上で表現される、どのように決定がなされるかを指定する。
4. 認可ロジックとデータとともに、(アクタ、アクション、リソース)を入力として受け取り、決定を返す。
5. 結果のデシジョンは、アクターにレスポンスを返すために、エンフォースメントに よって使用される。

上記の組み合わせは数多くあるが、ほとんどのアプリケーションでは、通常、以下のセットアップを推奨する：

1. IDプロバイダを使って認証を行う。
2. アプリケーション自体で認可を強制する。
3. 認可インタフェースを追加することで、認可ロジックをアプリケーションコードから分離する。
4. 認証データをアプリケーション内に保持する。これは、アプリケーションのサービス数が少ない場合は、単純な分散型モデルを使用して決定を実装するか、複数のサービスを使用する場合はハイブリッド・アプローチを使用することを意味します。

もちろん、各組織は個別にユースケースとトレードオフを評価する必要があります。もしあなたがこの分野を探求しているのであれば、Oso Slackの開発者コミュニティに参加することをお勧めします！当社のコア・エンジニアリング・チームもSlackに参加しており、あなたの質問に喜んでお答えします。アプリケーションに認可を組み込むプロセスを始めたい場合は、Osoを使用し、Osoのドキュメントで詳細を学ぶことができます。

### 6. What's Next

ここまで、認可の実施と決定を実装するためのさまざまなアーキテクチャについて説明してきた。しかし、楽しみはそれだけに留まりません。

認可システムをアプリケーション全体の一部として構築し始めると、他の関連領域が現れ始めます。

例えば、認可情報をエンドユーザーに伝えたいとしたらどうだろうか？このアクションは禁止されています」と言われ続けるのは理想的なユーザーエクスペリエンスではない。そのためには、バックエンドがこの情報をユーザーに返す必要がある。もしユーザーが書き込み権限を持っていないのであれば、変更を加えるオプションを灰色にする。

同様に、組織のメンバがアプリケーションでどのような権限を持っているかを表示する管理者インタフェースを提供したいと思うかもしれません。これには、アプリケーションにどのようなロールが存在するのか、誰が特定のリソースにアクセスできるのか、あるいは、特定のユーザがどのリソースにアクセスできるのかを一覧表示することが含まれます。

これらはすべて、認可をアプリケーション全体の構成要素として考えることを含みます。これらのユースケースの詳細については、今後の章で説明します。

このガイドで使用した単純な例にとどまらず、リポジトリはいくつもの方法で作成、破棄、読み取り、編集することができ、アクセス制御が親リソースのそれに関連する子リソース（課題、Wiki、ブランチなど）を持つこともできます。さらに、パーミッション階層はリソースに限定されません。ユーザーを組織にグループ化し、さらにチームやサブチームにグループ化することができ、アクセス制御のビジネスをさらに複雑にしています。

次回のエントリでは、このようなユースケースに一般的な権限パターンを適用する方法を紹介します。ここでは GitClub を例にとりますが、所有権や階層化されたパーミッション、ネストしたリソースなど、ここで取り上げるパターンは多くのユーザー向けアプリケーションに共通するものです。

## Role-Based Access Control (RBAC)

ロールベースの認可、またはロールベースのアクセス制御とは、権限を「ユーザ」や「管理者」のようなロールにグループ化し、それらのロールをユーザに割り当てることを意味します。 これは、権限コードを構造化する一般的で効果的な方法です。この構造により、開発者にとってもユーザにとっても、誰がどのリソースにアクセスできるかを理解しやすくなります。

### 1. What Part of the System is Role-Based Authorization?

前の章では、典型的なウェブ・アプリケーションであるGitClubを紹介し、そのアプリに認可を追加する手順を説明しました。認可は、「決定(decision)」と「実施(enforcement)」の二つの部分からなることを説明しました。

決定(decision)とは、「このユーザがこのリソースに対してこのアクションを実行することを許可されているか 」ということです。多くの場合、それは 「イエス 」か 「ノー 」である。

実施(enforcement)とは、一旦決定したらどのようなアクションを取るかということです。もし 「deny 」であれば、リダイレクトするか、「Permission Denied 」のページを表示するか。ユーザーが要求したアクションの実行が許可された場合、それはどのように見えるか？

この章では、その決定(decision)に焦点を当てる。特に、次のような質問をします： 「アプリケーションの中で誰が何をすることができるのか？また、データについても話す必要があります。「誰が何をできるか 」を問うとき、どのようなデータ構造を調べるのでしょうか？

これが完全にオープンエンドな問題になるのを防ぐために、私たちは認可モデルを使用して実装を導きます。モデルとは、認可コードを構造化し、実装をガイドする方法である。

この章では、役割ベースのアクセス制御（RBAC）の使い方について説明します。異なる種類の企業間(B2B)アプリケーションを中心に、いくつかの異なるモデルを取り上げます。それぞれのモデルについて、以下について説明します：

認可モデルとは何か。適切な認可モデルを選択することは、望ましいユーザエクスペリエンスに依存します。そのモデルがどのようなものであるか、また、実際の使用例を示し、どのような場合に使用するのが合理的であるかを説明します。

モデルの実装方法: 前章で述べたように、認可の決定はデータとロジックという2つの情報で構成される。認可ロジックは、誰が何をできるかを決定する抽象的なルールセットである。例えば、ある組織のメンバーは、その組織に属するリポジトリへのアクセスを許可される。 これらのルールは認可データ上で表現される。

さらに、リレーショナルデータベースにどのように格納されるかのスキーマ図を含めて、ロジックをバックアップする認可データをどのように構成するかを説明します。(e.g PostgreSQL)

多くの場合は、前の章で紹介した GitClub のサンプルアプリケーションを使うことになるでしょう。覚えておきましょう： GitClubはソースコードのホスティング、コラボレーション、バージョン管理のためのウェブサイトであり、現実のアプリケーションであるGitLabやGitHubに似ています。GitClubは、そもそも権限付与の動機となるもの、つまりリソースへのアクセスを確保することの純粋な例を提供している。GitClubでは、リソースの例はリポジトリだ。ユーザーは、リポジトリを読んだり変更したりすることができるかもしれないし、できないかもしれない。

#### Enforcement

それぞれの例では、アプリケーションの中で、以前推奨したように認可が実施されていると仮定します。たとえば、リポジトリを返すメソッドでは、ユーザーがそのリポジトリの読み込みを許可されているかどうかをチェックし、許可されていなければ拒否されたことを返します：

![alt text](<assets/CleanShot 2024-10-25 at 20.07.56@2x.png>)

前の章で紹介したis_allowedインターフェイスを使います。

これはアクター、アクション、リソースを受け取り、True/Falseを返します。

### Why Use Authorization Models?

認可モデルは、「私たちのアプリケーションで誰が何をできるか」という、そうでなければオープンエンドな質問に構造を適用するのに役立ちます。これは実装の観点からは素晴らしいことで、適用するテンプレートがあると便利です。また、ユーザーエクスペリエンスを劇的に向上させます。

認可モデルは、実装の指針になるだけではありません。それは、アプリケーションの中で何ができるかを示すために、ユーザーに教えるメンタルモデルです。明確な認可モデルを持つことで、私たちはユーザーに、「あなたが私たちのアプリケーションで実行することが期待されている職務はこれです 」と伝えることができます。

どのような権限が必要なのかを理解するためには、アプリケーションがどのように機能するのかを熟知している必要があります：

![alt text](<assets/CleanShot 2024-10-25 at 20.10.04@2x.png>)

あるいは、どこかの管理者を困らせるようなダイアログが表示される

![alt text](<assets/CleanShot 2024-10-25 at 20.11.55@2x.png>)

では、どうすればこのような状況を回避できるのだろうか？

それは、現在のニーズに適切で、新しいニーズが発生したときに対応できるよう、時間とともに成長できる柔軟性を備えた承認モデルを使用することだ。

時間の経過に伴う新しいニーズに対応するのは難しい部分であり、チームが苦労しているのを見てきました。この章では、モデルが互いの上に構築され、柔軟性とシンプルさのバランスが取れていることを確認することで、この問題に対処する。

### Role-Based Access Control (RBAC) Models

ロールは、認可のアプローチとして広く使われている。ロールベースのアクセス制御」としても知られるロールは、実装者とユーザの両方にとって、認可ロジックを単純化する効果的な方法です。

ロール(Role)とは、単に権限をグループ化し、ユーザに割り当てられるようにしたものです。

ユーザがロールに割り当てられると、そのロールが持つすべてのパーミッションがユーザに付与されます。

パーミッション(Permission)は、ユーザがリソースに対して実行できるアクションを指定します。例えば、ある組織のユーザはリポジトリの読み取り権限を持っているとします。

ロールのパーミッションは任意に選ばれるものではありません。一般的に、ロールはユーザーが誰なのか、アプリケーションで何をしたいのか、そしておそらくは組織内での役割や肩書きに沿ったものであるべきです。

例えば、GitClubでは主要なユーザーは開発者です。これは、私たちのシステムにおける一つの「ロール」になります。組織の設定を担当する IT 管理者や、課金を担当する財務担当者などです。これらのユーザはそれぞれ、アプリケーションを使用するために必要な異なる権限を持っています。GitClub の権限モデルでは、これらのユーザはそれぞれひとつのロールになります。

"課金" ロールに割り当てられた人は、当然ながら組織の課金を設定できることを期待するでしょう - 新規会員の支払いや支払い情報の更新などです。

ロールを使うことで、エンドユーザーに公開する必要のあるパーミッション情報の表面積を減らすことができます。アプリケーションを使用するために、膨大な数のパーミッションを設定する代わりに、少数のオプションから選択することができます。

ロールは信じられないほど柔軟であり、このセクションで異なる機能を実現するためにロールを使用するいくつかの異なる方法を見ていきます。

### Organizational Roles

GitClubでは、他の多くのアプリケーションと同様に、マルチテナント・アプリケーションとしてアプリケーションを構築しています。つまり、単一のバージョンのアプリケーションで、多くのインスタンスがすべてのユーザーや組織のリクエストに対応するということです。当然ながら、ユーザーが所属していない組織のリソースを閲覧できないようにする必要があります。では、どうすればよいのでしょうか？

#### What the authorization model is

ロールの単純な出発点は、各ユーザを1つの組織に関連付け、ロールに割り当てることです。その後、すべてのアクセスは、そのユーザーが組織内で持つどのロールによっても制御されます。

しかし、どのようなロールを作成すればよいのでしょうか？

ユーザー・エクスペリエンスをできるだけシンプルに保つために、最初は少数のロールで始めるべきです。ロールの数が多すぎると、すぐに混乱して管理が大変になります。

GitClub では、まず admin と member の二つのロールを用意します。これは、多くの B2B アプリケーションで一般的な開始点です。メンバーロールは、アプリケーションのすべてのコア機能 (リポジトリの読み書きなど) にアクセスできます。管理者は、メンバーができることすべてと、組織にユーザーを招待することができます。実際のシステムでは、管理者に支払いの設定、設定の構成、組織の削除の権限を与えるかもしれません。

#### How to implement the model

まず第一に、ユーザーを特定の組織に関連付け、ロールに割り当てる方法が必要です。データモデルでこれを実現する簡単な方法は、組織からユーザーへの1対多のリレーションシップを持ち、ユーザーに別のroleカラムを持つことです。

![alt text](<assets/CleanShot 2024-10-25 at 20.15.59@2x.png>)

このデータモデルでは、ユーザーがリソースに対してアクションを起こせるかどうかをチェックするロジックは、以下のチェックで構成される：

1. そのユーザーが所属する組織と、どのようなロールを持っているか
2. ロールが持っているパーミッション
3. パーミッションがアクションとリソースに適用されるかどうか

ロールと組織はユーザーデータに由来する。

ロール名からパーミッションの文字列リストまでの単純な辞書に格納することで、「ロールがどのようなパーミッションを持っているか」を定義します。手始めに、リポジトリへの読み書きと組織へのユーザー追加に関する簡単なパーミッションに注目してみましょう。例えば

![alt text](<assets/CleanShot 2024-10-25 at 20.17.03@2x.png>)

パーミッションにはaction:resourceという規約を使用しています。つまり、ユーザーがこのパーミッションを持っていれば、「resource 」タイプのリソースに対して 「action 」を実行できるということです。ユーザーは特定の組織のロールを持っていますが、パーミッションは組織とリポジトリの両方に適用されることに注意してください。

リソースがロールと同じ組織に属している場合、パーミッションは対象のリソースに適用されます。これらをまとめると

![alt text](<assets/CleanShot 2024-10-25 at 20.17.49@2x.png>)

#### When to use this model

これは、アプリケーション内でのアクセスを決定するものが組織レベルのロールだけである場合にうまく機能する、シンプルで保守性の高いモデルを提供します。

このモデルにはいくつかの制限があります。各ユーザーはただ1つの組織と関連付けられ、組織内のすべてのリソースを同じように扱います。異なるリポジトリに対して異なる権限を割り当てる必要がある場合、これでは十分ではありません。次のセクションでは、このようなケースをカバーするためにモデルを拡張する方法を示します。

### Cross-Organization Roles

#### What the authorization model is

GitClub のような共同作業ソフトウェアでは、一人のユーザーが個人的なプロジェクトのために自分のアカウントを持ち、また他の人と共同作業をするために他の多くの組織にも参加するのが一般的です。

各ユーザーをひとつの組織だけに所属させるのではなく、一人のユーザーが複数の組織に所属できるようにします。さらに、ユーザーは所属する組織ごとにロールが必要になります。

これをサポートするために、これまでの1対多のユーザーと組織の関係を、**多対多**の関係に変更する必要がある。

#### How to implement the model

多対多のリレーションの場合と同じように、結合テーブルを作成し、そのテーブルにロール名のカラムを追加してデータを構造化します。

![alt text](<assets/CleanShot 2024-10-25 at 20.19.49@2x.png>)

これにより、組織に所属することと、組織で役割を割り当てられることは同じであることが明示される。ロールを持たずに組織に所属することは不可能であり、その逆も同様である。

ロジックについては、以前と同じパーミッションを使用します。しかし、ユーザーのすべてのロールを検索し、ターゲット組織と照合するためにロジックを更新する必要があります：

![alt text](<assets/CleanShot 2024-10-25 at 20.20.15@2x.png>)

ロジックは少し複雑になり始めています。データベースからロールをフィルタリングすることで、潜在的な数の中から該当するロールをチェックしています。しかし、同じ基本的な構造がまだ存在することがわかります：ロールを取得し、それが組織に一致するかチェックし、正しいパーミッションをチェックします。

#### When to use this model

ユーザが複数の組織にまたがってアカウントを持つ必要がある場合、このモデルは先に説明したシンプルなモデルよりも大きく改善される！

この代替案は、Slackのような状況（記事執筆時点）であり、参加するSlackワークスペースごとに個別のアカウントとログインを作成する必要がある。これは、ユーザーがアカウントを持っているかどうかさえ分からない、ログインが何であるかを忘れてしまう、そして一般的に新しい組織に参加する障壁を増やすという状況をもたらします。

これは、将来的な対策としても価値のある取り組みであることが多い。アプリケーションが1組織につき1ユーザーのモデルに明確に適合しているように見えても、将来的には組織横断的なユーザーを追加する必要が出てくるかもしれません。より柔軟なモデルを使うことで、この新しい機能を後の段階で追加しても、移行は必要ない。この柔軟性の代償として、データモデルが若干複雑になります。

### Resource-Specific Roles

GitClubでは、大きな組織にも使ってもらえるようになったとします。顧客から、特定のリポジトリを誰が見ることができるかをもっとカスタマイズしたいという声が聞かれるようになりました。例えば、ある顧客は、すべてのインフラをコードとしてリポジトリに保存している。すべてのチームメンバーがこのリポジトリに書き込みアクセスできるようにすることはできません。

多くのB2B企業は、この機能要求の何らかのバリエーションに遭遇するでしょう。組織内のすべてのリソースへのアクセスを一律に扱うことに満足している限り、私たちが書いた組織ロールはうまく機能する。しかし、当社の製品を使用する組織の規模が大きくなるにつれて、単一のロール・セットでは、すべてのユーザーができることを十分に説明できなくなります。当社の顧客は、フォルダを作成し、フォルダにロールを割り当ててファイルへのアクセスを管理したり、リソースをプロジェクトや部署ごとにグループ化したり、個々のリソースへのアクセスを明示的に制御できるようにしたいと考えるかもしれません。

これに対処するために、リソース固有の役割を導入することができる。

#### What the authorization model is

リソース固有ロールは、組織ロールをより一般的にしたものです。特定の組織にロールを関連付けるのではなく、あらゆる種類のリソースにロールを関連付ける。組織自体がリソースの一種であるため、組織ロールはリソース・ロールの特殊な形となります。

GitClubでは、リポジトリもリソースの一種です。ここでは、組織のロールに加えてリポジトリにスコープされるロールを紹介します。

#### How to implement the model

このモデルのいいところは、組織の役割と同じ構造になっていることだ。

実際、組織そのものがリソースである。組織へのアクセス（または組織のメンバーであること）は、他のリソースへのアクセスと同じようにゲートされる！組織はもはや特別なケースではありません。すべてのリソース（この場合は組織とリポジトリ）は、このように同等のデータモデルを持っている：

![alt text](<assets/CleanShot 2024-10-25 at 20.24.04@2x.png>)

ベストプラクティスとして、ユーザーが同じリソースにアクセスできる異なる方法の数を最小限にします。そのため、リポジトリにアクセスするにはリポジトリのロールが必要です。今後は、リポジトリとのやり取りを許可する権限を組織のロールに割り当てることはありません。

GitClub では、「admin」 と 「member」 という 2 つの組織ロールはそのままに、「mentainer」 と 「contributor」 という 2 つの新しいロールをリポジトリ用に定義します。メンテナは、ブランチの作成やコードのプッシュ、プルリクエストのマージなど、リポジトリに対して何でもできます。コントリビューターは、コードを読んだり、課題を開いたり、プルリクエストを開いたりすることしかできません。

リポジトリを作成した人には、自動的に「メンテナ(maintainer)」ロールを割り当てることができます。しかし、アクセス権を得るために、組織の全員を手動でリポジトリに追加しなければならないのは迷惑です。私たちが欲しいのは、組織の全員に適用される基本レベルのアクセスです。

例えば、リポジトリと同じ組織にいる人は、明示的にロールが割り当てられていない限り、デフォルトのロールは「貢献者(contributor)」です。

![alt text](<assets/CleanShot 2024-10-25 at 20.25.08@2x.png>)

一方、組織レベルのアクションのアクセスチェックは、引き続き組織のロールのみをチェックする。これには、組織に新規ユーザーを追加するようなアクションが含まれる。

#### When to use this model

リソース固有のロールは、多くのユースケースに十分なきめ細かなパーミッションをサポートできる、非常に強力なモデルです。ここでは、リポジトリと組織というシンプルなリソースから説明しましたが、きめ細かなアクセス制御を行いたいアプリ内の他のタイプのリソースにも、同じロジックを適用し続けることができます。

このモデルは、何らかのリソース階層を持つあらゆるものに適している。フォルダ（Google DriveやDropboxを想像してほしい）、プロジェクト、ディレクトリ、あるいはそれに類するものだ。

このレベルまで成熟すれば、ロールベースのアプローチでほとんどのニーズに対応できると確信できるはずだ！

### Custom Roles

さらに複雑な問題があります。

ある GitClub ユーザーは CI/CD チームを持っていて、その唯一の仕事はメインへのコミットのマージと CI ジョブの実行です。彼らはコードを読むことはできませんが、ワークフローをトリガーすることはできます。これは既存のどの役割にも当てはまらない。
様々なユースケースやカスタマイズをサポートするための最善の努力にもかかわらず、自分のアカウントでユーザができることを正確にコントロールする必要がある少数の企業ユーザがいます。最後の手段として、お客様が独自のロールを作成し、カスタマイズできるようにすることができます。これはデータベースを複雑にし、UIを必要とします。

#### What the authorization model is

カスタムロールは、エンドユーザ（アプリケーションのユーザ）が独自のロールを作成し、そのロールに権限を割り当てることができるモデルです。

これらのカスタム・ロールは、ユーザをロールに割り当てることで通常どおり使用することができます。カスタム・ロールは、既存のロールと一緒に使用することができます。

#### How to implement the model

カスタムロールのモデルは、ロールから権限リストへのマップが動的である必要があり、ユーザを動的に作成されたロールに関連付ける方法が必要であることを除けば、これまで使用してきたものと実質的に同じです。

これを実現するために、ロールを管理する追加のテーブルを作成します。各ロールは特定のリソースに関連付けられていなければなりません。組織でロールをカスタマイズしたい場合は、ロールを組織に関連付けます。

ロールはロール名とパーミッションのリストで構成される。

![alt text](<assets/CleanShot 2024-10-25 at 20.29.38@2x.png>)

抽象的な視点から見ると、これは以前のスキームで書いたロジックとほとんど同じに見える。「ロールが持っているパーミッションをチェックする "というステップは同じです。実装の観点からの違いは、これらのパーミッションがメモリではなくデータベースに保存されるようになったことです。

#### When to use this model

ユーザーが独自のロールを作成できるようにすることは、すべてのユースケースを想定し、それらのユースケースのためにロールを定義する必要なく、幅広いユースケースをサポートする素晴らしい方法です。

しかし、**これをサポートする選択には十分注意してください**。カスタムロールを機能させるには、権限の定義を公開することに賛同する必要があります。これは、ドキュメント化し、変更時にユーザーに通知することを意味します。新しいパーミッションで新しい機能を追加したり、アプリケーションを移動させたりすると、予期せぬ副作用があるかもしれません。

実際、私たちがインスピレーションを得た2つの主要な情報源であるGitHubとGitLabを見てみると、どちらのアプリケーションもカスタムロールをサポートしていません。

GitHubは2020年にロードマップを公開しましたが、それ以来ずっと動かしています：

![alt text](<assets/CleanShot 2024-10-25 at 20.31.00@2x.png>)

一方、GitLab はこの機能について多くの議論を行い、最終的にサポートしないことを選択しました: <https://gitlab.com/gitlab-org/gitlab-foss/-/issues/12736#note_50662947>

しかし、どのような場合にカスタムロールを作る意味があるのでしょうか。ひとつの可能性は、platform-as-a-serviceのように大規模な設定が必要なアプリケーションです。この場合、ユーザがどのようにチームを編成し、製品を使用するかをユーザに押し付けたくないかもしれません。

エンドユーザーが設定可能なロールの世界に入ることは、AWS Identity and Access Management (IAM)システムのような完全に設定可能な権限システムにつながる。これについては今後の章で詳しく説明する。

### 3. Quick Reference To Choosing An Authorization Model

私たちは、最も複雑でない（そして最も柔軟でない）ものから最も柔軟なものまで、ロールベースの認可の4つのバリエーションを示した。

1. 組織ごとに 「メンバー 」や 「管理者 」のようなロールをユーザーに与えることは、ほとんどのアプリケーションで始められる素晴らしい方法です。
2. ユーザが個人アカウントを持つ必要がある場合や、組織をまたいで共同作業を行う必要がある場合は、組織横断的なロールを追加することができます。これは複雑さを増しますが、より柔軟です。
3. B2Bアプリケーションで、より大きな組織にサービスを提供している場合、顧客はおそらくリソース固有のロールを必要とするでしょう。データモデルはより複雑になりますが、これによって特定のリソースに対する権限を制御できるようになります。
4. ユーザが独自の権限スキームを作成し設定できるようにする必要がある場合、カスタムロールを実装する方法を説明しました。これを必要とする企業はほとんどないでしょう！

ここで説明したロールは、プロダクションで遭遇する多くの状況をカバーします。しかし、すべてをカバーしているわけではありません。ロールでは対処できない状況もあります：

1. ユーザーが作成したコメントを削除できる
2. ユーザーは共有されたコードスニペットを読むことができます。
3. 閲覧が許可されているリポジトリに属するすべての課題を閲覧することができます。

次の章では、このようなケースに対応するために、*関係*に基づく認可(ReBAC)を紹介する。
