
# [Authorization Enforcement](https://www.osohq.com/academy/authorization-enforcement)

認可の実施とは、認可の決定を要求し、その結果に基づいて行動するプロセスである。ユーザがリソースへのアクセスを許可されるべきか拒否されるべきかがわかったら、 そのアクセスを実装する必要があります。また、この実施をどこに置くかを決定する必要がありますが、このガイドではその決定方法を紹介します。

## 1. What This Guide Covers

第 II 章では認可アーキテクチャについて説明し、GitClub のサンプルアプリケーションにおけるリクエストの流れを説明しました。認可を追加したい場所はいくつかありますが、その中心は「アクタ(actor)はこのリソース(resource)に対してアクション(action)を実行してもいいのか？この質問こそが認可のインターフェイスであり、そのインターフェイスのふたつの側面が決定と実施です。

第III章と第IV章では、認可の決定を行うために認可モデルをどのように使用できるかを見てきました。これらのモデルには、ロールとリレーションシップが含まれていました。

本章では、第II章で紹介した認可＝決定＋実施の方程式の後半部分である、実施について取り上げる。この章では、どこで認可を実施するか、その場所で何を実施すべきか、どのように実施と決定メカニズムとを結びつけるか、そして決定に対して何を行うかを決定するためのモデルを提供する。

前の章までと同様、引き続き GitClub のサンプルアプリケーションを使います。覚えておきましょう： GitClubはソースコードのホスティング、コラボレーション、バージョン管理のためのウェブサイトであり、現実のアプリケーションであるGitLabやGitHubに似ています。GitClubは、そもそもオーソライゼーションを動機づけるもの、つまりリソースへのアクセスを確保することの純粋な例を提供します。リソース 「とは、GitClubにおけるリポジトリのように、」アクセスできるもの "のことです。ユーザーは、リポジトリを読んだり変更したりすることができるかもしれないし、できないかもしれない。

### What Is Authorization Enforcement?

最後の2つの章では、「このアクターはこのリソースに対してこのアクションを取ることができるのか」という認可判断の方法について説明しました。エンフォースメントとは、その認可決定を要求し、その結果に基づいて行動するプロセスのことです。

言い換えれば、エンフォースメントとは、ユーザが間違ったデータにアクセスするのを実際に防ぐために、アプリケーションに追加する部分です。

![alt text](<assets/CleanShot 2024-10-28 at 20.52.31@2x.png>)

GitClub アプリケーションでは、リポジトリの取得と返却を行うコードにその一例があります。認可の判断を仰ぐには、まず認可クエリの内容を決定します。現在のユーザーが要求しているリポジトリの閲覧を許可されているかどうか。GitClub では、認可はライブラリで処理します。つまり、認可をリクエストするということは、ライブラリのメソッド is_allowed(user, 「read」, repository) を実行するということです。

判定結果が返ってきます。もし判定が 「allow」 なら、リクエストを通常どおり続行させます。しかし、判定が 「deny 」であれば、ユーザーにエラーを返します。

### Where to enforce authorization?

多層アーキテクチャのレイヤーを考えることで、どこにエンフォースメントを追加するかを考えることができる。ここでアーキテクチャパターンの本を書いているわけではないので、もし馴染みがなければ Wikipedia を見てください。

GitClubのレイヤー：

1. サービスレイヤー - リクエストの処理とルーティングを担当します。GitClubでは、このレイヤーはネットワークプロキシとアプリケーション自体のルーターの両方を指します。
2. ビジネスロジック層 - GitClubアプリケーションの機能。
3. データレイヤー - データへのアクセスを提供する。GitClubでは、データベースとリポジトリデータを保存するファイルシステムがこれにあたります。
4. プレゼンテーション層 - ユーザーに何を見せるか。これは、（仮想の）<https://www.gitclub.dev> にアクセスしたときに表示される GitClub ウェブ・インターフェイスです。

アプリケーションの各レイヤーには、適用すべき認可の異なるレベルがある。レベルは、認可を決定するために使用するデータによって区別される。

![alt text](<assets/CleanShot 2024-10-28 at 20.54.43@2x.png>)

サービスレイヤーでは、リクエストの内容に基づいて認可を決定できる。アプリケーションコンテキストがないことを考えると、エンドポイントに アクセスできるかどうかを強制することだけが現実的である。これは**リクエストレベル**の認可である。

ビジネスロジック層は、私たちが主に注目するところです。このレイヤでは、ユーザが何をしていて、どのリソースにアクセスしている かについて、完全なコンテキストを持っています。これが**リソースレベル**の認可です。

データセットに対して一括して認可を行う場合、データレイヤーに認可をプッシュダウンすることが望ましい。これを実現する方法は、データレイヤーとの通信に認可を適用することである。これが**クエリーレベル**の認可である。

また、プレゼンテーション層で一種の認可を行うこともできる。これは**クライアントサイド**の認可である。他のレベルとは異なり、これは実際に認可を実施することを信頼することはできません。なぜなら、ユーザがクライアントを回避してバックエンドに直接アクセスすることが可能だからです。

次のセクションでは、各レイヤーと各レベルを順番に見ていき、クエリーの構築、決定メカニズムへの送信、レスポンスの処理のステップについて詳しく説明する。

## 2. Authorization enforcement by layer and level

各レイヤーを順番に見ていき、施行がどのようなものか見ていこう。プレゼンテーション・レイヤーは最後まで残しておこう。

### Service layer and request-level authorization

サービス層では、生のHTTPリクエストを扱います。GitClub では、HTTP リクエストを扱う場所のひとつにリクエストミドルウェアがあります。たいていのウェブフレームワークにはリクエストミドルウェアというものがあり、それを使えばすべてのリクエストに同じロジックを適用することができます。

![alt text](<assets/CleanShot 2024-10-28 at 20.57.44@2x.png>)

#### What is request-level authorization?

サービスレイヤーでリクエストに対する認可を実行することは、リクエストレベル の認可として適切に知られている。これは、認可を決定するためにリクエストそれ自 体で利用可能な情報を利用する認可である。

リクエストレベルの認可では、問い合わせは一種類だけである： 「アクターはこのサービスにこのリクエストをすることが許可されているか」。HTTPリクエストの場合、認可の決定に使用される情報は通常、リクエストパスとHTTPメソッドである。

ユーザデータにアクセスすることも一般的です。例えば、多くのアプリケーションはミドルウェアの一部としてユーザーセッションを処理したり、認証情報の一部としてユーザーに関する追加データを含めたりします。しかし、サービスレイヤーの一部としてデータベースからリソースを取得することは、ビジネスレイヤーで行われる作業と重複してしまうため、通常は行うべきではありません。

この制約により、多くの認可モデルを適用することができない。前の章で取り上げたモデルは、すべてアプリケーションデータに依存して決定します。

いくつかの例と、それぞれの場合のアクター、アクション、リソースを見てみましょう。

ログインしていないユーザーがホームページを訪問する

ウェブユーザーがログアウトしている場合、アクターはゲストであると考えます。

この場合のアクションは /home への GET リクエストです。

リソースは GitClub ウェブアプリケーションです。

認可クエリは、ゲストが GitClub ウェブアプリケーションの /home ルートに対して GET リクエストを行うことを許可するか、というものです。

というものです： 「誰でも、ウェブアプリケーションの /home で始まるルートへの GET リクエストを行うことができます。また、ゲストがログインページにアクセスできるようにする必要があります。それ以外のものは拒否され、ユーザーをログインページにリダイレクトします。

リクエストに追加のコンテキストを追加することで、より多くのリクエストレベルの認可を行うことができます。これを行う最良の方法は、セッションを管理するためによく使われる暗号トークンに追加することです。このようにして、追加のコンテキストをユーザーに提供し、それ以降のリクエストに含めることができる。提供されたトークンは、ユーザーがその追加コンテキストを操作していないことを暗号的に保証する。

GitClub では、ユーザーが API トークンを作成する際に特定のパーミッションを設定できるようにしたいと思うかもしれません。ユーザーが API トークンをリクエストするための特別なページを用意し、トークンに持たせたいパーミッションを選択できるようにします。たとえば、「issues:read」 や 「repositories:read」 といった文字列のリストをトークンに持たせて、トークンが実行できるアクションを指定します。

GitClub CLI は、API トークンを使って Acme/Anvil リポジトリに新しいプルリクエストを開こうとします。

APIトークンを使ってリクエストを行う際には、トークンの持ち主をアクターとして識別します。

この場合のアクションは、/org/acme/repo/anvil/pull_requests への POST リクエストです。

リソースは GitClub API サービスです。

認可クエリは次のようになります： GitClub API サービスの /org/acme/repo/anvil/pull_requests に対して POST リクエストを行うことを API トークンに許可しますか？

リクエストが許可されるべきかどうかを決定することはできません。トークンを作成したユーザーが Acme/Anvil リポジトリでプルリクエストを開くことを許可されているかどうかはわかりません。

しかし、リクエストの情報を使って最初の判断を下すことはできます。我々のAPIトークンは暗号トークンであり、トークンの持ち主にどのような権限が付与されているかを含んでいる。したがって、トークンが 「repository:write 」パーミッションを持っているかどうかで判断することができる。

これと同じロジックがすべてのAPIエンドポイントに必要なので、サービスレイヤーでリクエストレベルの認可を使用することで、一箇所で処理することができる。

しかし、それが扱う認可はまだかなり粗い。例えば、アプリケーションは、トークンを作成したユーザーがAcme/Anvilへのプル・リクエストを開くことを許可されているかどうかをチェックする必要がある。これは、ビジネスレイヤーのリソースレベルで行われる必要がある。利点は、APIトークンを処理するロジックがサービス層で処理されるので、この情報をビジネス層に渡す必要がないことである。

#### Where to enforce

モノリスアプリケーションでは、リクエストミドルウェアがリクエストレベルの認可 を実装するのに最適な場所である。最良のアプローチは、すべてのリクエストに対して認可を実行し、認可を必要と しない特定のルートに対してはオプトアウトメカニズムに依存することです。

サービス指向アーキテクチャのコンテキストでは、ネットワークプロキシ の一部としてリクエストレベルの認可チェックを追加することもできます。これにはAPIゲートウェイ、サービスメッシュ、ロードバランサーなど、いくつかの種類がある。ネットワークプロキシは、認可の決定を中央のサービスに委ねることで、リクエストレベルの認可を強制することができる。前の例で見たように、このサービスは通常ユーザデータにアクセスする必要がある。

#### What to return

APIリクエストの場合、403 Forbiddenエラーメッセージとエラーの詳細をレスポンス本文で返すのがよい。

### Business Logic Layer and Resource-Level Authorization

リクエストが適切にルーティングされたら、アプリケーションのビジネスロジックに入ります。ここでマジックが起こる！ここでアプリケーションはデータを取得し、操作し、他のデータを更新し、バックグラウンドジョブをトリガーします。

ビジネスロジック層では、コードは多くの場合、アプリケーションの中核となるドメイン概念を表すオブジェクト、クラス、または型を扱います。そして、一般的に、リソースレベルの認可という形で、認可の大部分がここで行われます。

![alt text](<assets/CleanShot 2024-10-28 at 21.03.32@2x.png>)

#### What is resource-level authorization

"リソース(resource)"とは、ユーザーがアプリケーションにアクセスしたり操作したりするあらゆるデータのことを指します。GitClub では、組織、リポジトリ、課題、コメントなどがリソースの例です。

リソースレベルの権限付与では、リソースとそれに関連するデータを直接使って判断を行います。これまでの認可アカデミーの章で使ってきた例は、すべてリソースレベルです。たとえば、「acme/anvil リポジトリの issue #1313 を読むことが許可されているか」 はリソースレベルのチェックです。

#### What to enforce

友人があなたに尋ねたとしよう： 「あなたのアパートに入ってもいい？何の脈絡もなく答えるのは難しいと思うかもしれない！」と聞かれたとする。上着を忘れて取りに行きたいのかもしれない。 "あなたのアパートから上着を取りに行ってもいいですか？"と聞かれたら、あなたの友人に答えるのは簡単でしょう」。

アプリケーションの承認についても同じ問題がある。acme/anvilリポジトリの課題#312をクローズしたいというユーザーからのリクエストを処理するとします。最も具体的なクエリは次のようになります： ****ユーザ(行為者)はacme/anvilリポジトリのissue #312をクローズ(アクション)することを許可されていますか? ****このように具体的にすることで、意思決定メカニズムに可能な限り多くの情報を提供し、最適な答えを決定することができます。

認可クエリをより一般的にするという選択肢を考えてみましょう。他のメソッドでクエリを再利用できる可能性があり、心配するパーミッションが少なくなるためです。例えば、上記のクエリを 「is the user (actor) allowed to edit (action) the acme/anvil repository (resource)」 に変更すると、ユーザがリポジトリに対してどのような権限を持っているかに基づいて、認可の判断を簡単に行うことができます。そして、この同じクエリを、ユーザがリポジトリに対して要求するすべての変更に対して使用することができます！

しかしそうすると、クエリをより一般的にすることで情報を捨ててしまうことになります。もしそのユーザがリポジトリのメンバーではなく、元のissueをオープンした外部の共同作業者であった場合はどうでしょうか？issueの所有者がissueを閉じることができるかどうかを判断するために、関係ベースの認可を使用することができるはずです。

問題は、認可ロジックがアプリケーション・コードに漏れてしまっていることです。ユーザがissueの属するリポジトリを編集できるのであれば、issueを閉じることができると暗黙のうちに仮定してしまっているのです。

まとめると、認可クエリは可能な限り正確に作成しましょう。こうすることで、認可ロジックを分離し、何を強制するかを考える必要がなくなり、決定ロジックをより柔軟にすることができます。

#### Where to enforce

リソースレベルの認可を追加するのに最適な場所は、意図したアクションが実行される場所にできるだけ近い、アプリケーションコードの中です。

リソースがすでに手元にある場合は、すぐに認可を実行することができます。これは新しいリソースを作成する場合によくあることです。

そうでない場合は、まずリソースを取得し、アクセスを強制してからアクションを実行する必要があるかもしれません。例えば、データを読み込む場合、最初のステップはデータベースからリソースを取得し、ユーザーに読み込む権限があるかどうかをチェックします。(次のセクションで別のアプローチを取り上げます。)

#### What to return

認証失敗を処理するためのデフォルトの戦略は、HTTP 403 Forbiddenメッセージを返すことです。

しかし、場合によってはエラーメッセージを返すことでユーザーが知るべきでない情報を公開してしまうこともあります。たとえば、ある GitClub ユーザーが /org/acme/repo/secret_project (非公開リポジトリ) を訪れたとしましょう。そのとき 403 Forbidden メッセージが表示されると、そのようなリポジトリが存在することがバレてしまうかもしれません。

そのため、ユーザーがどのような操作をしようとしているかにかかわらず、リソースの読み込みすら許可されていない場合は常に HTTP 404 NotFound メッセージを返すようにしましょう。

#### Field-level access

ユーザーがリソースのどのフィールドにアクセスできるのかを制御したいことはよくあります。

たとえば GitClub では、ユーザーは自分のプロフィールを見ることができ、自分に関するすべてのデータを見ることができます。他の人のプロフィールも見ることができますが、見られるのはデータの一部だけです。

これは**フィールドレベルのアクセス**と呼ばれます。リソースレベルのさらに上のレベルです。

フィールドレベルの強制を扱うには2つの方法がある：

1. Individual: アクセスされるフィールドを表すより具体的なアクションを新たに作成する。
2. Generic: フィールドを認可判断の追加パラメータにする。

個々のアプローチは、リソースレベルの認可の上に追加作業を必要としないが、少し柔軟性に欠ける。二つ目はより強力ですが、認可のインターフェイスを変更する必要があります。それでは、GitClub のコンテキストでどちらを使うかを見てみましょう。

GitClub のユーザーはリポジトリに変更を加えることができます。名前の変更や説明の追加、タグの指定などができます。これらはすべて、「update repository」 メソッドで行います。リソースレベルの認証を使って、ユーザーがリポジトリの更新を許可されているかどうかを調べます。

しかし現在、組織管理者だけがリポジトリを非公開にできるように制限したいと考えています。現在のアプローチでは、ユーザーがリポジトリの更新を許可されているかどうかをチェックするだけなので、これを扱うことはできません。

フィールドレベルのエンフォースメントに個別のアプローチを取ることは、少数のフィールドでは問題ありませんが、時間が経つにつれて、かなりの量の認可ロジックがアプリケーションに波及することになります。私たちのやり方はこうです：

まず、リポジトリに 「change visibility 」という新しいアクションを追加し、これを組織の管理者ロールに権限として割り当てます。実施側では、ユーザがリポジトリの 「private 」フィールドを変更しようとした場合、認可クエリで 「change visibility 」アクションを使用する必要があります。この場合、アプリケーションに認可ロジックを追加する必要があります。リクエストにどのリソースフィールドが存在するかによって、どの認可を適用するかを選択しなければなりません。

時間が経てば、ユーザーが更新できるフィールドをもっとコントロールできるようになるかもしれません。例えば、リポジトリメンテナーだけがリポジトリの説明を更新することができ、リポジトリ貢献者はタグを追加することができます。

このような変更を行うには、認可ロジックの多くをアプリケーションに漏らす必要があります。

フィールドレベル強制の一般的なアプローチでは、要求されたフィールドを含むようにクエリを更新します。更新の場合、元のクエリを次のように修正します。つまり、アクションを単に「更新」と考える代わりに、更新されるフィールドの完全なコンテキストを含めるのです。

こうすることで、決定メカニズムが次のようなロジックを処理する責任を負います：もし更新要求が 「private 」属性を含むなら、ユーザーはリポジトリ上で 「change_visibility 」する権限を持っていなければなりません。リクエストに含まれる他のすべてのフィールドについても同様です。

ジェネリック・アプローチの欠点は、追加されたパラメータ（フィールド）を処理するために、認可インターフェースを更新する必要があることだ。この点を考慮すると、個別アプローチが適しているのは、扱うフィールドが数個しかない場合である。

#### Data Layer and Query-Level Authorization

リソースレベルの認可には、1つの重大な欠点がある：認可を実行するためにリソースをフェッチする必要がある。

これは大したことではないように思えるかもしれない。結局のところ、私たちはとにかくリソースを取得したいのです。しかし、リストエンドポイントを実装するときによくあるように、大きなリソースの集合に対して認可を行う場合は、それぞれのリソースを個別に取得することが問題になります。

GitClub では、ユーザーがアクセスできるすべてのリポジトリの一覧を表示するエンドポイントを公開しています。これをリソースレベルの認可で行うと、データベース内のすべてのリポジトリを取得し、そのひとつひとつに対して認可の判断を要求することになります。その代わりに、認可をデータレイヤーにプッシュダウンし、クエリーレベルの認可を使用することができます。データレイヤーは一般的にデータベースを指しますが、他のサービスを指すこともあります。

![alt text](<assets/CleanShot 2024-10-28 at 21.15.32@2x.png>)

#### What is query-level authorization

クエリーレベル認可は、データアクセスクエリー（例えばSQLクエリー）に認可パラメーターを含めるように変更することで、データレイヤーで認可を実施するアプローチである。

これには、これまで見てきたものとは異なる認可インターフェイスが関係する。認可の判断は、もはや「はい」「いいえ」の単一回答ではない。その代わりに、クエリのフィルターとして決定をエンコードすることで、データセットの各リソースに対して決定を行わなければならない。

簡単な例として、ユーザーが作成したリポジトリはすべて読むことができるとします。この認可ロジックを反映させるために、すべてのリポジトリを取得するクエリに「where the created_by field is set to the ID of the current user」という条件を含めることができます。これにより、許可されたリソースのみが返されるようにデータベースをフィルタリングします。

#### Decisions and enforcement

クエリ・レベルの認可クエリについて、次のように考える必要があります。「アクタは、このクエリ内のすべてのリソースに対してアクションを実行することが許可されているか？

上記の例の場合、クエリは「repositories」テーブルへのクエリによって返されたリポジトリに対して、ユーザが「read」というアクションを実行することが許可されているか、ということになります。

これまでの実施例では、権限付与の判断は単純な「はい/いいえ」で済みます。しかし、クエリ・レベルの権限付与では、クエリに適用するすべての条件を含めて決定しなければなりません。

GitClub の場合、誰かがリポジトリを読めるシナリオには次のようなものがあります：

1. リポジトリが公開されている
2. ユーザーが共同作業者としてリポジトリに追加された
3. リポジトリが所属する組織で役割を持っている

これらの各条件は、実施メカニズムが適切なクエリフィルタを適用できるような 方法で表現される必要がある。これらの条件のフォーマットが柔軟であればあるほど、認可ロジックの拡張性が高まる。しかし、そのためには、任意の条件を返すことができる決定メカニズムを実装する必要がある。Osoでは、ポリシー言語が認可クエリの出力として制約のセットを返せるようにすることで、これを可能にしました。

ある程度の柔軟性を犠牲にし、決定メカニズムによって返される有限数の条件を指定することで、完全なポリシー言語を必要としないようにすることができます。前の例では、各条件に対して文字列を返すことができました：

1. 「repository_is_public" - リポジトリが公開されているかチェックする。
2. 「user_has_repository_role_contributor「 - ユーザーがリポジトリの 」contributor" ロールを持つかチェックします。- ユーザーがリポジトリの 「contributor」 ロールを持つかチェックする
3. 「user_has_organization_role_member「 - ユーザーがリポジトリが所属する組織の 」member" ロールを持つかチェックします。

実施メカニズムの役割は、決定メカニズムから返された条件を処理し、クエリに適用することです。これは、データが取得された後に遡及的に実施されるのとは対照的に、プロアクティブに適用される実施と考えることができる。

データベース、検索エンジン、外部サービスのいずれにアクセスする場合でも、データレイヤーが何らかの形でフィルタリングをサポートすることを期待しています。クエリレベルで認可を実施するには、デシジョンから返された条件を、サポートされているフィルタに変換できなければなりません。

例えば、前述の各条件はSQLフィルタとして実装できます：

![alt text](<assets/CleanShot 2024-10-28 at 21.19.08@2x.png>)

#### Where to enforce

クエリレベルの認可は、データアクセスレイヤ（データベースやその他のソースからデータを取得するアプリケーションコードの部分）に追加されるべきです。

認可クエリは、現在のユーザや実行中のアクションなど、リソースレベルの認可と同じコンテキストを必要とします。このコンテキストは、クエリ・インターフェイスの一部になる必要がある。

#### What to return

認可はデータセットをフィルタリングすることで適用されるので、結果を特別な方法で処理する必要はない。アプリケーション・コードにとっては、認可されていない項目は単に存在しないように見えるだけである。これは 「read 」アクションには理想的である。

しかし、「no results」 と 「not allowed」 を区別したほうがよい場合もあります。GitClub のユーザーがある組織のチームを一覧表示しようとしたときに、そのユーザーがその組織に属していないために結果が表示されなかったり、すべてのチームが非公開であるために結果が表示されなかったりすることがあります。この二つのケースを区別するために、リソースレベルのチェックを追加することができます。結果がNOの場合は、エラーを返すか、ユーザーをリダイレクトします。結果がYesの場合は、クエリレベルのチェックに進みます。

クエリレベル認証は、リソースレベルのチェックを置き換えるために使用することもできます。例えば、データベースからリポジトリを取得し、そのユーザーが読み取り権限を持っているかどうかをチェックする代わりに、クエリレベル認可を使用すると、両方のステップを一度に行うことができます。これは、リソースレベルのチェックで説明したように、リソースが存在するかどうかを明らかにしたくない場合に有効です。

### Presentation Layer and Client-Side Authorization

エンフォースメントのために考慮すべき最後のレイヤーは、プレゼンテーション・レイヤーである。プレゼンテーション層とは、サーバサイドでレンダリングされたウェブページ、シング ルページアプリケーション、コマンドラインアプリケーション、ウェブサイトなど、あらゆる ユーザインタフェース（UI）を指します。これらすべての場合において、強制コードは信頼されていないクライアント上で実行されます。これは簡単にバイパスできるため、より良いユーザーエクスペリエンスを提供する方法として、クライアント側の認証を使用するしかありません。

#### What is client-side authorization?

クライアント側の認可とは、ユーザが何をできるかを通知するために、ユーザインタフェースで認可決定を使用することを指します。これは、より良いユーザーエクスペリエンスを実現します。誰もボタンをクリックしてエラーメッセージが表示されることだけは望んでいません。

![alt text](<assets/CleanShot 2024-10-28 at 21.21.09@2x.png>)

これを避けるために、リクエストが許可されるかどうかを先取りするために、クライアント側の認可を使用する。リクエストが拒否される場合、特定のユーザーインターフェイスコンポーネントを無効にするか、ユーザーから完全に隠すことができます。

さらに良いことに、認可の判断の理由をユーザーに表示することで、そもそもなぜそのアクションを実行できないのかを正確に知ることができます。

![alt text](<assets/CleanShot 2024-10-28 at 21.23.11@2x.png>)

GitHub リポジトリの設定ページで、組織のメンバーがリポジトリを削除したり転送したりできない理由を説明しています。

#### What to enforce

クライアントサイドの認可の主な課題の1つは、バックエンドで実装された認可と同期を保つ方法です。

通常、現在のユーザーがリソースに対してどのようなアクションを取ることが許可されているかに基づいて、UIコンポーネントを非表示にしたり、表示したりしたいものです。良いパターンは、バックエンドサーバにそのアクションが何であるかを問い合わせることです。これにより、サーバーがすでに実装しなければならない認可ロジックの重複を避けることができます。また、クライアントはそれらのアクションを自由に使うことができる。

例えば、「リポジトリ設定」ページをレンダリングするとき、現在のユーザーがリポジトリに対して持っているすべてのパーミッションのセットを計算することができます。これは、「read」、「change_visibility」、「update 」などです。ウェブページは単純なロジックを実装するだけでよいのです。「delete 」パーミッションがユーザーパーミッションのリストになければ、削除ボタンを非表示にします。

しかし、クライアントとサーバーの間には依存関係があります。サーバー上の各エンドポイントにどのようなアクションが必要なのか、両者は同期していなければなりません。

## 3. Summary: When To Use Each Level

第II章で認可を行う場所を説明したとき、我々はビジネスロジック層とデータアクセス層で行うべきだと結論づけた。この2つの場所では、「このユーザはこのリポジトリを読むことができるか? 」といった、一般的な認可シナリオを処理するために、最も多くのコンテキストが利用可能でした。

ここまで、アプリケーション・アーキテクチャ全体を通して、認可を実施できる4つの異なるレイヤと、どのようなレベルの認可を追加できるかについて、詳しく説明してきました。要約すると、各認証レベルにはそれぞれの場所があるということです：

1. リクエストレベルは、全リクエストに共通する共通の実施手順を抽出するために 使用されるべきである。また、リソースレベルの認可の上に付加的なレイヤーとして、 徹底した防御のために使うこともできる。
2. リソースレベルはほとんどのシナリオで安全な選択である。このレベルでは、関連するすべてのコンテキストが認可の決定に利用可能です。
3. クエリーレベルは強力なアプローチであり、データセット全体にリソースレベルの認可を適用する必要がある場合に使用されるべきである。
4. クライアントサイドは、バックエンドで実行される認証の上に追加されるレイヤである。可能な限り、どのようなアクションを実行できるか/できないかをユーザーに知らせるために使用されるべきである。

言い換えると、認可が行われる可能性のある場所はたくさんあり、それを追跡するのは難しいかもしれません！少なくとも1つのレベルの認可がリクエストパス全体に適用されていることを確認する必要があります。

実用的な例を見たい場合は、リソースレベル、フィールドレベル、リクエストレベルの認証を Oso を使って実証しています。
