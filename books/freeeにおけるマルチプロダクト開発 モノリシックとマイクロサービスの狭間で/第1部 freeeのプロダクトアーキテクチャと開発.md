# 第1部 freeeのプロダクトアーキテクチャと開発

## 第1章 成熟したプロダクトの大規模リアーキテクチャ ~ 統合分離への挑戦 ~

### 1.1 freeeのアーキテクチャ特性と成長に伴う課題

- freeeのシステムアーキテクチャ特性
  - プロダクトにおける進化スピードを最速に維持することを重視している
  - スモールビジネスの経営にまつわる業務とその 領域は非常に多岐にわたり、それらに最速で価値を届け続けるためには新規プロダクトや機能改善を素早く開発できることが求められる
  - しかしビジネスが成長し、開発組織・プロダクトの数・事業所数などの規模が大きくなるにつれ、これらの特性を維持する難易度は上がっていく
    - 特に創業期からのプロダクトであるfreee会計はコードベースが非常に巨大なモノリスとなっていて、その業務の特性も相まってさまざまな機能が複雑に依存し合うようになったことで、機能を追加した時の影響範囲が読みきれず拡張が困難になっていた
    - コードベースが巨大なのでリファクタリングなどの内部品質の向上も一筋縄ではいかず、技術的負債が蓄積しやすくなっている
    - 一定規模以上の法人ユーザーが増えたことでデータ量やトラフィックも増加したが、データの依存関係も複雑になっているため、スケールアウトの難易度も上がっていた
- これらの課題を解決するため、社内の技術リーダーたちを中心に議論を行い、結論としてサービス分離によるシステムのリアーキテクチャによって多くの課題が解決できると判断した
  - この戦略に基づき、巨大なモノリスとなったシステムをドメイン境界に合わせて適切に「分離」してシステムと体験を「統合」することで、freee全体のリアーキテクチャを行う「統合分離」と呼ばれるプロジェクトが立ち上がった

![alt text](<assets/CleanShot 2024-11-04 at 21.14.41@2x.png>)

### 1.2 統合分離とその戦略

- すでにいくつかの機能をマイクロサービス化している経験もあり、サービス分離にはそれに伴うコストや分離すること自体のデメリットもあることがわかっていた
  - 単純に機能をそのままマイクロサービスに分けるとデータベーストランザクションが別れてしまい、データの整合性を担保する難易度が増大することが考えられる
  - 1つの機能を提供するのに複数のサービスを呼び出すことによるネットワーキングコストの増大とそれによる体験劣化
- リアーキテクチャの恩恵を享受するために、大きく分けて2つの戦略で推進することになった
  - ドメインの境界を基準としたサービス分離によって依存関係をシンプルにする
  - 標準化・共通基盤によって分離されたサービスの開発とその統合を支援する

#### 1.2.1 ドメインを分析し境界を見つける

- 整合性担保や通信オーバーヘッドなどのサービス分離にまつわる多くの課題は、依存関 係の複雑さに起因している
- これを解決して依存関係をシンプルにするには、強く依存する業務とそうでない業務の境界を見つけるドメイン分析が必要になる

> この時に現在のシステム構造に 引っ張られないようにし、まずは対象のドメインについてあるべき業務フローから分析を していきます。freee ではプロダクトマネージャーやドメインエキスパートのような対象 業務に詳しい人が社内にいるので、その協力を仰ぐことが多いです

![alt text](<assets/CleanShot 2024-11-04 at 21.31.02@2x.png>)

- 理想の業務フローが整理されて依存関係が可視化されても、現状のシステム構造を考慮しないと実現性に乏しいものになってしまう
  - 現状のシステムにおけるデータベーステーブルやコードとドメインのマッピングを作ることで、分析によって洗い出したドメインに抜け漏れがないかのチェックや、分析によって見つけたドメイン境界の中で現実と大きなズレがあるところの可視化などに役立つ

![alt text](<assets/CleanShot 2024-11-04 at 21.32.11@2x.png>)

- これらのアプローチをもとに、適切な単位のドメイン境界を決める
- 理想と現実を照らし合わせた上で塩梅の取れたドメイン境界を決めていく

#### 1.2.2 どうやって分離するかを決める

- 以下の軸によって対象ドメインの分離をスコアリングし、上位のものを優先して対応していくこととした
  - ビジネス優先度(どのくらい活発に開発されるのか)
  - 生産性・パフォーマンス等の改善見込み(どのくらい分離の効果があるか)
  - 分離する難易度(分離にどのくらい開発コストがかかるか)

![alt text](<assets/CleanShot 2024-11-04 at 21.38.06@2x.png>)

- 分離の開発パターン
  - **v2 新規実装**
    - 扱うドメインは同じだがデータモデル含め全く新しいサービスを設計し実装するパターン
    - 既存のプロダクトに手を入れずに新規プロダクトのように独立して開発できるメリットはあるが、既存ユーザに利用してもらうためには移行の負担を強いることになるデメリットがある
    - このパターンを採用するのはシステムアーキテクチャとしての分離よりも、ドメインそのものを見直して新たな価値を創造したいというのが主な動機になる
  - **コンポーネントベース分離**
    - 分離したいドメインロジックについて、まずシステム内部でモジュールとして隔離(モジュラーモノリス化)を行う
      - 次に新しいマイクロサービスを立ち上げてモジュールの実装を移植し、分離元の依存コードの向き先を徐々に新しいサービスに変えていくパターン
    - 既存実装への依存関係がすでに複雑であったり品質が低くそのまま分離しても流用できない時に、まずモジュール化によって疎結合にしてから分離する選択肢になる
    - 既存コードのリファクタリングの延長から始まるため、他のアプローチに比べて二重メンテナンスの問題は起きづらいが、分離の効果が生まれるまで比較的時間がかかることが想定される
  - **戦略的fork**
    - 分離したいシステムをコピーして対象ドメインに不要なコードを削った新しいサービスを立ち上げ、分離元の依存コードの向き先を徐々にforkしたサービスに置き換えていくパターン
    - コンポーネントベース分解はまず先に分離元システム内でモジュール境界を切ってから新しいサービスへ移行していくが、戦略的forkではまず丸ごとコピーしてしまうことで分離された新しいサービスを先に作ってしまって既存コードを移行していく
  - **抽象化ブランチ**
    - 既存コードにおける主要ロジック・分離対象テーブルへのアクセス箇所について、ある程度集約した上で標準のインターフェイスを再設計し、それを満たす実装に置き換えていく
      - その後、内部実装をマイクロサービス側にAPIとして再実装し、最後に呼び出し箇所をマイクロサービスのAPI呼び出しに置き換えることで分離するパターン
    - 何らかの理由で分離するサービスの言語を変えたり、そもそも作りたいドメイン境界と既存の実装に大きく乖離があるような場合に、その間を埋めて段階的に移行していくための選択肢になる
  
![alt text](<assets/CleanShot 2024-11-04 at 21.53.04@2x.png>)

- 分離を加速するための基盤の整備
  - **標準アプリケーション構成の自動生成（freee-bootstrap / freeeops）**
    - 対象のドメインロジック実装に注力できるよう、ボイラープレートを自動生成するツールを開発
      - 。freee-bootstrap（アプリケーションコード生成）
      - freeeops（インフラコード生成）
  - **ドメインモジュールへの不正なアクセスの検知（packwerk / InvalidModuleAccessTracer）**
    - 既存コードを分離するための準備として、対象ドメインのコードを疎結合に して予期しない箇所からの呼び出しを防ぐ必要がある
      - これを防ぐため、 Shopify が作った Packwerk * 1 を使ってモジュール間の依存関係を静的に検査 する仕組みと、InvalidModuleAccessTracer という独自のツールによってモ ジュールの境界を越えた SQL 発行を動的に検出・制限する仕組みを導入した
    - **依存関係の逆転（PubSub 基盤）**
      - サービス分離しても、分離元と分離先が互いに通信し合っているようではただ の分散モノリスになってしまい、ドメインが依存したままになってしまう
      - 依存関係を逆転させ、DAG にしてシンプルにするため、サービス間の連 携に PubSub パターンを導入できる基盤が用意されている
      - この基盤を前 提にしてサービス間が繋がるようになれば、各サービスが自分のドメインこと だけを知っていればよくなる
      - また耐障害性の向上やスケールアウトのしやすさも見込める
- 結局は以下のようなことに泥臭く取り組んでいく必要があった
  - 該当実装の機能仕様の明確化とテストコードを整備する
  - 問題のある実装に起因する暗黙的な仕様をプロダクトマネージャーと相談して見 直す
  - 同時実行アプローチによって、分離したドメインロジックの結果が旧実装から変 わっていないことを保証する

#### 1.2.3 共通基盤と標準化によって分離されたサービスを統合する

- 統合分離において特に重要な領域として基盤を提供したのは以下の領域
  - **権限管理**
    - 保有ロールや ライセンス、対象リソースの属性に応じて権限判定を統一的に扱える基盤は、 権限の体験を統合するために必要不可欠
    - 特にマルチプロダクトの統合型クラウドERPにおいては、プロダクトの提供するリソースを他のプロダクトの業務で参照して適切な範囲のデータのみを参照できるようにするため、権限設定を一元的に扱える権限基盤がなくてはならない
  - **標準UI**
    - 分離されていくサービスごとに提供するUIに乖離があると、学習コストが業務の流れを阻害してしまう
  - **共通業務**
    - 申請・承認
      - 発注・受注の承認を得たり、勤怠を締める確認をしたり、上長など誰かの承認を得てその証跡を残すことはさまざまな業務で現れる要求
        - 承認者のことを考えると、分離によって各サービスごとに独自でこの機能を開 発してしまうと、自分の確認が必要なすべての申請に対応するために各サービスを行ったり来たりすることになる
      - 見なければならない申 請・承認が一元化されていて、ここだけ見ていればいいようにすることが 統合体験に繋がる
        - 共通の申請・承認基盤はこういった申請・承認機能の開発とデータの一元化を支援する
  - **通知**
    - 通知の基盤を提供することで Slack や LINE などコミュニケーションツールと連携したり、ツール上ですぐ アクションを実行したりできるようになることで、業務上のコミュニケー ション分断が解消されることを目指している
  
#### 1.2.4 対象ドメインの開発制限方針を策定する

- サービスの分離にはコストがかかり、それなりの期間を要することが想定される
  - 世間一般のよくあるシステムリプレースのプロジェクトでは一定期間の開発凍結を決断して いる事例も見受けられますが、その間に対象のドメインをまったく進化させられないのは ユーザーにとってもfreeeにとっても嬉しくない
  - とはいえリアーキテクチャし ようとしているドメインをそのまま今まで通り開発し続けては分離も進まないので、開発 を制限するための方針を明文化する必要があった
- 統合分離プロジェクトにおいて設定した開発制限方針は大まかに言うと以下のような内容
  - 分離対象となっているドメインに手を入れるときはまずサービス分離してから開発することを原則とする
  - 何らかの理由で分離を待てない場合は1年以内に分離するロードマップを計画した上で開発してもよい
  - それ以外の例外対応は基盤の責任者と合意して決める

- 基本的にはビジネス上の優先度に配慮して柔軟に判断していた
  - 結果として分離しないまま開発を進めることを許容するケースも多くあったが、この制限方針によって少なくとも方針の相談が集まるようになり、今後の分離を妨げるような開発が起きていないかを把握できるようになった
  - > とはいえ対象ドメインへの開発をすべて中央集権的に チェックしないといけないのは大変だったので、まずは分離を選択して自律的に動いても らえるような周知を根気よく続けていくことも大事だったと思います。

## 1.3 今後の展望

- 最初に思い描いていた理想のアーキテクチャにはまだ道半ばだが、統合分離プロジェクトの最初のスコープにおいては一定の成果も生み出された
  - 統合分離のため開発された共通基盤や標準化もプロダクト開発の資産として活用できるようになり、分離だけでなく新規プロダクト開発の加速にも寄与できるようになった
- この規模のプロダクト開発において最適なシステムアーキテクチャとユーザー体験を両立するためには、標準化と共通基盤の存在が必要不可欠
  - 今後は共通基盤をさら に発展させて、業務フロー全体を簡単に構築できるような開発を実現したいと考えている

## 第2章 インダビュー:新しい業務システムを作るために必要な思想を巡って

### 2.2 余白論 ∼ SaaS プロダクトのあり方の理想を追え ∼

#### 2.2.1 適度な余白を作れ。でもその「適度」ってなに？

- SaaSアプリケーションを作るときのコツ
  - 適度な余白をつくる
  - 概念定義をとことんやる
  - 拡張性・保守性・共通化・標準化
- PdLとは？
  - プロダクトリード; Product Lead
  - 開発組織内で利用されるロールの1 つで、以下のようなスキルが求められている
    - 課題の発見
    - 自身およびチームの技術力で問題の開発に導く
    - プロダクト価値・事業貢献へのこだわり
    - 最速で届けきる

- 適度な余白はとは？
  - 「多くのユーザの多様なユースケースを賄えるように作ること。ユースケースは可能なかぎり想定して作るべきだが、想定し切れないのが現実。なのでユーザーに使い方を委ねていくのも大切。それがすなわち「適度な余白」だ」
  - > 例えば、お客さん A, B, C では絶対こうだから、こういう風にしかならない！ って言って強い制限をかけちゃったり、そこでしか使えないモノを作るってしまう。そうすると、もしかしたら D, E, F そしてもっとずっと沢山いるであろう他のお客さんは、そのシステムを全然使えなくなるかもしれないじゃないですか。 「余白を作る」っていったときに色々意味はあるんだけれど…… 目先の範囲に囚われ過ぎず、自ら想像力を働かせるのが重要なんですよね。それで、想像力を働かせてできた仮説でもってプロダクトを作る。 我々が作りたいシステムは別にオーダーメードというわけではないので、あくまで前提や 参考にはするんだけれど、そこにフィットさせ過ぎない。要求を満たしつつ、外でも使える状態をつくるのが大切ですね。

#### 2.2.2 ついついやっちゃう「ガチガチ開発」

- validationなどガチガチにやってしまうと余白がなくなる

#### 2.2.3 ペルソナが効くときっていつ？

>アジャイル開発の手法としてのユーザーストーリーマッピングの中で、「じゃあまずはペルソナを1個置いてみよう」となったとして。そのペルソナというのが具体的なお客さんとほぼ一致した状態でシステムを作ってしまってしまうと、そのお客さんだけに特化したシステムをうっかり作ってしまう、みたいな失敗談は私にもあるんですよね。じゃあ、より様々な事例をみるためにもっと沢山のペルソナを考えよう…… といっても、それはそれでうまく行かない。そこにやっぱり難しいなっていう感触もあって。ただ、ペルソナはペルソナで僕は大事だと思ってるんですよ。一個の「こんな姿かも」っていうのをみんなで想像するためのツールとしては有用です。それと比べるとnomusanの思想は、「ペルソナの拡張」とも言えるんでしょうか。なんか、いい言葉がみつからないんですけど（笑

- バーニングニーズの考え方と異なる?

#### データモデリングと開発プロセス

- freee販売・工数管理ではチームの進行自体はスクラムをとっているが、開発プロセス上で「データモデリング」や「仕様への議論」を行うことを心がけたものとなっている。
- 実装を進める前に行っている、大きな流れで以下のような流れとなる
  - **要求定義**
    - PdMを中心にユーザにどのような体験を提供したいのかを中心に定義する。「∼は∼したい。」というユーザストーリーやユースケースを列挙したものを成果物とする。
  - **要件定義**
    - PdLを中心に、要求を実現するにはどのように実現するのかを中心に定義する。「A画面において、∼という項目を一覧できる」といった具体レベルを列挙したものをまとめ、要求に接続する。
  - **外部設計**
    - 必要な論理データ型と項目を定義する。論理データ型は、「金額はxx桁以内で小数点を持たない、0以上」といった制約情報をまとめたもので、アプリケーションの実装時は値オブジェクトに対応する。項目では特定の「データ」について以下のような情報をまとめる
      - 項目名
      - どのタイミングで入力されるか（補完されるか）
      - どのように項目が使われるか（表示や複製時の挙動など）
  - **内部設計**
    - 要件を満たすためにどのような技術を使うかといった情報をまとめる。freeeではDesign Docという設計ドキュメントをまとめており、以下のような情報を記載する:
      - 開発の範囲:
        - なにをやらないのか?
      - モデル図・コンテキスト図
      - API:
        - 開発時にOpenAPIを作ることになるので、入出力の概要とアクセス方法にとどまる
      - ストレージ・データベーススキーマ
      - テスト方法
      - リリース方法: feature ﬂag での管理方法について
      - リスク:
        - 実装によっておきると「ヤバい」ことや、既存システムへの影響をまとめる

#### 概念定義をミスるとこうなる

- > 名前、つまり概念の定義は人間の理解にとって非常に大事なことです。すごくプラクティカルに言ってしまえば「概念定義をミスるとコード内の変数名をミスるので、単純に後で色々面倒くさい」となります。例えば「受注」という概念を定義するとき、これを指して「注文（order）」という名前でコードを書き始めますと。で、後から「発注」が出てきた時に「あれ、実はこれも『注文』の一部じゃない？」となる。

- 概念定義に余白(意味が曖昧になるような言葉)はいらない

#### たとえひとつ目でも「共通化」する？

- コーディングレベルだとYAGNI 原則*5とか「早すぎる共通化」みたいな話は頷けるが、概念レベルの場合は「ここに共通の概念があるはずだよね」という発見はあらかじめしておかなければならない
- 「要らないものはずっと要らない」とか言っちゃいがちだが、あくまでコーディングの話であって、概念レベルでそれを言い出すと、ほとんどの場合は後で困ってしまう。
- 想定不足とYAGNIはまた違う話
