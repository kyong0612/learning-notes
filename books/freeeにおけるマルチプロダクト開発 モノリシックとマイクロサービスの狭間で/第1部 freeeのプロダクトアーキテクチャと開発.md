# 第1部 freeeのプロダクトアーキテクチャと開発

## 第1章 成熟したプロダクトの大規模リアーキテクチャ ~ 統合分離への挑戦 ~

### 1.1 freeeのアーキテクチャ特性と成長に伴う課題

- freeeのシステムアーキテクチャ特性
  - プロダクトにおける進化スピードを最速に維持することを重視している
  - スモールビジネスの経営にまつわる業務とその 領域は非常に多岐にわたり、それらに最速で価値を届け続けるためには新規プロダクトや機能改善を素早く開発できることが求められる
  - しかしビジネスが成長し、開発組織・プロダクトの数・事業所数などの規模が大きくなるにつれ、これらの特性を維持する難易度は上がっていく
    - 特に創業期からのプロダクトであるfreee会計はコードベースが非常に巨大なモノリスとなっていて、その業務の特性も相まってさまざまな機能が複雑に依存し合うようになったことで、機能を追加した時の影響範囲が読みきれず拡張が困難になっていた
    - コードベースが巨大なのでリファクタリングなどの内部品質の向上も一筋縄ではいかず、技術的負債が蓄積しやすくなっている
    - 一定規模以上の法人ユーザーが増えたことでデータ量やトラフィックも増加したが、データの依存関係も複雑になっているため、スケールアウトの難易度も上がっていた
- これらの課題を解決するため、社内の技術リーダーたちを中心に議論を行い、結論としてサービス分離によるシステムのリアーキテクチャによって多くの課題が解決できると判断した
  - この戦略に基づき、巨大なモノリスとなったシステムをドメイン境界に合わせて適切に「分離」してシステムと体験を「統合」することで、freee全体のリアーキテクチャを行う「統合分離」と呼ばれるプロジェクトが立ち上がった

![alt text](<assets/CleanShot 2024-11-04 at 21.14.41@2x.png>)

### 1.2 統合分離とその戦略

- すでにいくつかの機能をマイクロサービス化している経験もあり、サービス分離にはそれに伴うコストや分離すること自体のデメリットもあることがわかっていた
  - 単純に機能をそのままマイクロサービスに分けるとデータベーストランザクションが別れてしまい、データの整合性を担保する難易度が増大することが考えられる
  - 1つの機能を提供するのに複数のサービスを呼び出すことによるネットワーキングコストの増大とそれによる体験劣化
- リアーキテクチャの恩恵を享受するために、大きく分けて2つの戦略で推進することになった
  - ドメインの境界を基準としたサービス分離によって依存関係をシンプルにする
  - 標準化・共通基盤によって分離されたサービスの開発とその統合を支援する

#### 1.2.1 ドメインを分析し境界を見つける

- 整合性担保や通信オーバーヘッドなどのサービス分離にまつわる多くの課題は、依存関 係の複雑さに起因している
- これを解決して依存関係をシンプルにするには、強く依存する業務とそうでない業務の境界を見つけるドメイン分析が必要になる

> この時に現在のシステム構造に 引っ張られないようにし、まずは対象のドメインについてあるべき業務フローから分析を していきます。freee ではプロダクトマネージャーやドメインエキスパートのような対象 業務に詳しい人が社内にいるので、その協力を仰ぐことが多いです

![alt text](<assets/CleanShot 2024-11-04 at 21.31.02@2x.png>)

- 理想の業務フローが整理されて依存関係が可視化されても、現状のシステム構造を考慮しないと実現性に乏しいものになってしまう
  - 現状のシステムにおけるデータベーステーブルやコードとドメインのマッピングを作ることで、分析によって洗い出したドメインに抜け漏れがないかのチェックや、分析によって見つけたドメイン境界の中で現実と大きなズレがあるところの可視化などに役立つ

![alt text](<assets/CleanShot 2024-11-04 at 21.32.11@2x.png>)

- これらのアプローチをもとに、適切な単位のドメイン境界を決める
- 理想と現実を照らし合わせた上で塩梅の取れたドメイン境界を決めていく

#### 1.2.2 どうやって分離するかを決める

- 以下の軸によって対象ドメインの分離をスコアリングし、上位のものを優先して対応していくこととした
  - ビジネス優先度(どのくらい活発に開発されるのか)
  - 生産性・パフォーマンス等の改善見込み(どのくらい分離の効果があるか)
  - 分離する難易度(分離にどのくらい開発コストがかかるか)

![alt text](<assets/CleanShot 2024-11-04 at 21.38.06@2x.png>)

- 分離の開発パターン
  - **v2 新規実装**
    - 扱うドメインは同じだがデータモデル含め全く新しいサービスを設計し実装するパターン
    - 既存のプロダクトに手を入れずに新規プロダクトのように独立して開発できるメリットはあるが、既存ユーザに利用してもらうためには移行の負担を強いることになるデメリットがある
    - このパターンを採用するのはシステムアーキテクチャとしての分離よりも、ドメインそのものを見直して新たな価値を創造したいというのが主な動機になる
  - **コンポーネントベース分離**
    - 分離したいドメインロジックについて、まずシステム内部でモジュールとして隔離(モジュラーモノリス化)を行う
      - 次に新しいマイクロサービスを立ち上げてモジュールの実装を移植し、分離元の依存コードの向き先を徐々に新しいサービスに変えていくパターン
    - 既存実装への依存関係がすでに複雑であったり品質が低くそのまま分離しても流用できない時に、まずモジュール化によって疎結合にしてから分離する選択肢になる
    - 既存コードのリファクタリングの延長から始まるため、他のアプローチに比べて二重メンテナンスの問題は起きづらいが、分離の効果が生まれるまで比較的時間がかかることが想定される
  - **戦略的fork**
    - 分離したいシステムをコピーして対象ドメインに不要なコードを削った新しいサービスを立ち上げ、分離元の依存コードの向き先を徐々にforkしたサービスに置き換えていくパターン
    - コンポーネントベース分解はまず先に分離元システム内でモジュール境界を切ってから新しいサービスへ移行していくが、戦略的forkではまず丸ごとコピーしてしまうことで分離された新しいサービスを先に作ってしまって既存コードを移行していく
  - **抽象化ブランチ**
    - 既存コードにおける主要ロジック・分離対象テーブルへのアクセス箇所について、ある程度集約した上で標準のインターフェイスを再設計し、それを満たす実装に置き換えていく
      - その後、内部実装をマイクロサービス側にAPIとして再実装し、最後に呼び出し箇所をマイクロサービスのAPI呼び出しに置き換えることで分離するパターン
    - 何らかの理由で分離するサービスの言語を変えたり、そもそも作りたいドメイン境界と既存の実装に大きく乖離があるような場合に、その間を埋めて段階的に移行していくための選択肢になる
  
![alt text](<assets/CleanShot 2024-11-04 at 21.53.04@2x.png>)

- 分離を加速するための基盤の整備
  - **標準アプリケーション構成の自動生成（freee-bootstrap / freeeops）**
    - 対象のドメインロジック実装に注力できるよう、ボイラープレートを自動生成するツールを開発
      - 。freee-bootstrap（アプリケーションコード生成）
      - freeeops（インフラコード生成）
  - **ドメインモジュールへの不正なアクセスの検知（packwerk / InvalidModuleAccessTracer）**
    - 既存コードを分離するための準備として、対象ドメインのコードを疎結合に して予期しない箇所からの呼び出しを防ぐ必要がある
      - これを防ぐため、 Shopify が作った Packwerk * 1 を使ってモジュール間の依存関係を静的に検査 する仕組みと、InvalidModuleAccessTracer という独自のツールによってモ ジュールの境界を越えた SQL 発行を動的に検出・制限する仕組みを導入した
    - **依存関係の逆転（PubSub 基盤）**
      - サービス分離しても、分離元と分離先が互いに通信し合っているようではただ の分散モノリスになってしまい、ドメインが依存したままになってしまう
      - 依存関係を逆転させ、DAG にしてシンプルにするため、サービス間の連 携に PubSub パターンを導入できる基盤が用意されている
      - この基盤を前 提にしてサービス間が繋がるようになれば、各サービスが自分のドメインこと だけを知っていればよくなる
      - また耐障害性の向上やスケールアウトのしやすさも見込める
- 結局は以下のようなことに泥臭く取り組んでいく必要があった
  - 該当実装の機能仕様の明確化とテストコードを整備する
  - 問題のある実装に起因する暗黙的な仕様をプロダクトマネージャーと相談して見 直す
  - 同時実行アプローチによって、分離したドメインロジックの結果が旧実装から変 わっていないことを保証する

#### 1.2.3 共通基盤と標準化によって分離されたサービスを統合する

- 統合分離において特に重要な領域として基盤を提供したのは以下の領域
  - **権限管理**
    - 保有ロールや ライセンス、対象リソースの属性に応じて権限判定を統一的に扱える基盤は、 権限の体験を統合するために必要不可欠
    - 特にマルチプロダクトの統合型クラウドERPにおいては、プロダクトの提供するリソースを他のプロダクトの業務で参照して適切な範囲のデータのみを参照できるようにするため、権限設定を一元的に扱える権限基盤がなくてはならない
  - **標準UI**
    - 分離されていくサービスごとに提供するUIに乖離があると、学習コストが業務の流れを阻害してしまう
  - **共通業務**
    - 申請・承認
      - 発注・受注の承認を得たり、勤怠を締める確認をしたり、上長など誰かの承認を得てその証跡を残すことはさまざまな業務で現れる要求
        - 承認者のことを考えると、分離によって各サービスごとに独自でこの機能を開 発してしまうと、自分の確認が必要なすべての申請に対応するために各サービスを行ったり来たりすることになる
      - 見なければならない申 請・承認が一元化されていて、ここだけ見ていればいいようにすることが 統合体験に繋がる
        - 共通の申請・承認基盤はこういった申請・承認機能の開発とデータの一元化を支援する
  - **通知**
    - 通知の基盤を提供することで Slack や LINE などコミュニケーションツールと連携したり、ツール上ですぐ アクションを実行したりできるようになることで、業務上のコミュニケー ション分断が解消されることを目指している
  
#### 1.2.4 対象ドメインの開発制限方針を策定する

- サービスの分離にはコストがかかり、それなりの期間を要することが想定される
  - 世間一般のよくあるシステムリプレースのプロジェクトでは一定期間の開発凍結を決断して いる事例も見受けられますが、その間に対象のドメインをまったく進化させられないのは ユーザーにとってもfreeeにとっても嬉しくない
  - とはいえリアーキテクチャし ようとしているドメインをそのまま今まで通り開発し続けては分離も進まないので、開発 を制限するための方針を明文化する必要があった
- 統合分離プロジェクトにおいて設定した開発制限方針は大まかに言うと以下のような内容
  - 分離対象となっているドメインに手を入れるときはまずサービス分離してから開発することを原則とする
  - 何らかの理由で分離を待てない場合は1年以内に分離するロードマップを計画した上で開発してもよい
  - それ以外の例外対応は基盤の責任者と合意して決める

- 基本的にはビジネス上の優先度に配慮して柔軟に判断していた
  - 結果として分離しないまま開発を進めることを許容するケースも多くあったが、この制限方針によって少なくとも方針の相談が集まるようになり、今後の分離を妨げるような開発が起きていないかを把握できるようになった
  - > とはいえ対象ドメインへの開発をすべて中央集権的に チェックしないといけないのは大変だったので、まずは分離を選択して自律的に動いても らえるような周知を根気よく続けていくことも大事だったと思います。

## 1.3 今後の展望

- 最初に思い描いていた理想のアーキテクチャにはまだ道半ばだが、統合分離プロジェクトの最初のスコープにおいては一定の成果も生み出された
  - 統合分離のため開発された共通基盤や標準化もプロダクト開発の資産として活用できるようになり、分離だけでなく新規プロダクト開発の加速にも寄与できるようになった
- この規模のプロダクト開発において最適なシステムアーキテクチャとユーザー体験を両立するためには、標準化と共通基盤の存在が必要不可欠
  - 今後は共通基盤をさら に発展させて、業務フロー全体を簡単に構築できるような開発を実現したいと考えている

## 第2章 インダビュー:新しい業務システムを作るために必要な思想を巡って

### 2.2 余白論 ∼ SaaS プロダクトのあり方の理想を追え ∼

#### 2.2.1 適度な余白を作れ。でもその「適度」ってなに？

- SaaSアプリケーションを作るときのコツ
  - 適度な余白をつくる
  - 概念定義をとことんやる
  - 拡張性・保守性・共通化・標準化
- PdLとは？
  - プロダクトリード; Product Lead
  - 開発組織内で利用されるロールの1 つで、以下のようなスキルが求められている
    - 課題の発見
    - 自身およびチームの技術力で問題の開発に導く
    - プロダクト価値・事業貢献へのこだわり
    - 最速で届けきる

- 適度な余白はとは？
  - 「多くのユーザの多様なユースケースを賄えるように作ること。ユースケースは可能なかぎり想定して作るべきだが、想定し切れないのが現実。なのでユーザーに使い方を委ねていくのも大切。それがすなわち「適度な余白」だ」
  - > 例えば、お客さん A, B, C では絶対こうだから、こういう風にしかならない！ って言って強い制限をかけちゃったり、そこでしか使えないモノを作るってしまう。そうすると、もしかしたら D, E, F そしてもっとずっと沢山いるであろう他のお客さんは、そのシステムを全然使えなくなるかもしれないじゃないですか。 「余白を作る」っていったときに色々意味はあるんだけれど…… 目先の範囲に囚われ過ぎず、自ら想像力を働かせるのが重要なんですよね。それで、想像力を働かせてできた仮説でもってプロダクトを作る。 我々が作りたいシステムは別にオーダーメードというわけではないので、あくまで前提や 参考にはするんだけれど、そこにフィットさせ過ぎない。要求を満たしつつ、外でも使える状態をつくるのが大切ですね。

#### 2.2.2 ついついやっちゃう「ガチガチ開発」

- validationなどガチガチにやってしまうと余白がなくなる

#### 2.2.3 ペルソナが効くときっていつ？

>アジャイル開発の手法としてのユーザーストーリーマッピングの中で、「じゃあまずはペルソナを1個置いてみよう」となったとして。そのペルソナというのが具体的なお客さんとほぼ一致した状態でシステムを作ってしまってしまうと、そのお客さんだけに特化したシステムをうっかり作ってしまう、みたいな失敗談は私にもあるんですよね。じゃあ、より様々な事例をみるためにもっと沢山のペルソナを考えよう…… といっても、それはそれでうまく行かない。そこにやっぱり難しいなっていう感触もあって。ただ、ペルソナはペルソナで僕は大事だと思ってるんですよ。一個の「こんな姿かも」っていうのをみんなで想像するためのツールとしては有用です。それと比べるとnomusanの思想は、「ペルソナの拡張」とも言えるんでしょうか。なんか、いい言葉がみつからないんですけど（笑

- バーニングニーズの考え方と異なる?

#### データモデリングと開発プロセス

- freee販売・工数管理ではチームの進行自体はスクラムをとっているが、開発プロセス上で「データモデリング」や「仕様への議論」を行うことを心がけたものとなっている。
- 実装を進める前に行っている、大きな流れで以下のような流れとなる
  - **要求定義**
    - PdMを中心にユーザにどのような体験を提供したいのかを中心に定義する。「∼は∼したい。」というユーザストーリーやユースケースを列挙したものを成果物とする。
  - **要件定義**
    - PdLを中心に、要求を実現するにはどのように実現するのかを中心に定義する。「A画面において、∼という項目を一覧できる」といった具体レベルを列挙したものをまとめ、要求に接続する。
  - **外部設計**
    - 必要な論理データ型と項目を定義する。論理データ型は、「金額はxx桁以内で小数点を持たない、0以上」といった制約情報をまとめたもので、アプリケーションの実装時は値オブジェクトに対応する。項目では特定の「データ」について以下のような情報をまとめる
      - 項目名
      - どのタイミングで入力されるか（補完されるか）
      - どのように項目が使われるか（表示や複製時の挙動など）
  - **内部設計**
    - 要件を満たすためにどのような技術を使うかといった情報をまとめる。freeeではDesign Docという設計ドキュメントをまとめており、以下のような情報を記載する:
      - 開発の範囲:
        - なにをやらないのか?
      - モデル図・コンテキスト図
      - API:
        - 開発時にOpenAPIを作ることになるので、入出力の概要とアクセス方法にとどまる
      - ストレージ・データベーススキーマ
      - テスト方法
      - リリース方法: feature ﬂag での管理方法について
      - リスク:
        - 実装によっておきると「ヤバい」ことや、既存システムへの影響をまとめる

#### 概念定義をミスるとこうなる

- > 名前、つまり概念の定義は人間の理解にとって非常に大事なことです。すごくプラクティカルに言ってしまえば「概念定義をミスるとコード内の変数名をミスるので、単純に後で色々面倒くさい」となります。例えば「受注」という概念を定義するとき、これを指して「注文（order）」という名前でコードを書き始めますと。で、後から「発注」が出てきた時に「あれ、実はこれも『注文』の一部じゃない？」となる。

- 概念定義に余白(意味が曖昧になるような言葉)はいらない

#### たとえひとつ目でも「共通化」する？

- コーディングレベルだとYAGNI 原則*5とか「早すぎる共通化」みたいな話は頷けるが、概念レベルの場合は「ここに共通の概念があるはずだよね」という発見はあらかじめしておかなければならない
- 「要らないものはずっと要らない」とか言っちゃいがちだが、あくまでコーディングの話であって、概念レベルでそれを言い出すと、ほとんどの場合は後で困ってしまう。
- 想定不足とYAGNIはまた違う話

### 2.3 マイクロサービスとの付き合い方

#### 2.3.1 時にはマイクロサービスをひっくり返せ

- 積極的に文句を言っていく
  - feedbackがないと改善がない
  - 基盤を利用するときの所与の条件はあるにせよ、こちらからも関与することはできる

#### 2.3.2 共通基盤メンバーと、同じ飯の窯を食う

- freee販売の初期には、ミッションが2つあった
  - メインは「販売をリリースすること」
  - もう1つは「今後の新規プロダクトで使える共通パーツを作りながら踏み込んでいく」
  - 現実問題、一緒のチームでやるしかないと
  - > 基盤づくりと製品づくりはもう一緒にやっていかないと、基盤も製品も良くなっていかないし、完成もしていかないと。それぞれの好循環を考えなきゃいけないという感じなんですね。

## 第3章 アクセス制御基盤

### 3.1 はじめに

### 3.2 アクセス制御システムの基礎知識

#### 3.2.1 アクセス制御とは

- アプリケーションにおけるアクセス制御とは
  - アプリケーションが提供する様々なリソースに対するユーザのアクセスを管理および制御することを意味する
  
![alt text](<assets/CleanShot 2024-11-09 at 21.26.47@2x.png>)

#### 3.2.2 アクセス制御システムのコンポーネント

![alt text](<assets/CleanShot 2024-11-09 at 21.29.05@2x.png>)

- **リクエスター**
  - アクセス要求を初めて開始するentityで、ユーザーやアプリケーションなどが該当する
- **ポリシー実施ポイント(PEP: Policy Enforcement Point)**
  - PEPはリクエスターからのリソースに対するアクセス要求を受け取り、ポリシー決定ポイント(PDP)に送信する。その後、PEPは、PDPから返却された認可決定(許可または拒否)をリクエスターのリソースに対するアクセス要求に適用する
- **ポリシー決定ポイント(PDP: Policy Decision Point)**
  - PDPは、PEPから送られてきたアクセス要求に対するアクセス制御ポリシーを評価し、アクセス要求が許可されるべきか否かの決定(認可決定)を生成する
- **ポリシー情報ポイント(PIP: Policy Information Point)**
  - PIPは、PDPがアクセス要求に対するアクセス制御ポリシーを評価するために追加で情報が必要な場合にその情報を提供する
- **ポリシー管理ポイント(PAP: Policy Administration Point)**
  - PAPは、アクセス制御ポリシーの作成や変更など、アクセス制御のポリシーライフサイクルの全体を管理する

#### 3.2.3 アクセス制御システムのアーキテクチャパターン

##### 全てのコンポーネントをアプリケーションごとに配置するパターン

![alt text](<assets/CleanShot 2024-11-09 at 21.37.15@2x.png>)

- メリット
  - コンポーネントをアプリケーション間で共有する必要がないため、コンポーネントの実装をアプリケーションごとのドメインに特化できる
  - 特定のアプリケーションにおけるコンポーネントの障害が他のアプリケーションに波及しない
- デメリット
  - アプリケーションごとのドメインや実装の違いが反映されることで、ユーザーに一貫性にあるアクセス制御の体験(特にアクセス制御ルールの粒度や設定)を提供するのが難しい
  - アプリケーションの開発者がアクセス制御にちて十分に理解し、正しくコンポーネントを実装・メンテナンスできなければならない
  - 他のアプリケーションにリソースにアクセスする場合に、アクセス先のアプリケーションにおけるコンポーネントの実装を正しく理解し利用する必要がある

- マイクロサービスのような複数のアプリケーションでシステムを構成している場合にメリットがデメリットを上回る可能性を考える必要がある

##### PEPをアプリケーションごとに配置するパターン

![alt text](<assets/CleanShot 2024-11-09 at 21.42.43@2x.png>)

- メリット
  - 全てのアプリケーションがユーザーに一貫性のあるアクセス制御の体験を提供できる
  - アプリケーションの開発者は、コンポーネントを実装・メンテナンスする必要がない
- デメリット
  - 集中管理するコンポーネントの障害が全てのアプリケーションに影響する
  - 特定のアプリケーションのドメインに特化したアクセス制御には対応しづらい、もしくは対応できない

- 集中管理するコンポーネントがSPOF(Single Point Of Failure)となることを避けるために非常に高い水準の可能性を担保するための対応が求められることに注意が必要
-

##### PEPとPDPをアプリケーションごとに配置するパターン

![alt text](<assets/CleanShot 2024-11-09 at 21.45.39@2x.png>)

- メリット
  - 全てのアプリケーションがユーザーに一貫性のあるアクセス制御の体験を提供できる
  - アプリケーションの開発者は、コンポーネントを実装・メンテナンスする必要がない
  - PEP や PDP で障害があっても他のアプリケーションには影響が及ばない
- デメリット
  - 特定のアプリケーションのドメインに特化したアクセス制御には対応しづらい、もしくは対応できない

- PDPが持つアクセス制御ポリシーのキャッシュを更新/無効化する戦略について慎重に考える必要がある

### 3.3 freeeにおけるアクセス制御システムのアーキテクチャ

#### 3.3.1 freee におけるアクセス制御の歴史と課題

- freeeはこれまでスモールビジネスの広範な要求を満たすべく、会計にはじまり、給与計算、会社設立、開業など、様々な領域のアプリケーションを提供してきた
  - 現在では、満たせる要求の幅が広がったことで、より良い体験を求めて、全てのアプリケーションがスムーズに連携し一貫した体験を提供する「統合体験」の実現を目指すようになっている
- それぞれの領域におけるビジネスニーズに最速で応えることを重要視していたために、アプリケーションは、それぞれの領域に合わせた独自の進化を遂げ、アプリケーション間で共通する機能でもそれぞれが独自に作り込むことが度々発生していた
- 当時の freee におけるアクセス制御システムのアーキテクチャは、前述した「全てのコンポーネントをアプリケーションごとに配置するパターン」を採用している状況であった
- 特に、「ユーザーに一貫性のあるアクセス制御の体験を提供するのが難しい」というデメリットは、「統合体験」の実現を大きく妨げる枷となっていました

#### 3.3.2 freeeの新しいアクセス制御基盤

- freeeの新しいアクセス制御基盤が持つ特徴をまとめると次のようになる
  - 「統合体験」を考慮した一貫性のあるアクセス制御ルールの定義と管理
  - アプリケーション開発者がアクセス制御の方式をドメインに合わせて柔軟に組み合わせ可能
  - アクセス制御基盤の存在を意識しない開発者体験

- 「統合体験」を考慮した一貫性のあるアクセス制御ルールの定義と管理」は、PAP の共通化が必須
- 我々は、新しいアクセス制御基盤のアー キテクチャとして「PEP をアプリケーションごとに配置するパターン」を採用するという意思決定をした

![alt text](<assets/CleanShot 2024-11-09 at 21.58.24@2x.png>)

- PEPをライブラリではなく、独立したプロキシとして提供
  - PEPをライブラリではなくプロキシとすることで、アプリケーションから完全に外部化し、アプリケーション開発者がアクセス制御に関して全く意識する必要がなくなることを意図している
- アクセス制御ポリシーをアプリケーションごとの設定ファイルとして管理
  - アクセス制御ポリシーをアプリケーションのリポジトリ上に設定ファイルとして配 置することで、アプリケーション開発者が設定ファイルでアクセス制御ポリシーを 記述するという体験を維持することを意図している
    - リポジトリ上の 設定ファイルを PAP に変換して登録するジョブを用意し、アプリケーションのデ プロイ時にキックすることでアクセス制御ポリシーを登録している

#### 3.3.3 アーキテクチャの変化で生まれた難しさ

- **コンポーネントの外部化と開発体験のバランス**
  - 新しいアクセス制御基盤を導入することにより、アプリケーションのアクセス制御コンポーネントは外部化され、アプリケーションの開発者が自らこれを実装する必要はなくなった
  - しかし、これは同時に開発環境における通信経路の複雑化やアクセス制御の挙動のブラックボックス化といった開発体験の変化を招くことにも繋がった
    - 導入当初は、アプリケーション開発者から「開発環境構築がうまくいかない」、「アク セス制御に関わる問題の原因特定が難しくなった」といった声が多く上がるようになっていた
  - そうした声に対して、まず、アクセス制御基盤の挙動を可視化するための機能の追加やドキュメントの整備といった対応を行うことで開発体験の向上を試みていた
  - しかし、最終的には、一部（PEP）のコンポーネントをライブラリ化してアプリケーションの内部に戻すというアーキテクチャレベルの調整を行い、それが最もアプリケーション開発者に歓迎される結果となりました。
  - 元々、アクセス制御のコンポーネントをアプリケーションから外部化することで、アプリケーション開発者がアクセス制御について十分に理解する必要がなくなることを狙っていた
  - しかし、この結果は、実際のところアプリケーション開発者はアクセス制御について理解した上で利用する ことを求めており、過度な外部化は開発体験を悪化させることがあることを示していた
  - このことから、アーキテクチャ設計においてコンポーネントの関係を疎にすることが 必ずしも良い結果を生むわけではなく、システムのステークホルダーの要求の実態を把握し、全体として最適なバランスを求めることが肝要であることを再認識することになった
- **安全なアクセス制御ルールのマイグレーション**
  - アプリケーションごとのアクセス制御から新しいアクセス制御基盤へのマイグレーションをデグレすることなく安全に行えるかは、アプリケーション開発者にとって極めて重要な関心ごと
  - デグレが起こる要因として、次のようなものが考えられる
    - アプリケーションごとに作り込んだアクセス制御に設定していたアクセス制御ルールを、新しいアクセス制御基盤に設定する過程で誤りや欠落が生じた
    - 新しいアクセス制御基盤におけるアクセス制御ルールの評価にバグが存在した
    - 同じアクセス制御ルールでも評価の方法に差異があった
  - これらの要因は、新しいアクセス制御基盤が単に既存のアプリケーションのコンポーネントを外部化したのではなく、複数のアプリケーションの要件を元に再設計されたものであることを考慮すると、十分に発生し得るもの
  - これらが起こらないことを確認す るために最も確実な方法は、完全なリグレッションテストを用意してマイグレーション後 でも問題なく通るか確認すること
  - しかし、アプリケーションが完全なリグレッションテストを用意することは、開発のコストやスピードの観点から現実的ではないことがほとんど
    - そうなると、後は、手動のE2Eなどでテストすることになりますが、機能が多く拡張を続けてきたようなアプリケーションではどうしてもエッジケースを拾いきれな いといったことが出てきてしまう
  - そこで、PEPがアクセス要求の認可決定を取得するが適用は行わないExperimental Modeと呼ばれるモードを実装した
  - ![alt text](<assets/CleanShot 2024-11-09 at 22.11.07@2x.png>)
  - Experimental Mode では、PEPが、アクセス要求に対する認可決定をPDPから取得した後は、アクセス制御を行わず、認可決定をリクエストのコンテキストに経由してアプリケーションに渡すという動作をする
  - アプリケーションは、独自に作り込んだアクセス制御の認可決定と新しいアクセス制御基盤の認可決定を比較し、差分があれば通知するといった対応が可能
  - この 時、アプリケーションにおけるアクセス制御は、独自のアクセス制御をそのまま適用し続 けることができるため、アプリケーションがデグレすることもない
- **安全なトラフィックのマイグレーション**
  - PDPを内包する新しいアクセス制御基盤は、アプリケーションのSPOFとならざるをえず、可能な限り高いレベルの可用性を要求されることになる
  - 新しいアクセス制御基盤では、負荷に対してスケールアウト可能で障害時に迅速な復旧が可能な 冗長性を持つインフラを構築しており、通常時の運用では十分に機能していた
  - アプリケーションごとのアクセス制御からアクセス制御基盤へのマイグレーションを考えた時、実施方法次第では、そのアプリケーションの全トラフィックが新しいアクセス制御基盤に一気に流入することになる
    - スケールアウトが間に合わない量の負荷が短時間で一気に発生する可能性があることを意味している
  - そこで、次のような対応を行い、新しいアクセス制御基盤のキャパシティと負荷をコントロールし、安全なトラフィックのマイグレーションを確立しました
    - PEP に新しいアクセス制御基盤へ流すトラフィックに対する流量調整を可能にする機能を追加
    - アプリケーションごとのヒアリングと負荷試験によるキャパシティプランニングを行い事前のインフラの増設
  - 流量調整は、比較的実装が容易で、低コストで対応することが出来きた
    - Istioのようなサービスメッシュを利用できる環境であれば、更に低いコストで実現 することも出来たかもしれない
  - 一方で、キャパシティプランニングについては、非常に高コストな対応を要求されるものになった
    - なぜなら、アプリケーションのアクセスモデル作成、本番相当の試験環境構築、試験の実施とレポーティングなど、多くの対応 をアプリケーションが増える度に要求されるため
    - アクセス制御基盤の機能開発が進んでアクセス特性が大きく変わる場合も再試験を行う必要があることもさらなるコスト増の要因
    - キャパシティプランニングについては、今後も継続可能な体制の整備が大きな課題として残っており、負荷試験を容易に実施できる基盤の整備や予測モデルの構築などが検討がなされている

#### 3.3.4 今後の展望

> 新しいアクセス制御基盤は、現状、まだ全てのアプリケーションに導入できたわけではありません

- また、機能性としても、全てのアプリケーションの要求をカバーしきれていない
  - そのため、直近では、導入範囲の拡大と機能の充実を目指していくことになる
- 一方で、直近のフェーズを抜けた後に直面するであろう課題も既に見えてきた
  - ただ、それらの課題は、非常に難易度が高く、エンジニアとしての技術力がためされる挑戦的な領域となっている
  - 現在は、チームの中でも技術力の高いメン バーをアサインして、先行調査や技術検証といった仕込みを進めている

##### 可用性に対するより要求の高度化

- 新しいアクセス制御基盤で障害が発生した時、いかに影響範囲を小さくするかということがより強く求められるようになってきている
- そうした要求を満たす対応の一つとして、新しいアクセス制御基盤のアーキテクチャを「PEPとPDPをアプリケーションごとに配置するパターン」に移行することを検討している
- 部化されるため、PDP の障害が特定 のアプリケーションに局所化されることが期待できる

##### アクセス制御ポリシーの複雑化

- 現在、新しいアクセス制御基盤は、ユーザーの役割（ロール）やライセンス契約、所属組 織といった決まったサブジェクトの属性をベースにしたアクセス制御ポリシーをサポートしている
  - 今後、より多くの属性のサポートや、サブジェクトとしてユーザーのグループのサポート、オブジェクトの属性をベースとしたアクセス制御ポリシーのサポートなどが求められることが予測されている
- しかし、現状のPDPが持つアクセス制御ポリシーの評価エンジンは、元々アクセス制御ポリシーがあまり複雑化しないという要件の元、拡張性よりシンプルさを優先した設計となっている
- 今後は、PDPと評価エンジンをコンポーネントとして分離した上で、評価エンジンをより拡張性の高い 関係ベースアクセス制御（ReBAC: Relation Based Access Control）ベースのものに差し替えることを検討している

## 第4章 ワークフロー基盤

### 4.1 freeeにおける申請・承認フロー機能とワークフロー基盤

- freeeで申請・承認フローを設定できるプロダクトは、freee会計、freee人事労務、freee請求書などがあり、これらのプロダクトの申請・承認フローの機能は専用のマイクロサービス郡によって共通化されている
- freee 社内ではこれらを総称して「ワークフロー基盤」と呼んでいる

### 4.2 アーキテクチャと処理の流れ

- freeeにおける申請・承認フローは、はじめからマイクロサービスとして設計されていたわけではない
- freeeが現在のようなマルチプロダクト構成になる前、業務機能の多くはfreee会計に集約されており、申請・承認フローもfreee会計の機能の一つでした。しかし、freee 全体で のマルチプロダクト、マイクロサービス化を推し進めていく中で、業務の核を担う申請・承認フローはfreee会計から独立していたほうが都合が良く、freee会計から申請・承認フロー機能だけを切り出してマイクロサービスとして独立することになった
- freee会計での申請・承認フロー機能は Rails で実装されていましたが、マイクロサービスで切り出すときに Go で再実装され、切り出されたマイクロサービスは、初めにfreee人事労務に導入される
- もともとは freee 会計の一機能だったワークフローマイクロサービスだが、他のプロダクトで使われるにあたり、もともとあった機能に加えていくつかの実現したい要件がでてきた
  - 申請経路をプロダクト間で共有でき、その申請経路の作成、変更は各プロダクトの権限によって制御されること
  - プロダクト横断ですべての申請が見られる一覧画面を作ること
  - UIは共通のものを利用し、ユーザー体験を統一するとともに実装工数の削減を目指すこと
- 実際に、freee 人事労務では経路の設定画面だけ、freee 会計の画面に依存していた
  - あるプロダクトが申請・承認フローの機能を使うために、また別のプロダクトであるfreee会計への依存があることは望ましくなく、上記の要件を実現するためのフロントサービスが立ち上げられた
  - フロントサービスは申請・承認フローに関して UI コン ポーネントとその API の提供や関連APIの集約、ユーザーアクセスの認可を行う、いわゆるBFFのような役割を担う
  - 「BFF のような」というのは、BFF 的な機能を持っているものの、始めから BFFとして設計・企画されたわけではないため
  - また、フロントサービスと対比して、申請・ 承認フローの主だった機能を担う元のワークフローマイクロサービスをコア機能サービスと呼ぶ
  
![alt text](<assets/CleanShot 2024-11-10 at 13.03.55@2x.png>)

- ワークフロー基盤は、フロントサービスとコア機能サービスからなる
  - フロントサービス
    - ユーザの認証と認可
    - フロントエンドのUIコンポーネントと画面の提供
    - 申請や承認などのアクションが行われたときのプロダクトへのコールバック
    - 申請や承認などのアクションが行われた時のエンドユーザへの通知
  - コア機能サービス
    - 申請の状態や遷移に関する処理
    - 申請者、承認者を含む申請や進路経路データの永続化
- それらを利用するプロダクトは、APIを通じて下記のような処理を行う
  - プロダクト固有の申請慣例データの保持
  - 申請操作に応じた業務処理の実行

#### 4.2.1 処理の流れ

1. プロダクトが申請関連データを作成する
2. フロントサービスが提供するUIコンポーネントとREST APIを通じて申請の作成や承認を行う
   1. - 申請に関するUIコンポーネントはWeb Componentsによって提供される
3. フロントサービスが認証・認可をする
   1. フロントサービスは、認証基盤・認可基盤に問い合わせて、ユーザがその申請や申請経路を操作する権限があるかをチェックする
4. コア機能サービスが申請アクションの処理をする
5. フロントサービスがプロダクトへのコールバックやエンドユーザーへの通知をする
6. プロダクトがコールバックに応じて業務処理を実行する
